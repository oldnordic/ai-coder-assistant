6. Visualizations — scikit-learn 1.7.0 documentation
Skip to main content
Back to top
Ctrl
+
K
Install
User Guide
API
Examples
Community
More
Getting Started
Release History
Glossary
Development
FAQ
Support
Related Projects
Roadmap
Governance
About us
GitHub
Choose version
Install
User Guide
API
Examples
Community
Getting Started
Release History
Glossary
Development
FAQ
Support
Related Projects
Roadmap
Governance
About us
GitHub
Choose version
Section Navigation
1. Supervised learning
1.1. Linear Models
1.2. Linear and Quadratic Discriminant Analysis
1.3. Kernel ridge regression
1.4. Support Vector Machines
1.5. Stochastic Gradient Descent
1.6. Nearest Neighbors
1.7. Gaussian Processes
1.8. Cross decomposition
1.9. Naive Bayes
1.10. Decision Trees
1.11. Ensembles: Gradient boosting, random forests, bagging, voting, stacking
1.12. Multiclass and multioutput algorithms
1.13. Feature selection
1.14. Semi-supervised learning
1.15. Isotonic regression
1.16. Probability calibration
1.17. Neural network models (supervised)
2. Unsupervised learning
2.1. Gaussian mixture models
2.2. Manifold learning
2.3. Clustering
2.4. Biclustering
2.5. Decomposing signals in components (matrix factorization problems)
2.6. Covariance estimation
2.7. Novelty and Outlier Detection
2.8. Density Estimation
2.9. Neural network models (unsupervised)
3. Model selection and evaluation
3.1. Cross-validation: evaluating estimator performance
3.2. Tuning the hyper-parameters of an estimator
3.3. Tuning the decision threshold for class prediction
3.4. Metrics and scoring: quantifying the quality of predictions
3.5. Validation curves: plotting scores to evaluate models
4. Metadata Routing
5. Inspection
5.1. Partial Dependence and Individual Conditional Expectation plots
5.2. Permutation feature importance
6. Visualizations
7. Dataset transformations
7.1. Pipelines and composite estimators
7.2. Feature extraction
7.3. Preprocessing data
7.4. Imputation of missing values
7.5. Unsupervised dimensionality reduction
7.6. Random Projection
7.7. Kernel Approximation
7.8. Pairwise metrics, Affinities and Kernels
7.9. Transforming the prediction target (
y
)
8. Dataset loading utilities
8.1. Toy datasets
8.2. Real world datasets
8.3. Generated datasets
8.4. Loading other datasets
9. Computing with scikit-learn
9.1. Strategies to scale computationally: bigger data
9.2. Computational Performance
9.3. Parallelism, resource management, and configuration
10. Model persistence
11. Common pitfalls and recommended practices
12. Dispatching
12.1. Array API support (experimental)
13. Choosing the right estimator
14. External Resources, Videos and Talks
User Guide
6.
Visualizations
6.
Visualizations
#
Scikit-learn defines a simple API for creating visualizations for machine
learning. The key feature of this API is to allow for quick plotting and
visual adjustments without recalculation. We provide
Display
classes that
expose two methods for creating plots:
from_estimator
and
from_predictions
.
The
from_estimator
method generates a
Display
object from a fitted estimator,
input data (
X
,
y
), and a plot.
The
from_predictions
method creates a
Display
object from true and predicted
values (
y_test
,
y_pred
), and a plot.
Using
from_predictions
avoids having to recompute predictions,
but the user needs to take care that the prediction values passed correspond
to the
pos_label
. For
predict_proba
, select the column corresponding
to the
pos_label
class while for
decision_function
, revert the score
(i.e. multiply by -1) if
pos_label
is not the last class in the
classes_
attribute of your estimator.
The
Display
object stores the computed values (e.g., metric values or
feature importance) required for plotting with Matplotlib. These values are the
results derived from the raw predictions passed to
from_predictions
, or
an estimator and
X
passed to
from_estimator
.
Display objects have a plot method that creates a matplotlib plot once the display
object has been initialized (note that we recommend that display objects are created
via
from_estimator
or
from_predictions
instead of initialized directly).
The plot method allows adding to an existing plot by passing the existing plots
matplotlib.axes.Axes
to the
ax
parameter.
In the following example, we plot a ROC curve for a fitted Logistic Regression
model
from_estimator
:
from
sklearn.model_selection
import
train_test_split
from
sklearn.linear_model
import
LogisticRegression
from
sklearn.metrics
import
RocCurveDisplay
from
sklearn.datasets
import
load_iris
X
,
y
=
load_iris
(
return_X_y
=
True
)
y
=
y
==
2
# make binary
X_train
,
X_test
,
y_train
,
y_test
=
train_test_split
(
X
,
y
,
test_size
=
.8
,
random_state
=
42
)
clf
=
LogisticRegression
(
random_state
=
42
,
C
=
.01
)
clf
.
fit
(
X_train
,
y_train
)
clf_disp
=
RocCurveDisplay
.
from_estimator
(
clf
,
X_test
,
y_test
)
If you already have the prediction values, you could instead use
from_predictions
to do the same thing (and save on compute):
from
sklearn.model_selection
import
train_test_split
from
sklearn.linear_model
import
LogisticRegression
from
sklearn.metrics
import
RocCurveDisplay
from
sklearn.datasets
import
load_iris
X
,
y
=
load_iris
(
return_X_y
=
True
)
y
=
y
==
2
# make binary
X_train
,
X_test
,
y_train
,
y_test
=
train_test_split
(
X
,
y
,
test_size
=
.8
,
random_state
=
42
)
clf
=
LogisticRegression
(
random_state
=
42
,
C
=
.01
)
clf
.
fit
(
X_train
,
y_train
)
# select the probability of the class that we considered to be the positive label
y_pred
=
clf
.
predict_proba
(
X_test
)[:,
1
]
clf_disp
=
RocCurveDisplay
.
from_predictions
(
y_test
,
y_pred
)
The returned
clf_disp
object allows us to add another curve to the already computed
ROC curve. In this case, the
clf_disp
is a
RocCurveDisplay
that stores the computed values as attributes called
roc_auc
,
fpr
, and
tpr
.
Next, we train a random forest classifier and plot the previously computed ROC curve
again by using the
plot
method of the
Display
object.
import
matplotlib.pyplot
as
plt
from
sklearn.ensemble
import
RandomForestClassifier
rfc
=
RandomForestClassifier
(
n_estimators
=
10
,
random_state
=
42
)
rfc
.
fit
(
X_train
,
y_train
)
ax
=
plt
.
gca
()
rfc_disp
=
RocCurveDisplay
.
from_estimator
(
rfc
,
X_test
,
y_test
,
ax
=
ax
,
curve_kwargs
=
{
"alpha"
:
0.8
}
)
clf_disp
.
plot
(
ax
=
ax
,
curve_kwargs
=
{
"alpha"
:
0.8
})
Notice that we pass
alpha=0.8
to the plot functions to adjust the alpha
values of the curves.
Examples
ROC Curve with Visualization API
Advanced Plotting With Partial Dependence
Visualizations with Display Objects
Comparison of Calibration of Classifiers
6.1.
Available Plotting Utilities
#
6.1.1.
Display Objects
#
calibration.CalibrationDisplay
(prob_true, ...)
Calibration curve (also known as reliability diagram) visualization.
inspection.PartialDependenceDisplay
(...[, ...])
Partial Dependence Plot (PDP) and Individual Conditional Expectation (ICE).
inspection.DecisionBoundaryDisplay
(*, xx0, ...)
Decisions boundary visualization.
metrics.ConfusionMatrixDisplay
(...[, ...])
Confusion Matrix visualization.
metrics.DetCurveDisplay
(*, fpr, fnr[, ...])
Detection Error Tradeoff (DET) curve visualization.
metrics.PrecisionRecallDisplay
(precision, ...)
Precision Recall visualization.
metrics.PredictionErrorDisplay
(*, y_true, y_pred)
Visualization of the prediction error of a regression model.
metrics.RocCurveDisplay
(*, fpr, tpr[, ...])
ROC Curve visualization.
model_selection.LearningCurveDisplay
(*, ...)
Learning Curve visualization.
model_selection.ValidationCurveDisplay
(*, ...)
Validation Curve visualization.
previous
5.2.
Permutation feature importance
next
7.
Dataset transformations
On this page
6.1. Available Plotting Utilities
6.1.1. Display Objects
This Page
Show Source
© Copyright 2007 - 2025, scikit-learn developers (BSD License).