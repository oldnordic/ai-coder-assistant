7.6. Random Projection — scikit-learn 1.7.0 documentation
Skip to main content
Back to top
Ctrl
+
K
Install
User Guide
API
Examples
Community
More
Getting Started
Release History
Glossary
Development
FAQ
Support
Related Projects
Roadmap
Governance
About us
GitHub
Choose version
Install
User Guide
API
Examples
Community
Getting Started
Release History
Glossary
Development
FAQ
Support
Related Projects
Roadmap
Governance
About us
GitHub
Choose version
Section Navigation
1. Supervised learning
1.1. Linear Models
1.2. Linear and Quadratic Discriminant Analysis
1.3. Kernel ridge regression
1.4. Support Vector Machines
1.5. Stochastic Gradient Descent
1.6. Nearest Neighbors
1.7. Gaussian Processes
1.8. Cross decomposition
1.9. Naive Bayes
1.10. Decision Trees
1.11. Ensembles: Gradient boosting, random forests, bagging, voting, stacking
1.12. Multiclass and multioutput algorithms
1.13. Feature selection
1.14. Semi-supervised learning
1.15. Isotonic regression
1.16. Probability calibration
1.17. Neural network models (supervised)
2. Unsupervised learning
2.1. Gaussian mixture models
2.2. Manifold learning
2.3. Clustering
2.4. Biclustering
2.5. Decomposing signals in components (matrix factorization problems)
2.6. Covariance estimation
2.7. Novelty and Outlier Detection
2.8. Density Estimation
2.9. Neural network models (unsupervised)
3. Model selection and evaluation
3.1. Cross-validation: evaluating estimator performance
3.2. Tuning the hyper-parameters of an estimator
3.3. Tuning the decision threshold for class prediction
3.4. Metrics and scoring: quantifying the quality of predictions
3.5. Validation curves: plotting scores to evaluate models
4. Metadata Routing
5. Inspection
5.1. Partial Dependence and Individual Conditional Expectation plots
5.2. Permutation feature importance
6. Visualizations
7. Dataset transformations
7.1. Pipelines and composite estimators
7.2. Feature extraction
7.3. Preprocessing data
7.4. Imputation of missing values
7.5. Unsupervised dimensionality reduction
7.6. Random Projection
7.7. Kernel Approximation
7.8. Pairwise metrics, Affinities and Kernels
7.9. Transforming the prediction target (
y
)
8. Dataset loading utilities
8.1. Toy datasets
8.2. Real world datasets
8.3. Generated datasets
8.4. Loading other datasets
9. Computing with scikit-learn
9.1. Strategies to scale computationally: bigger data
9.2. Computational Performance
9.3. Parallelism, resource management, and configuration
10. Model persistence
11. Common pitfalls and recommended practices
12. Dispatching
12.1. Array API support (experimental)
13. Choosing the right estimator
14. External Resources, Videos and Talks
User Guide
7.
Dataset transformations
7.6.
Random Projection
7.6.
Random Projection
#
The
sklearn.random_projection
module implements a simple and
computationally efficient way to reduce the dimensionality of the data by
trading a controlled amount of accuracy (as additional variance) for faster
processing times and smaller model sizes. This module implements two types of
unstructured random matrix:
Gaussian random matrix
and
sparse random matrix
.
The dimensions and distribution of random projections matrices are
controlled so as to preserve the pairwise distances between any two
samples of the dataset. Thus random projection is a suitable approximation
technique for distance based method.
References
Sanjoy Dasgupta. 2000.
Experiments with random projection.
In Proceedings of the Sixteenth conference on Uncertainty in artificial
intelligence (UAI’00), Craig Boutilier and Moisés Goldszmidt (Eds.). Morgan
Kaufmann Publishers Inc., San Francisco, CA, USA, 143-151.
Ella Bingham and Heikki Mannila. 2001.
Random projection in dimensionality reduction: applications to image and text data.
In Proceedings of the seventh ACM SIGKDD international conference on
Knowledge discovery and data mining (KDD ‘01). ACM, New York, NY, USA,
245-250.
7.6.1.
The Johnson-Lindenstrauss lemma
#
The main theoretical result behind the efficiency of random projection is the
Johnson-Lindenstrauss lemma (quoting Wikipedia)
:
In mathematics, the Johnson-Lindenstrauss lemma is a result
concerning low-distortion embeddings of points from high-dimensional
into low-dimensional Euclidean space. The lemma states that a small set
of points in a high-dimensional space can be embedded into a space of
much lower dimension in such a way that distances between the points are
nearly preserved. The map used for the embedding is at least Lipschitz,
and can even be taken to be an orthogonal projection.
Knowing only the number of samples, the
johnson_lindenstrauss_min_dim
estimates
conservatively the minimal size of the random subspace to guarantee a
bounded distortion introduced by the random projection:
>>>
from
sklearn.random_projection
import
johnson_lindenstrauss_min_dim
>>>
johnson_lindenstrauss_min_dim
(
n_samples
=
1e6
,
eps
=
0.5
)
np.int64(663)
>>>
johnson_lindenstrauss_min_dim
(
n_samples
=
1e6
,
eps
=
[
0.5
,
0.1
,
0.01
])
array([    663,   11841, 1112658])
>>>
johnson_lindenstrauss_min_dim
(
n_samples
=
[
1e4
,
1e5
,
1e6
],
eps
=
0.1
)
array([ 7894,  9868, 11841])
Examples
See
The Johnson-Lindenstrauss bound for embedding with random projections
for a theoretical explication on the Johnson-Lindenstrauss lemma and an
empirical validation using sparse random matrices.
References
Sanjoy Dasgupta and Anupam Gupta, 1999.
An elementary proof of the Johnson-Lindenstrauss Lemma.
7.6.2.
Gaussian random projection
#
The
GaussianRandomProjection
reduces the
dimensionality by projecting the original input space on a randomly generated
matrix where components are drawn from the following distribution
\(N(0, \frac{1}{n_{components}})\)
.
Here is a small excerpt which illustrates how to use the Gaussian random
projection transformer:
>>>
import
numpy
as
np
>>>
from
sklearn
import
random_projection
>>>
X
=
np
.
random
.
rand
(
100
,
10000
)
>>>
transformer
=
random_projection
.
GaussianRandomProjection
()
>>>
X_new
=
transformer
.
fit_transform
(
X
)
>>>
X_new
.
shape
(100, 3947)
7.6.3.
Sparse random projection
#
The
SparseRandomProjection
reduces the
dimensionality by projecting the original input space using a sparse
random matrix.
Sparse random matrices are an alternative to dense Gaussian random
projection matrix that guarantees similar embedding quality while being much
more memory efficient and allowing faster computation of the projected data.
If we define
s
=
1
/
density
, the elements of the random matrix
are drawn from
\[\begin{split}\left\{
\begin{array}{c c l}
-\sqrt{\frac{s}{n_{\text{components}}}} & & 1 / 2s\\
0 &\text{with probability}  & 1 - 1 / s \\
+\sqrt{\frac{s}{n_{\text{components}}}} & & 1 / 2s\\
\end{array}
\right.\end{split}\]
where
\(n_{\text{components}}\)
is the size of the projected subspace.
By default the density of non zero elements is set to the minimum density as
recommended by Ping Li et al.:
\(1 / \sqrt{n_{\text{features}}}\)
.
Here is a small excerpt which illustrates how to use the sparse random
projection transformer:
>>>
import
numpy
as
np
>>>
from
sklearn
import
random_projection
>>>
X
=
np
.
random
.
rand
(
100
,
10000
)
>>>
transformer
=
random_projection
.
SparseRandomProjection
()
>>>
X_new
=
transformer
.
fit_transform
(
X
)
>>>
X_new
.
shape
(100, 3947)
References
D. Achlioptas. 2003.
Database-friendly random projections: Johnson-Lindenstrauss  with binary
coins
.
Journal of Computer and System Sciences 66 (2003) 671-687.
Ping Li, Trevor J. Hastie, and Kenneth W. Church. 2006.
Very sparse random projections.
In Proceedings of the 12th ACM SIGKDD international conference on
Knowledge discovery and data mining (KDD ‘06). ACM, New York, NY, USA, 287-296.
7.6.4.
Inverse Transform
#
The random projection transformers have
compute_inverse_components
parameter. When
set to True, after creating the random
components_
matrix during fitting,
the transformer computes the pseudo-inverse of this matrix and stores it as
inverse_components_
. The
inverse_components_
matrix has shape
\(n_{features} \times n_{components}\)
, and it is always a dense matrix,
regardless of whether the components matrix is sparse or dense. So depending on
the number of features and components, it may use a lot of memory.
When the
inverse_transform
method is called, it computes the product of the
input
X
and the transpose of the inverse components. If the inverse components have
been computed during fit, they are reused at each call to
inverse_transform
.
Otherwise they are recomputed each time, which can be costly. The result is always
dense, even if
X
is sparse.
Here is a small code example which illustrates how to use the inverse transform
feature:
>>>
import
numpy
as
np
>>>
from
sklearn.random_projection
import
SparseRandomProjection
>>>
X
=
np
.
random
.
rand
(
100
,
10000
)
>>>
transformer
=
SparseRandomProjection
(
...
compute_inverse_components
=
True
...
)
...
>>>
X_new
=
transformer
.
fit_transform
(
X
)
>>>
X_new
.
shape
(100, 3947)
>>>
X_new_inversed
=
transformer
.
inverse_transform
(
X_new
)
>>>
X_new_inversed
.
shape
(100, 10000)
>>>
X_new_again
=
transformer
.
transform
(
X_new_inversed
)
>>>
np
.
allclose
(
X_new
,
X_new_again
)
True
previous
7.5.
Unsupervised dimensionality reduction
next
7.7.
Kernel Approximation
On this page
7.6.1. The Johnson-Lindenstrauss lemma
7.6.2. Gaussian random projection
7.6.3. Sparse random projection
7.6.4. Inverse Transform
This Page
Show Source
© Copyright 2007 - 2025, scikit-learn developers (BSD License).