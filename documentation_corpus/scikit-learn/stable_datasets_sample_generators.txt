8.3. Generated datasets — scikit-learn 1.7.0 documentation
Skip to main content
Back to top
Ctrl
+
K
Install
User Guide
API
Examples
Community
More
Getting Started
Release History
Glossary
Development
FAQ
Support
Related Projects
Roadmap
Governance
About us
GitHub
Choose version
Install
User Guide
API
Examples
Community
Getting Started
Release History
Glossary
Development
FAQ
Support
Related Projects
Roadmap
Governance
About us
GitHub
Choose version
Section Navigation
1. Supervised learning
1.1. Linear Models
1.2. Linear and Quadratic Discriminant Analysis
1.3. Kernel ridge regression
1.4. Support Vector Machines
1.5. Stochastic Gradient Descent
1.6. Nearest Neighbors
1.7. Gaussian Processes
1.8. Cross decomposition
1.9. Naive Bayes
1.10. Decision Trees
1.11. Ensembles: Gradient boosting, random forests, bagging, voting, stacking
1.12. Multiclass and multioutput algorithms
1.13. Feature selection
1.14. Semi-supervised learning
1.15. Isotonic regression
1.16. Probability calibration
1.17. Neural network models (supervised)
2. Unsupervised learning
2.1. Gaussian mixture models
2.2. Manifold learning
2.3. Clustering
2.4. Biclustering
2.5. Decomposing signals in components (matrix factorization problems)
2.6. Covariance estimation
2.7. Novelty and Outlier Detection
2.8. Density Estimation
2.9. Neural network models (unsupervised)
3. Model selection and evaluation
3.1. Cross-validation: evaluating estimator performance
3.2. Tuning the hyper-parameters of an estimator
3.3. Tuning the decision threshold for class prediction
3.4. Metrics and scoring: quantifying the quality of predictions
3.5. Validation curves: plotting scores to evaluate models
4. Metadata Routing
5. Inspection
5.1. Partial Dependence and Individual Conditional Expectation plots
5.2. Permutation feature importance
6. Visualizations
7. Dataset transformations
7.1. Pipelines and composite estimators
7.2. Feature extraction
7.3. Preprocessing data
7.4. Imputation of missing values
7.5. Unsupervised dimensionality reduction
7.6. Random Projection
7.7. Kernel Approximation
7.8. Pairwise metrics, Affinities and Kernels
7.9. Transforming the prediction target (
y
)
8. Dataset loading utilities
8.1. Toy datasets
8.2. Real world datasets
8.3. Generated datasets
8.4. Loading other datasets
9. Computing with scikit-learn
9.1. Strategies to scale computationally: bigger data
9.2. Computational Performance
9.3. Parallelism, resource management, and configuration
10. Model persistence
11. Common pitfalls and recommended practices
12. Dispatching
12.1. Array API support (experimental)
13. Choosing the right estimator
14. External Resources, Videos and Talks
User Guide
8.
Dataset loading utilities
8.3.
Generated datasets
8.3.
Generated datasets
#
In addition, scikit-learn includes various random sample generators that
can be used to build artificial datasets of controlled size and complexity.
8.3.1.
Generators for classification and clustering
#
These generators produce a matrix of features and corresponding discrete
targets.
8.3.1.1.
Single label
#
make_blobs
creates a multiclass dataset by allocating each class to one
normally-distributed cluster of points. It provides control over the centers and
standard deviations of each cluster. This dataset is used to demonstrate clustering.
import
matplotlib.pyplot
as
plt
from
sklearn.datasets
import
make_blobs
X
,
y
=
make_blobs
(
centers
=
3
,
cluster_std
=
0.5
,
random_state
=
0
)
plt
.
scatter
(
X
[:,
0
],
X
[:,
1
],
c
=
y
)
plt
.
title
(
"Three normally-distributed clusters"
)
plt
.
show
()
make_classification
also creates multiclass datasets but specializes in
introducing noise by way of: correlated, redundant and uninformative features; multiple
Gaussian clusters per class; and linear transformations of the feature space.
import
matplotlib.pyplot
as
plt
from
sklearn.datasets
import
make_classification
fig
,
axs
=
plt
.
subplots
(
1
,
3
,
figsize
=
(
12
,
4
),
sharey
=
True
,
sharex
=
True
)
titles
=
[
"Two classes,
\n
one informative feature,
\n
one cluster per class"
,
"Two classes,
\n
two informative features,
\n
two clusters per class"
,
"Three classes,
\n
two informative features,
\n
one cluster per class"
]
params
=
[
{
"n_informative"
:
1
,
"n_clusters_per_class"
:
1
,
"n_classes"
:
2
},
{
"n_informative"
:
2
,
"n_clusters_per_class"
:
2
,
"n_classes"
:
2
},
{
"n_informative"
:
2
,
"n_clusters_per_class"
:
1
,
"n_classes"
:
3
}
]
for
i
,
param
in
enumerate
(
params
):
X
,
Y
=
make_classification
(
n_features
=
2
,
n_redundant
=
0
,
random_state
=
1
,
**
param
)
axs
[
i
]
.
scatter
(
X
[:,
0
],
X
[:,
1
],
c
=
Y
)
axs
[
i
]
.
set_title
(
titles
[
i
])
plt
.
tight_layout
()
plt
.
show
()
make_gaussian_quantiles
divides a single Gaussian cluster into
near-equal-size classes separated by concentric hyperspheres.
import
matplotlib.pyplot
as
plt
from
sklearn.datasets
import
make_gaussian_quantiles
X
,
Y
=
make_gaussian_quantiles
(
n_features
=
2
,
n_classes
=
3
,
random_state
=
0
)
plt
.
scatter
(
X
[:,
0
],
X
[:,
1
],
c
=
Y
)
plt
.
title
(
"Gaussian divided into three quantiles"
)
plt
.
show
()
make_hastie_10_2
generates a similar binary, 10-dimensional problem.
make_circles
and
make_moons
generate 2D binary classification
datasets that are challenging to certain algorithms (e.g., centroid-based
clustering or linear classification), including optional Gaussian noise.
They are useful for visualization.
make_circles
produces Gaussian data
with a spherical decision boundary for binary classification, while
make_moons
produces two interleaving half-circles.
import
matplotlib.pyplot
as
plt
from
sklearn.datasets
import
make_circles
,
make_moons
fig
,
(
ax1
,
ax2
)
=
plt
.
subplots
(
nrows
=
1
,
ncols
=
2
,
figsize
=
(
8
,
4
))
X
,
Y
=
make_circles
(
noise
=
0.1
,
factor
=
0.3
,
random_state
=
0
)
ax1
.
scatter
(
X
[:,
0
],
X
[:,
1
],
c
=
Y
)
ax1
.
set_title
(
"make_circles"
)
X
,
Y
=
make_moons
(
noise
=
0.1
,
random_state
=
0
)
ax2
.
scatter
(
X
[:,
0
],
X
[:,
1
],
c
=
Y
)
ax2
.
set_title
(
"make_moons"
)
plt
.
tight_layout
()
plt
.
show
()
8.3.1.2.
Multilabel
#
make_multilabel_classification
generates random samples with multiple
labels, reflecting a bag of words drawn from a mixture of topics. The number of
topics for each document is drawn from a Poisson distribution, and the topics
themselves are drawn from a fixed random distribution. Similarly, the number of
words is drawn from Poisson, with words drawn from a multinomial, where each
topic defines a probability distribution over words. Simplifications with
respect to true bag-of-words mixtures include:
Per-topic word distributions are independently drawn, where in reality all
would be affected by a sparse base distribution, and would be correlated.
For a document generated from multiple topics, all topics are weighted
equally in generating its bag of words.
Documents without labels words at random, rather than from a base
distribution.
8.3.1.3.
Biclustering
#
make_biclusters
(shape, n_clusters, *[, ...])
Generate a constant block diagonal structure array for biclustering.
make_checkerboard
(shape, n_clusters, *[, ...])
Generate an array with block checkerboard structure for biclustering.
8.3.2.
Generators for regression
#
make_regression
produces regression targets as an optionally-sparse
random linear combination of random features, with noise. Its informative
features may be uncorrelated, or low rank (few features account for most of the
variance).
Other regression generators generate functions deterministically from
randomized features.
make_sparse_uncorrelated
produces a target as a
linear combination of four features with fixed coefficients.
Others encode explicitly non-linear relations:
make_friedman1
is related by polynomial and sine transforms;
make_friedman2
includes feature multiplication and reciprocation; and
make_friedman3
is similar with an arctan transformation on the target.
8.3.3.
Generators for manifold learning
#
make_s_curve
([n_samples, noise, random_state])
Generate an S curve dataset.
make_swiss_roll
([n_samples, noise, ...])
Generate a swiss roll dataset.
8.3.4.
Generators for decomposition
#
make_low_rank_matrix
([n_samples, ...])
Generate a mostly low rank matrix with bell-shaped singular values.
make_sparse_coded_signal
(n_samples, *, ...)
Generate a signal as a sparse combination of dictionary elements.
make_spd_matrix
(n_dim, *[, random_state])
Generate a random symmetric, positive-definite matrix.
make_sparse_spd_matrix
([n_dim, alpha, ...])
Generate a sparse symmetric definite positive matrix.
previous
8.2.
Real world datasets
next
8.4.
Loading other datasets
On this page
8.3.1. Generators for classification and clustering
8.3.1.1. Single label
8.3.1.2. Multilabel
8.3.1.3. Biclustering
8.3.2. Generators for regression
8.3.3. Generators for manifold learning
8.3.4. Generators for decomposition
This Page
Show Source
© Copyright 2007 - 2025, scikit-learn developers (BSD License).