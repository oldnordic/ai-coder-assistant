7.9. Transforming the prediction target (y) — scikit-learn 1.7.0 documentation
Skip to main content
Back to top
Ctrl
+
K
Install
User Guide
API
Examples
Community
More
Getting Started
Release History
Glossary
Development
FAQ
Support
Related Projects
Roadmap
Governance
About us
GitHub
Choose version
Install
User Guide
API
Examples
Community
Getting Started
Release History
Glossary
Development
FAQ
Support
Related Projects
Roadmap
Governance
About us
GitHub
Choose version
Section Navigation
1. Supervised learning
1.1. Linear Models
1.2. Linear and Quadratic Discriminant Analysis
1.3. Kernel ridge regression
1.4. Support Vector Machines
1.5. Stochastic Gradient Descent
1.6. Nearest Neighbors
1.7. Gaussian Processes
1.8. Cross decomposition
1.9. Naive Bayes
1.10. Decision Trees
1.11. Ensembles: Gradient boosting, random forests, bagging, voting, stacking
1.12. Multiclass and multioutput algorithms
1.13. Feature selection
1.14. Semi-supervised learning
1.15. Isotonic regression
1.16. Probability calibration
1.17. Neural network models (supervised)
2. Unsupervised learning
2.1. Gaussian mixture models
2.2. Manifold learning
2.3. Clustering
2.4. Biclustering
2.5. Decomposing signals in components (matrix factorization problems)
2.6. Covariance estimation
2.7. Novelty and Outlier Detection
2.8. Density Estimation
2.9. Neural network models (unsupervised)
3. Model selection and evaluation
3.1. Cross-validation: evaluating estimator performance
3.2. Tuning the hyper-parameters of an estimator
3.3. Tuning the decision threshold for class prediction
3.4. Metrics and scoring: quantifying the quality of predictions
3.5. Validation curves: plotting scores to evaluate models
4. Metadata Routing
5. Inspection
5.1. Partial Dependence and Individual Conditional Expectation plots
5.2. Permutation feature importance
6. Visualizations
7. Dataset transformations
7.1. Pipelines and composite estimators
7.2. Feature extraction
7.3. Preprocessing data
7.4. Imputation of missing values
7.5. Unsupervised dimensionality reduction
7.6. Random Projection
7.7. Kernel Approximation
7.8. Pairwise metrics, Affinities and Kernels
7.9. Transforming the prediction target (
y
)
8. Dataset loading utilities
8.1. Toy datasets
8.2. Real world datasets
8.3. Generated datasets
8.4. Loading other datasets
9. Computing with scikit-learn
9.1. Strategies to scale computationally: bigger data
9.2. Computational Performance
9.3. Parallelism, resource management, and configuration
10. Model persistence
11. Common pitfalls and recommended practices
12. Dispatching
12.1. Array API support (experimental)
13. Choosing the right estimator
14. External Resources, Videos and Talks
User Guide
7.
Dataset transformations
7.9.
Transforming the prediction target (
y
)
7.9.
Transforming the prediction target (
y
)
#
These are transformers that are not intended to be used on features, only on
supervised learning targets. See also
Transforming target in regression
if
you want to transform the prediction target for learning, but evaluate the
model in the original (untransformed) space.
7.9.1.
Label binarization
#
7.9.1.1.
LabelBinarizer
#
LabelBinarizer
is a utility class to help create a
label
indicator matrix
from a list of
multiclass
labels:
>>>
from
sklearn
import
preprocessing
>>>
lb
=
preprocessing
.
LabelBinarizer
()
>>>
lb
.
fit
([
1
,
2
,
6
,
4
,
2
])
LabelBinarizer()
>>>
lb
.
classes_
array([1, 2, 4, 6])
>>>
lb
.
transform
([
1
,
6
])
array([[1, 0, 0, 0],
[0, 0, 0, 1]])
Using this format can enable multiclass classification in estimators
that support the label indicator matrix format.
Warning
LabelBinarizer is not needed if you are using an estimator that
already supports
multiclass
data.
For more information about multiclass classification, refer to
Multiclass classification
.
7.9.1.2.
MultiLabelBinarizer
#
In
multilabel
learning, the joint set of binary classification tasks is
expressed with a label binary indicator array: each sample is one row of a 2d
array of shape (n_samples, n_classes) with binary values where the one, i.e. the
non zero elements, corresponds to the subset of labels for that sample. An array
such as
np.array([[1,
0,
0],
[0,
1,
1],
[0,
0,
0]])
represents label 0 in the
first sample, labels 1 and 2 in the second sample, and no labels in the third
sample.
Producing multilabel data as a list of sets of labels may be more intuitive.
The
MultiLabelBinarizer
transformer can be used to convert between a collection of collections of
labels and the indicator format:
>>>
from
sklearn.preprocessing
import
MultiLabelBinarizer
>>>
y
=
[[
2
,
3
,
4
],
[
2
],
[
0
,
1
,
3
],
[
0
,
1
,
2
,
3
,
4
],
[
0
,
1
,
2
]]
>>>
MultiLabelBinarizer
()
.
fit_transform
(
y
)
array([[0, 0, 1, 1, 1],
[0, 0, 1, 0, 0],
[1, 1, 0, 1, 0],
[1, 1, 1, 1, 1],
[1, 1, 1, 0, 0]])
For more information about multilabel classification, refer to
Multilabel classification
.
7.9.2.
Label encoding
#
LabelEncoder
is a utility class to help normalize labels such that
they contain only values between 0 and n_classes-1. This is sometimes useful
for writing efficient Cython routines.
LabelEncoder
can be used as
follows:
>>>
from
sklearn
import
preprocessing
>>>
le
=
preprocessing
.
LabelEncoder
()
>>>
le
.
fit
([
1
,
2
,
2
,
6
])
LabelEncoder()
>>>
le
.
classes_
array([1, 2, 6])
>>>
le
.
transform
([
1
,
1
,
2
,
6
])
array([0, 0, 1, 2])
>>>
le
.
inverse_transform
([
0
,
0
,
1
,
2
])
array([1, 1, 2, 6])
It can also be used to transform non-numerical labels (as long as they are
hashable and comparable) to numerical labels:
>>>
le
=
preprocessing
.
LabelEncoder
()
>>>
le
.
fit
([
"paris"
,
"paris"
,
"tokyo"
,
"amsterdam"
])
LabelEncoder()
>>>
list
(
le
.
classes_
)
[np.str_('amsterdam'), np.str_('paris'), np.str_('tokyo')]
>>>
le
.
transform
([
"tokyo"
,
"tokyo"
,
"paris"
])
array([2, 2, 1])
>>>
list
(
le
.
inverse_transform
([
2
,
2
,
1
]))
[np.str_('tokyo'), np.str_('tokyo'), np.str_('paris')]
previous
7.8.
Pairwise metrics, Affinities and Kernels
next
8.
Dataset loading utilities
On this page
7.9.1. Label binarization
7.9.1.1. LabelBinarizer
7.9.1.2. MultiLabelBinarizer
7.9.2. Label encoding
This Page
Show Source
© Copyright 2007 - 2025, scikit-learn developers (BSD License).