"""
comprehensive_analyzer.py

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

Copyright (C) 2024 AI Coder Assistant Contributors
"""

"""
Comprehensive Analysis Service
Uses Python's AST module to analyze code architecture and generate refactoring suggestions.
Integrates with the autonomous learning system for intelligent recommendations.
"""

import ast
import json
import logging
import os
from collections import defaultdict, deque
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple, Union
from enum import Enum

from .continuous_learning import ContinuousLearningService, KnowledgeUnit
from .llm_manager import LLMManager

logger = logging.getLogger(__name__)


class DependencyType(Enum):
    """Types of dependencies between code elements."""
    
    FUNCTION_CALL = "function_call"
    CLASS_INHERITANCE = "class_inheritance"
    CLASS_COMPOSITION = "class_composition"
    IMPORT = "import"
    VARIABLE_REFERENCE = "variable_reference"
    METHOD_CALL = "method_call"
    ATTRIBUTE_ACCESS = "attribute_access"


class ArchitectureIssueType(Enum):
    """Types of architectural issues that can be detected."""
    
    HIGH_COUPLING = "high_coupling"
    LOW_COHESION = "low_cohesion"
    CIRCULAR_DEPENDENCY = "circular_dependency"
    GOD_CLASS = "god_class"
    LONG_METHOD = "long_method"
    DUPLICATE_CODE = "duplicate_code"
    TIGHT_COUPLING = "tight_coupling"
    VIOLATION_OF_SRP = "violation_of_srp"  # Single Responsibility Principle
    VIOLATION_OF_OCP = "violation_of_ocp"  # Open/Closed Principle
    VIOLATION_OF_LSP = "violation_of_lsp"  # Liskov Substitution Principle
    VIOLATION_OF_ISP = "violation_of_isp"  # Interface Segregation Principle
    VIOLATION_OF_DIP = "violation_of_dip"  # Dependency Inversion Principle


@dataclass
class CodeElement:
    """Represents a code element (function, class, module)."""
    
    name: str
    element_type: str  # 'function', 'class', 'method', 'module'
    file_path: str
    line_number: int
    parent: Optional[str] = None
    children: List[str] = field(default_factory=list)
    dependencies: List[str] = field(default_factory=list)
    dependents: List[str] = field(default_factory=list)
    complexity: int = 0
    lines_of_code: int = 0
    docstring: Optional[str] = None
    parameters: List[str] = field(default_factory=list)
    return_type: Optional[str] = None
    decorators: List[str] = field(default_factory=list)
    attributes: List[str] = field(default_factory=list)
    methods: List[str] = field(default_factory=list)


@dataclass
class Dependency:
    """Represents a dependency between code elements."""
    
    source: str
    target: str
    dependency_type: DependencyType
    file_path: str
    line_number: int
    context: Optional[str] = None


@dataclass
class ArchitectureIssue:
    """Represents an architectural issue found in the codebase."""
    
    issue_type: ArchitectureIssueType
    severity: str  # 'low', 'medium', 'high', 'critical'
    description: str
    affected_elements: List[str]
    file_path: str
    line_number: int
    suggestion: str
    impact_score: float
    effort_score: float
    priority_score: float


@dataclass
class RefactoringSuggestion:
    """Represents a refactoring suggestion generated by the analysis."""
    
    id: str
    title: str
    description: str
    issue_type: ArchitectureIssueType
    affected_files: List[str]
    suggested_changes: List[Dict[str, Any]]
    estimated_effort: str  # 'low', 'medium', 'high'
    impact_score: float
    risk_score: float
    priority_score: float
    reasoning: str
    examples: List[str] = field(default_factory=list)
    alternatives: List[str] = field(default_factory=list)


class ComprehensiveAnalysisService:
    """
    Comprehensive code analysis service using AST parsing.
    Analyzes code architecture and generates intelligent refactoring suggestions.
    """
    
    def __init__(
        self,
        project_path: str,
        llm_manager: Optional[LLMManager] = None,
        learning_service: Optional[ContinuousLearningService] = None
    ):
        """Initialize the comprehensive analysis service."""
        self.project_path = Path(project_path)
        self.llm_manager = llm_manager
        self.learning_service = learning_service
        
        # Analysis results
        self.code_elements: Dict[str, CodeElement] = {}
        self.dependencies: List[Dependency] = []
        self.architecture_issues: List[ArchitectureIssue] = []
        self.refactoring_suggestions: List[RefactoringSuggestion] = []
        
        # Configuration
        self.config = {
            "max_file_size_mb": 10,
            "exclude_patterns": ["*.pyc", "__pycache__", "*.log", "node_modules", ".git", "venv", "env"],
            "include_patterns": ["*.py"],
            "complexity_threshold": 10,
            "loc_threshold": 50,
            "coupling_threshold": 5,
            "cohesion_threshold": 0.3
        }
        
        # Statistics
        self.stats = {
            "files_analyzed": 0,
            "elements_found": 0,
            "dependencies_found": 0,
            "issues_found": 0,
            "suggestions_generated": 0
        }
        
        logger.info(f"Comprehensive Analysis Service initialized for project: {project_path}")
    
    def analyze_architecture(self) -> Dict[str, Any]:
        """
        Perform comprehensive architectural analysis of the codebase.
        
        Returns:
            Dictionary containing analysis results
        """
        logger.info("Starting comprehensive architectural analysis...")
        
        try:
            # Reset previous results
            self.code_elements.clear()
            self.dependencies.clear()
            self.architecture_issues.clear()
            self.refactoring_suggestions.clear()
            
            # Discover and analyze Python files
            python_files = self._discover_python_files()
            self.stats["files_analyzed"] = len(python_files)
            
            # Parse each file
            for file_path in python_files:
                self._analyze_file(file_path)
            
            # Build dependency graph
            self._build_dependency_graph()
            
            # Detect architectural issues
            self._detect_architectural_issues()
            
            # Generate refactoring suggestions
            self._generate_refactoring_suggestions()
            
            # Update statistics
            self.stats["elements_found"] = len(self.code_elements)
            self.stats["dependencies_found"] = len(self.dependencies)
            self.stats["issues_found"] = len(self.architecture_issues)
            self.stats["suggestions_generated"] = len(self.refactoring_suggestions)
            
            logger.info(f"Architectural analysis completed: {self.stats}")
            
            return {
                "stats": self.stats,
                "code_elements": {k: self._element_to_dict(v) for k, v in self.code_elements.items()},
                "dependencies": [self._dependency_to_dict(d) for d in self.dependencies],
                "architecture_issues": [self._issue_to_dict(i) for i in self.architecture_issues],
                "refactoring_suggestions": [self._suggestion_to_dict(s) for s in self.refactoring_suggestions]
            }
            
        except Exception as e:
            logger.error(f"Error during architectural analysis: {e}")
            raise
    
    def _discover_python_files(self) -> List[Path]:
        """Discover Python files to analyze."""
        python_files = []
        
        for pattern in self.config["include_patterns"]:
            for file_path in self.project_path.rglob(pattern):
                # Check exclude patterns
                if any(file_path.match(exclude) for exclude in self.config["exclude_patterns"]):
                    continue
                
                # Check file size
                if file_path.stat().st_size > self.config["max_file_size_mb"] * 1024 * 1024:
                    continue
                
                python_files.append(file_path)
        
        return python_files
    
    def _analyze_file(self, file_path: Path) -> None:
        """Analyze a single Python file using AST."""
        try:
            content = file_path.read_text(encoding='utf-8')
            tree = ast.parse(content)
            
            # Create module element
            module_name = file_path.stem
            module_id = f"{file_path}:{module_name}"
            
            module_element = CodeElement(
                name=module_name,
                element_type="module",
                file_path=str(file_path),
                line_number=1
            )
            self.code_elements[module_id] = module_element
            
            # Analyze AST nodes
            analyzer = ASTAnalyzer(file_path, module_id, self.code_elements, self.dependencies)
            analyzer.visit(tree)
            
        except Exception as e:
            logger.error(f"Error analyzing file {file_path}: {e}")
    
    def _build_dependency_graph(self) -> None:
        """Build dependency graph from parsed elements."""
        # This would implement graph building logic
        # For now, we'll create basic dependency tracking
        for dependency in self.dependencies:
            source_id = dependency.source
            target_id = dependency.target
            
            if source_id in self.code_elements:
                self.code_elements[source_id].dependencies.append(target_id)
            
            if target_id in self.code_elements:
                self.code_elements[target_id].dependents.append(source_id)
    
    def _detect_architectural_issues(self) -> None:
        """Detect architectural issues in the codebase."""
        # Detect high coupling
        self._detect_high_coupling()
        
        # Detect low cohesion
        self._detect_low_cohesion()
        
        # Detect circular dependencies
        self._detect_circular_dependencies()
        
        # Detect god classes
        self._detect_god_classes()
        
        # Detect long methods
        self._detect_long_methods()
        
        # Detect SOLID principle violations
        self._detect_solid_violations()
    
    def _detect_high_coupling(self) -> None:
        """Detect high coupling between modules/classes."""
        for element_id, element in self.code_elements.items():
            if len(element.dependencies) > self.config["coupling_threshold"]:
                issue = ArchitectureIssue(
                    issue_type=ArchitectureIssueType.HIGH_COUPLING,
                    severity="medium",
                    description=f"{element.name} has high coupling with {len(element.dependencies)} dependencies",
                    affected_elements=[element_id],
                    file_path=element.file_path,
                    line_number=element.line_number,
                    suggestion="Consider reducing dependencies by applying dependency inversion or interface segregation",
                    impact_score=0.7,
                    effort_score=0.6,
                    priority_score=0.65
                )
                self.architecture_issues.append(issue)
    
    def _detect_low_cohesion(self) -> None:
        """Detect low cohesion in classes/modules."""
        for element_id, element in self.code_elements.items():
            if element.element_type == "class":
                # Calculate cohesion based on method relationships
                cohesion_score = self._calculate_cohesion(element)
                if cohesion_score < self.config["cohesion_threshold"]:
                    issue = ArchitectureIssue(
                        issue_type=ArchitectureIssueType.LOW_COHESION,
                        severity="medium",
                        description=f"{element.name} has low cohesion (score: {cohesion_score:.2f})",
                        affected_elements=[element_id],
                        file_path=element.file_path,
                        line_number=element.line_number,
                        suggestion="Consider splitting the class into more focused classes",
                        impact_score=0.6,
                        effort_score=0.7,
                        priority_score=0.65
                    )
                    self.architecture_issues.append(issue)
    
    def _detect_circular_dependencies(self) -> None:
        """Detect circular dependencies in the codebase."""
        # Simple cycle detection using DFS
        visited = set()
        rec_stack = set()
        
        def has_cycle(element_id: str) -> bool:
            if element_id in rec_stack:
                return True
            if element_id in visited:
                return False
            
            visited.add(element_id)
            rec_stack.add(element_id)
            
            element = self.code_elements.get(element_id)
            if element:
                for dep_id in element.dependencies:
                    if has_cycle(dep_id):
                        return True
            
            rec_stack.remove(element_id)
            return False
        
        for element_id in self.code_elements:
            if element_id not in visited:
                if has_cycle(element_id):
                    issue = ArchitectureIssue(
                        issue_type=ArchitectureIssueType.CIRCULAR_DEPENDENCY,
                        severity="high",
                        description=f"Circular dependency detected involving {element_id}",
                        affected_elements=[element_id],
                        file_path=self.code_elements[element_id].file_path,
                        line_number=self.code_elements[element_id].line_number,
                        suggestion="Break the circular dependency by introducing an interface or dependency injection",
                        impact_score=0.8,
                        effort_score=0.8,
                        priority_score=0.8
                    )
                    self.architecture_issues.append(issue)
    
    def _detect_god_classes(self) -> None:
        """Detect god classes (classes with too many responsibilities)."""
        for element_id, element in self.code_elements.items():
            if element.element_type == "class":
                # Check for god class indicators
                method_count = len(element.methods)
                attribute_count = len(element.attributes)
                complexity = element.complexity
                
                if (method_count > 10 or attribute_count > 15 or complexity > 20):
                    issue = ArchitectureIssue(
                        issue_type=ArchitectureIssueType.GOD_CLASS,
                        severity="high",
                        description=f"{element.name} appears to be a god class (methods: {method_count}, attributes: {attribute_count}, complexity: {complexity})",
                        affected_elements=[element_id],
                        file_path=element.file_path,
                        line_number=element.line_number,
                        suggestion="Split the class into smaller, more focused classes following Single Responsibility Principle",
                        impact_score=0.8,
                        effort_score=0.9,
                        priority_score=0.85
                    )
                    self.architecture_issues.append(issue)
    
    def _detect_long_methods(self) -> None:
        """Detect long methods that should be refactored."""
        for element_id, element in self.code_elements.items():
            if element.element_type in ["function", "method"]:
                if element.lines_of_code > self.config["loc_threshold"]:
                    issue = ArchitectureIssue(
                        issue_type=ArchitectureIssueType.LONG_METHOD,
                        severity="medium",
                        description=f"{element.name} is too long ({element.lines_of_code} lines)",
                        affected_elements=[element_id],
                        file_path=element.file_path,
                        line_number=element.line_number,
                        suggestion="Extract smaller methods to improve readability and maintainability",
                        impact_score=0.5,
                        effort_score=0.4,
                        priority_score=0.45
                    )
                    self.architecture_issues.append(issue)
    
    def _detect_solid_violations(self) -> None:
        """Detect violations of SOLID principles."""
        # Single Responsibility Principle violations
        for element_id, element in self.code_elements.items():
            if element.element_type == "class":
                responsibilities = self._count_responsibilities(element)
                if responsibilities > 3:
                    issue = ArchitectureIssue(
                        issue_type=ArchitectureIssueType.VIOLATION_OF_SRP,
                        severity="medium",
                        description=f"{element.name} has {responsibilities} responsibilities, violating SRP",
                        affected_elements=[element_id],
                        file_path=element.file_path,
                        line_number=element.line_number,
                        suggestion="Split the class into multiple classes, each with a single responsibility",
                        impact_score=0.7,
                        effort_score=0.7,
                        priority_score=0.7
                    )
                    self.architecture_issues.append(issue)
    
    def _calculate_cohesion(self, element: CodeElement) -> float:
        """Calculate cohesion score for a class."""
        # Simple cohesion calculation based on method relationships
        # In a real implementation, this would be more sophisticated
        if not element.methods:
            return 1.0
        
        # For now, return a placeholder score
        return 0.5
    
    def _count_responsibilities(self, element: CodeElement) -> int:
        """Count the number of responsibilities for a class."""
        # Simple responsibility counting based on method names
        # In a real implementation, this would analyze method purposes
        return len(element.methods) // 3  # Rough estimate
    
    def _generate_refactoring_suggestions(self) -> None:
        """Generate refactoring suggestions based on detected issues."""
        # Group issues by type
        issues_by_type = defaultdict(list)
        for issue in self.architecture_issues:
            issues_by_type[issue.issue_type].append(issue)
        
        # Generate suggestions for each issue type
        for issue_type, issues in issues_by_type.items():
            if issue_type == ArchitectureIssueType.HIGH_COUPLING:
                self._generate_coupling_suggestions(issues)
            elif issue_type == ArchitectureIssueType.LOW_COHESION:
                self._generate_cohesion_suggestions(issues)
            elif issue_type == ArchitectureIssueType.CIRCULAR_DEPENDENCY:
                self._generate_dependency_suggestions(issues)
            elif issue_type == ArchitectureIssueType.GOD_CLASS:
                self._generate_god_class_suggestions(issues)
            elif issue_type == ArchitectureIssueType.LONG_METHOD:
                self._generate_method_suggestions(issues)
            elif issue_type == ArchitectureIssueType.VIOLATION_OF_SRP:
                self._generate_srp_suggestions(issues)
    
    def _generate_coupling_suggestions(self, issues: List[ArchitectureIssue]) -> None:
        """Generate suggestions for high coupling issues."""
        for i, issue in enumerate(issues):
            suggestion = RefactoringSuggestion(
                id=f"coupling_{i}",
                title=f"Reduce Coupling in {issue.affected_elements[0]}",
                description=issue.description,
                issue_type=issue.issue_type,
                affected_files=[issue.file_path],
                suggested_changes=[
                    {
                        "type": "extract_interface",
                        "description": "Extract interfaces to reduce direct dependencies",
                        "target": issue.affected_elements[0]
                    },
                    {
                        "type": "dependency_injection",
                        "description": "Use dependency injection to loosen coupling",
                        "target": issue.affected_elements[0]
                    }
                ],
                estimated_effort="medium",
                impact_score=issue.impact_score,
                risk_score=0.3,
                priority_score=issue.priority_score,
                reasoning="High coupling makes the code difficult to test and maintain. Reducing coupling improves modularity and testability."
            )
            self.refactoring_suggestions.append(suggestion)
    
    def _generate_cohesion_suggestions(self, issues: List[ArchitectureIssue]) -> None:
        """Generate suggestions for low cohesion issues."""
        for i, issue in enumerate(issues):
            suggestion = RefactoringSuggestion(
                id=f"cohesion_{i}",
                title=f"Improve Cohesion in {issue.affected_elements[0]}",
                description=issue.description,
                issue_type=issue.issue_type,
                affected_files=[issue.file_path],
                suggested_changes=[
                    {
                        "type": "split_class",
                        "description": "Split the class into more focused classes",
                        "target": issue.affected_elements[0]
                    }
                ],
                estimated_effort="high",
                impact_score=issue.impact_score,
                risk_score=0.4,
                priority_score=issue.priority_score,
                reasoning="Low cohesion indicates that the class has multiple unrelated responsibilities. Splitting improves maintainability."
            )
            self.refactoring_suggestions.append(suggestion)
    
    def _generate_dependency_suggestions(self, issues: List[ArchitectureIssue]) -> None:
        """Generate suggestions for circular dependency issues."""
        for i, issue in enumerate(issues):
            suggestion = RefactoringSuggestion(
                id=f"dependency_{i}",
                title=f"Break Circular Dependency in {issue.affected_elements[0]}",
                description=issue.description,
                issue_type=issue.issue_type,
                affected_files=[issue.file_path],
                suggested_changes=[
                    {
                        "type": "introduce_interface",
                        "description": "Introduce an interface to break the circular dependency",
                        "target": issue.affected_elements[0]
                    },
                    {
                        "type": "dependency_injection",
                        "description": "Use dependency injection to invert the dependency",
                        "target": issue.affected_elements[0]
                    }
                ],
                estimated_effort="high",
                impact_score=issue.impact_score,
                risk_score=0.5,
                priority_score=issue.priority_score,
                reasoning="Circular dependencies create tight coupling and make the code difficult to test and maintain."
            )
            self.refactoring_suggestions.append(suggestion)
    
    def _generate_god_class_suggestions(self, issues: List[ArchitectureIssue]) -> None:
        """Generate suggestions for god class issues."""
        for i, issue in enumerate(issues):
            suggestion = RefactoringSuggestion(
                id=f"god_class_{i}",
                title=f"Split God Class {issue.affected_elements[0]}",
                description=issue.description,
                issue_type=issue.issue_type,
                affected_files=[issue.file_path],
                suggested_changes=[
                    {
                        "type": "extract_class",
                        "description": "Extract related methods and attributes into separate classes",
                        "target": issue.affected_elements[0]
                    },
                    {
                        "type": "apply_srp",
                        "description": "Apply Single Responsibility Principle to split responsibilities",
                        "target": issue.affected_elements[0]
                    }
                ],
                estimated_effort="high",
                impact_score=issue.impact_score,
                risk_score=0.6,
                priority_score=issue.priority_score,
                reasoning="God classes violate the Single Responsibility Principle and are difficult to maintain and test."
            )
            self.refactoring_suggestions.append(suggestion)
    
    def _generate_method_suggestions(self, issues: List[ArchitectureIssue]) -> None:
        """Generate suggestions for long method issues."""
        for i, issue in enumerate(issues):
            suggestion = RefactoringSuggestion(
                id=f"method_{i}",
                title=f"Refactor Long Method {issue.affected_elements[0]}",
                description=issue.description,
                issue_type=issue.issue_type,
                affected_files=[issue.file_path],
                suggested_changes=[
                    {
                        "type": "extract_method",
                        "description": "Extract smaller, focused methods from the long method",
                        "target": issue.affected_elements[0]
                    }
                ],
                estimated_effort="low",
                impact_score=issue.impact_score,
                risk_score=0.2,
                priority_score=issue.priority_score,
                reasoning="Long methods are difficult to understand, test, and maintain. Breaking them into smaller methods improves readability."
            )
            self.refactoring_suggestions.append(suggestion)
    
    def _generate_srp_suggestions(self, issues: List[ArchitectureIssue]) -> None:
        """Generate suggestions for SRP violations."""
        for i, issue in enumerate(issues):
            suggestion = RefactoringSuggestion(
                id=f"srp_{i}",
                title=f"Apply Single Responsibility Principle to {issue.affected_elements[0]}",
                description=issue.description,
                issue_type=issue.issue_type,
                affected_files=[issue.file_path],
                suggested_changes=[
                    {
                        "type": "split_responsibilities",
                        "description": "Split the class into multiple classes, each with a single responsibility",
                        "target": issue.affected_elements[0]
                    }
                ],
                estimated_effort="high",
                impact_score=issue.impact_score,
                risk_score=0.5,
                priority_score=issue.priority_score,
                reasoning="Classes with multiple responsibilities are difficult to maintain and violate the Single Responsibility Principle."
            )
            self.refactoring_suggestions.append(suggestion)
    
    def get_ai_enhanced_suggestions(self) -> List[RefactoringSuggestion]:
        """Get AI-enhanced refactoring suggestions using the learning system."""
        if not self.llm_manager or not self.learning_service:
            return self.refactoring_suggestions
        
        enhanced_suggestions = []
        
        for suggestion in self.refactoring_suggestions:
            # Get relevant knowledge for this suggestion
            knowledge_units = self.learning_service.get_knowledge_for_context(
                f"{suggestion.issue_type.value} refactoring {suggestion.title}",
                limit=5
            )
            
            # Enhance suggestion with learned knowledge
            enhanced_suggestion = self._enhance_suggestion_with_ai(suggestion, knowledge_units)
            enhanced_suggestions.append(enhanced_suggestion)
        
        return enhanced_suggestions
    
    def _enhance_suggestion_with_ai(
        self,
        suggestion: RefactoringSuggestion,
        knowledge_units: List[KnowledgeUnit]
    ) -> RefactoringSuggestion:
        """Enhance a suggestion using AI and learned knowledge."""
        # Create enhanced suggestion with additional context
        enhanced_suggestion = RefactoringSuggestion(
            id=suggestion.id,
            title=suggestion.title,
            description=suggestion.description,
            issue_type=suggestion.issue_type,
            affected_files=suggestion.affected_files,
            suggested_changes=suggestion.suggested_changes,
            estimated_effort=suggestion.estimated_effort,
            impact_score=suggestion.impact_score,
            risk_score=suggestion.risk_score,
            priority_score=suggestion.priority_score,
            reasoning=suggestion.reasoning,
            examples=suggestion.examples,
            alternatives=suggestion.alternatives
        )
        
        # Add examples from knowledge base
        for unit in knowledge_units:
            if unit.source_type == "code_scanner":
                enhanced_suggestion.examples.append(f"Similar issue: {unit.content[:200]}...")
            elif unit.source_type == "documentation":
                enhanced_suggestion.alternatives.append(f"Best practice: {unit.content[:200]}...")
        
        return enhanced_suggestion
    
    def _element_to_dict(self, element: CodeElement) -> Dict[str, Any]:
        """Convert CodeElement to dictionary."""
        return {
            "name": element.name,
            "element_type": element.element_type,
            "file_path": element.file_path,
            "line_number": element.line_number,
            "parent": element.parent,
            "children": element.children,
            "dependencies": element.dependencies,
            "dependents": element.dependents,
            "complexity": element.complexity,
            "lines_of_code": element.lines_of_code,
            "docstring": element.docstring,
            "parameters": element.parameters,
            "return_type": element.return_type,
            "decorators": element.decorators,
            "attributes": element.attributes,
            "methods": element.methods
        }
    
    def _dependency_to_dict(self, dependency: Dependency) -> Dict[str, Any]:
        """Convert Dependency to dictionary."""
        return {
            "source": dependency.source,
            "target": dependency.target,
            "dependency_type": dependency.dependency_type.value,
            "file_path": dependency.file_path,
            "line_number": dependency.line_number,
            "context": dependency.context
        }
    
    def _issue_to_dict(self, issue: ArchitectureIssue) -> Dict[str, Any]:
        """Convert ArchitectureIssue to dictionary."""
        return {
            "issue_type": issue.issue_type.value,
            "severity": issue.severity,
            "description": issue.description,
            "affected_elements": issue.affected_elements,
            "file_path": issue.file_path,
            "line_number": issue.line_number,
            "suggestion": issue.suggestion,
            "impact_score": issue.impact_score,
            "effort_score": issue.effort_score,
            "priority_score": issue.priority_score
        }
    
    def _suggestion_to_dict(self, suggestion: RefactoringSuggestion) -> Dict[str, Any]:
        """Convert RefactoringSuggestion to dictionary."""
        return {
            "id": suggestion.id,
            "title": suggestion.title,
            "description": suggestion.description,
            "issue_type": suggestion.issue_type.value,
            "affected_files": suggestion.affected_files,
            "suggested_changes": suggestion.suggested_changes,
            "estimated_effort": suggestion.estimated_effort,
            "impact_score": suggestion.impact_score,
            "risk_score": suggestion.risk_score,
            "priority_score": suggestion.priority_score,
            "reasoning": suggestion.reasoning,
            "examples": suggestion.examples,
            "alternatives": suggestion.alternatives
        }


class ASTAnalyzer(ast.NodeVisitor):
    """AST visitor for analyzing Python code structure."""
    
    def __init__(
        self,
        file_path: Path,
        module_id: str,
        code_elements: Dict[str, CodeElement],
        dependencies: List[Dependency]
    ):
        self.file_path = file_path
        self.module_id = module_id
        self.code_elements = code_elements
        self.dependencies = dependencies
        self.current_class: Optional[str] = None
        self.current_function: Optional[str] = None
    
    def visit_ClassDef(self, node: ast.ClassDef) -> None:
        """Visit class definition nodes."""
        class_id = f"{self.file_path}:{node.name}"
        
        # Create class element
        class_element = CodeElement(
            name=node.name,
            element_type="class",
            file_path=str(self.file_path),
            line_number=node.lineno,
            parent=self.module_id,
            docstring=ast.get_docstring(node),
            decorators=[self._get_decorator_name(d) for d in node.decorator_list]
        )
        
        # Add to code elements
        self.code_elements[class_id] = class_element
        
        # Update parent's children
        if self.module_id in self.code_elements:
            self.code_elements[self.module_id].children.append(class_id)
        
        # Track current class
        previous_class = self.current_class
        self.current_class = class_id
        
        # Visit class body
        self.generic_visit(node)
        
        # Restore previous class
        self.current_class = previous_class
    
    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
        """Visit function definition nodes."""
        func_id = f"{self.file_path}:{node.name}"
        
        # Determine element type
        element_type = "method" if self.current_class else "function"
        parent_id = self.current_class or self.module_id
        
        # Create function element
        func_element = CodeElement(
            name=node.name,
            element_type=element_type,
            file_path=str(self.file_path),
            line_number=node.lineno,
            parent=parent_id,
            docstring=ast.get_docstring(node),
            parameters=[arg.arg for arg in node.args.args],
            decorators=[self._get_decorator_name(d) for d in node.decorator_list]
        )
        
        # Add to code elements
        self.code_elements[func_id] = func_element
        
        # Update parent's children
        if parent_id in self.code_elements:
            if element_type == "method":
                self.code_elements[parent_id].methods.append(func_id)
            else:
                self.code_elements[parent_id].children.append(func_id)
        
        # Track current function
        previous_function = self.current_function
        self.current_function = func_id
        
        # Visit function body
        self.generic_visit(node)
        
        # Restore previous function
        self.current_function = previous_function
    
    def visit_Call(self, node: ast.Call) -> None:
        """Visit function call nodes."""
        if self.current_function:
            # Extract function name
            if isinstance(node.func, ast.Name):
                func_name = node.func.id
                self._add_dependency(func_name, DependencyType.FUNCTION_CALL)
            elif isinstance(node.func, ast.Attribute):
                # Handle method calls
                if isinstance(node.func.value, ast.Name):
                    obj_name = node.func.value.id
                    method_name = node.func.attr
                    self._add_dependency(f"{obj_name}.{method_name}", DependencyType.METHOD_CALL)
        
        self.generic_visit(node)
    
    def visit_Import(self, node: ast.Import) -> None:
        """Visit import nodes."""
        for alias in node.names:
            self._add_dependency(alias.name, DependencyType.IMPORT)
        self.generic_visit(node)
    
    def visit_ImportFrom(self, node: ast.ImportFrom) -> None:
        """Visit import from nodes."""
        module_name = node.module or ""
        for alias in node.names:
            full_name = f"{module_name}.{alias.name}" if module_name else alias.name
            self._add_dependency(full_name, DependencyType.IMPORT)
        self.generic_visit(node)
    
    def visit_Attribute(self, node: ast.Attribute) -> None:
        """Visit attribute access nodes."""
        if isinstance(node.value, ast.Name):
            obj_name = node.value.id
            attr_name = node.attr
            self._add_dependency(f"{obj_name}.{attr_name}", DependencyType.ATTRIBUTE_ACCESS)
        self.generic_visit(node)
    
    def _add_dependency(self, target: str, dep_type: DependencyType) -> None:
        """Add a dependency to the list."""
        if self.current_function:
            dependency = Dependency(
                source=self.current_function,
                target=target,
                dependency_type=dep_type,
                file_path=str(self.file_path),
                line_number=0  # Would need to track line numbers more precisely
            )
            self.dependencies.append(dependency)
    
    def _get_decorator_name(self, decorator: ast.expr) -> str:
        """Get the name of a decorator."""
        if isinstance(decorator, ast.Name):
            return decorator.id
        elif isinstance(decorator, ast.Attribute):
            return f"{decorator.value.id}.{decorator.attr}"
        else:
            return str(decorator)


# Global instance for easy access
_comprehensive_analyzer: Optional[ComprehensiveAnalysisService] = None


def get_comprehensive_analyzer(
    project_path: Optional[str] = None,
    llm_manager: Optional[LLMManager] = None,
    learning_service: Optional[ContinuousLearningService] = None
) -> ComprehensiveAnalysisService:
    """Get or create the global comprehensive analyzer instance."""
    global _comprehensive_analyzer
    
    if _comprehensive_analyzer is None:
        if project_path is None:
            project_path = os.getcwd()
        
        _comprehensive_analyzer = ComprehensiveAnalysisService(
            project_path=project_path,
            llm_manager=llm_manager,
            learning_service=learning_service
        )
    
    return _comprehensive_analyzer 