1.3. Kernel ridge regression — scikit-learn 1.7.0 documentation
Skip to main content
Back to top
Ctrl
+
K
Install
User Guide
API
Examples
Community
More
Getting Started
Release History
Glossary
Development
FAQ
Support
Related Projects
Roadmap
Governance
About us
GitHub
Choose version
Install
User Guide
API
Examples
Community
Getting Started
Release History
Glossary
Development
FAQ
Support
Related Projects
Roadmap
Governance
About us
GitHub
Choose version
Section Navigation
1. Supervised learning
1.1. Linear Models
1.2. Linear and Quadratic Discriminant Analysis
1.3. Kernel ridge regression
1.4. Support Vector Machines
1.5. Stochastic Gradient Descent
1.6. Nearest Neighbors
1.7. Gaussian Processes
1.8. Cross decomposition
1.9. Naive Bayes
1.10. Decision Trees
1.11. Ensembles: Gradient boosting, random forests, bagging, voting, stacking
1.12. Multiclass and multioutput algorithms
1.13. Feature selection
1.14. Semi-supervised learning
1.15. Isotonic regression
1.16. Probability calibration
1.17. Neural network models (supervised)
2. Unsupervised learning
2.1. Gaussian mixture models
2.2. Manifold learning
2.3. Clustering
2.4. Biclustering
2.5. Decomposing signals in components (matrix factorization problems)
2.6. Covariance estimation
2.7. Novelty and Outlier Detection
2.8. Density Estimation
2.9. Neural network models (unsupervised)
3. Model selection and evaluation
3.1. Cross-validation: evaluating estimator performance
3.2. Tuning the hyper-parameters of an estimator
3.3. Tuning the decision threshold for class prediction
3.4. Metrics and scoring: quantifying the quality of predictions
3.5. Validation curves: plotting scores to evaluate models
4. Metadata Routing
5. Inspection
5.1. Partial Dependence and Individual Conditional Expectation plots
5.2. Permutation feature importance
6. Visualizations
7. Dataset transformations
7.1. Pipelines and composite estimators
7.2. Feature extraction
7.3. Preprocessing data
7.4. Imputation of missing values
7.5. Unsupervised dimensionality reduction
7.6. Random Projection
7.7. Kernel Approximation
7.8. Pairwise metrics, Affinities and Kernels
7.9. Transforming the prediction target (
y
)
8. Dataset loading utilities
8.1. Toy datasets
8.2. Real world datasets
8.3. Generated datasets
8.4. Loading other datasets
9. Computing with scikit-learn
9.1. Strategies to scale computationally: bigger data
9.2. Computational Performance
9.3. Parallelism, resource management, and configuration
10. Model persistence
11. Common pitfalls and recommended practices
12. Dispatching
12.1. Array API support (experimental)
13. Choosing the right estimator
14. External Resources, Videos and Talks
User Guide
1.
Supervised learning
1.3.
Kernel ridge regression
1.3.
Kernel ridge regression
#
Kernel ridge regression (KRR)
[M2012]
combines
Ridge regression and classification
(linear least squares with
\(L_2\)
-norm regularization) with the
kernel trick
. It thus learns a linear
function in the space induced by the respective kernel and the data. For
non-linear kernels, this corresponds to a non-linear function in the original
space.
The form of the model learned by
KernelRidge
is identical to support
vector regression (
SVR
). However, different loss
functions are used: KRR uses squared error loss while support vector
regression uses
\(\epsilon\)
-insensitive loss, both combined with
\(L_2\)
regularization. In contrast to
SVR
, fitting
KernelRidge
can be done in closed-form and is typically faster for
medium-sized datasets. On the other hand, the learned model is non-sparse and
thus slower than
SVR
, which learns a sparse model for
\(\epsilon > 0\)
, at prediction-time.
The following figure compares
KernelRidge
and
SVR
on an artificial dataset, which consists of a
sinusoidal target function and strong noise added to every fifth datapoint.
The learned model of
KernelRidge
and
SVR
is
plotted, where both complexity/regularization and bandwidth of the RBF kernel
have been optimized using grid-search. The learned functions are very
similar; however, fitting
KernelRidge
is approximately seven times
faster than fitting
SVR
(both with grid-search).
However, prediction of 100,000 target values is more than three times faster
with
SVR
since it has learned a sparse model using only
approximately 1/3 of the 100 training datapoints as support vectors.
The next figure compares the time for fitting and prediction of
KernelRidge
and
SVR
for different sizes of the
training set. Fitting
KernelRidge
is faster than
SVR
for medium-sized training sets (less than 1000
samples); however, for larger training sets
SVR
scales
better. With regard to prediction time,
SVR
is faster
than
KernelRidge
for all sizes of the training set because of the
learned sparse solution. Note that the degree of sparsity and thus the
prediction time depends on the parameters
\(\epsilon\)
and
\(C\)
of
the
SVR
;
\(\epsilon = 0\)
would correspond to a
dense model.
Examples
Comparison of kernel ridge regression and SVR
References
[
M2012
]
“Machine Learning: A Probabilistic Perspective”
Murphy, K. P. - chapter 14.4.3, pp. 492-493, The MIT Press, 2012
previous
1.2.
Linear and Quadratic Discriminant Analysis
next
1.4.
Support Vector Machines
This Page
Show Source
© Copyright 2007 - 2025, scikit-learn developers (BSD License).