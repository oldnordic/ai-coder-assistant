pymatgen.io.vasp package — pymatgen 2025.5.28 documentation
pymatgen.io.vasp package
Submodules
pymatgen.io.vasp.help module
VaspDoc
VaspDoc.get_help()
VaspDoc.get_incar_tags()
VaspDoc.print_help()
VaspDoc.print_jupyter_help()
pymatgen.io.vasp.inputs module
BadIncarWarning
BadPoscarWarning
Incar
Incar.as_dict()
Incar.check_params()
Incar.copy()
Incar.diff()
Incar.from_dict()
Incar.from_file()
Incar.from_str()
Incar.get()
Incar.get_str()
Incar.proc_val()
Incar.write_file()
Kpoints
Kpoints.as_dict()
Kpoints.automatic()
Kpoints.automatic_density()
Kpoints.automatic_density_by_lengths()
Kpoints.automatic_density_by_vol()
Kpoints.automatic_gamma_density()
Kpoints.automatic_linemode()
Kpoints.copy()
Kpoints.from_dict()
Kpoints.from_file()
Kpoints.from_str()
Kpoints.gamma_automatic()
Kpoints.kpts
Kpoints.monkhorst_automatic()
Kpoints.style
Kpoints.supported_modes
Kpoints.write_file()
KpointsSupportedModes
KpointsSupportedModes.Automatic
KpointsSupportedModes.Cartesian
KpointsSupportedModes.Gamma
KpointsSupportedModes.Line_mode
KpointsSupportedModes.Monkhorst
KpointsSupportedModes.Reciprocal
KpointsSupportedModes.from_str()
Orbital
Orbital.E
Orbital.j
Orbital.l
Orbital.n
Orbital.occ
OrbitalDescription
OrbitalDescription.E
OrbitalDescription.Rcut
OrbitalDescription.Rcut2
OrbitalDescription.Type
OrbitalDescription.Type2
OrbitalDescription.l
PmgVaspPspDirError
Poscar
Poscar.structure
Poscar.comment
Poscar.true_names
Poscar.selective_dynamics
Poscar.velocities
Poscar.predictor_corrector
Poscar.predictor_corrector_preamble
Poscar.lattice_velocities
Poscar.temperature
Poscar.as_dict()
Poscar.from_dict()
Poscar.from_file()
Poscar.from_str()
Poscar.get_str()
Poscar.get_string()
Poscar.lattice_velocities
Poscar.natoms
Poscar.predictor_corrector
Poscar.predictor_corrector_preamble
Poscar.selective_dynamics
Poscar.set_temperature()
Poscar.site_symbols
Poscar.velocities
Poscar.write_file()
Potcar
Potcar.FUNCTIONAL_CHOICES
Potcar.as_dict()
Potcar.from_dict()
Potcar.from_file()
Potcar.from_spec()
Potcar.from_str()
Potcar.set_symbols()
Potcar.spec
Potcar.symbols
Potcar.write_file()
Potcar.write_potcar_spec()
PotcarSingle
PotcarSingle.data
PotcarSingle.keywords
PotcarSingle.atomic_no
PotcarSingle.compare_potcar_stats()
PotcarSingle.copy()
PotcarSingle.electron_configuration
PotcarSingle.element
PotcarSingle.from_file()
PotcarSingle.from_symbol_and_functional()
PotcarSingle.functional
PotcarSingle.functional_class
PotcarSingle.functional_dir
PotcarSingle.functional_tags
PotcarSingle.get_electron_configuration()
PotcarSingle.hash_sha256_from_file
PotcarSingle.identify_potcar()
PotcarSingle.identify_potcar_hash_based()
PotcarSingle.is_valid
PotcarSingle.md5_computed_file_hash
PotcarSingle.md5_header_hash
PotcarSingle.nelectrons
PotcarSingle.parse_functions
PotcarSingle.potential_type
PotcarSingle.sha256_computed_file_hash
PotcarSingle.spec()
PotcarSingle.symbol
PotcarSingle.verify_potcar()
PotcarSingle.write_file()
UnknownPotcarWarning
VaspInput
VaspInput.as_dict()
VaspInput.copy()
VaspInput.from_dict()
VaspInput.from_directory()
VaspInput.incar
VaspInput.kpoints
VaspInput.poscar
VaspInput.potcar
VaspInput.run_vasp()
VaspInput.write_input()
pymatgen.io.vasp.optics module
DielectricFunctionCalculator
DielectricFunctionCalculator.cder
DielectricFunctionCalculator.cder_imag
DielectricFunctionCalculator.cder_real
DielectricFunctionCalculator.cshift
DielectricFunctionCalculator.deltae
DielectricFunctionCalculator.efermi
DielectricFunctionCalculator.eigs
DielectricFunctionCalculator.from_directory()
DielectricFunctionCalculator.from_vasp_objects()
DielectricFunctionCalculator.get_epsilon()
DielectricFunctionCalculator.ismear
DielectricFunctionCalculator.ispin
DielectricFunctionCalculator.kweights
DielectricFunctionCalculator.nedos
DielectricFunctionCalculator.plot_weighted_transition_data()
DielectricFunctionCalculator.sigma
DielectricFunctionCalculator.volume
delta_func()
delta_methfessel_paxton()
epsilon_imag()
get_delta()
get_step()
kramers_kronig()
step_func()
step_methfessel_paxton()
pymatgen.io.vasp.outputs module
BSVasprun
BSVasprun.as_dict()
BandgapProps
BandgapProps.cbm
BandgapProps.cbm_k
BandgapProps.direct_gap_eigenvalues
BandgapProps.direct_gap_k
BandgapProps.efermi
BandgapProps.vbm
BandgapProps.vbm_k
Chgcar
Chgcar.from_file()
Chgcar.net_magnetization
Dynmat
Dynmat.data
Dynmat.get_phonon_frequencies()
Dynmat.masses
Dynmat.natoms
Dynmat.ndisps
Dynmat.nspecs
Eigenval
Eigenval.filename
Eigenval.occu_tol
Eigenval.ispin
Eigenval.nelect
Eigenval.nkpt
Eigenval.nbands
Eigenval.kpoints
Eigenval.kpoints_weights
Eigenval.eigenvalues
Eigenval.eigenvalue_band_properties
Elfcar
Elfcar.from_file()
Elfcar.get_alpha()
KpointOptProps
KpointOptProps.actual_kpoints
KpointOptProps.actual_kpoints_weights
KpointOptProps.dos_has_errors
KpointOptProps.efermi
KpointOptProps.eigenvalues
KpointOptProps.idos
KpointOptProps.kpoints
KpointOptProps.pdos
KpointOptProps.projected_eigenvalues
KpointOptProps.projected_magnetisation
KpointOptProps.tdos
Locpot
Locpot.from_file()
Oszicar
Oszicar.electronic_steps
Oszicar.ionic_steps
Oszicar.all_energies
Oszicar.as_dict()
Oszicar.final_energy
Outcar
Outcar.magnetization
Outcar.chemical_shielding
Outcar.unsym_cs_tensor
Outcar.cs_g0_contribution
Outcar.cs_core_contribution
Outcar.efg
Outcar.charge
Outcar.is_stopped
Outcar.run_stats
Outcar.elastic_tensor
Outcar.drift
Outcar.ngf
Outcar.sampling_radii
Outcar.electrostatic_potential
Outcar.final_energy_contribs
Outcar.efermi
Outcar.filename
Outcar.final_energy
Outcar.final_energy_wo_entrp
Outcar.final_fr_energy
Outcar.has_onsite_density_matrices
Outcar.lcalcpol
Outcar.lepsilon
Outcar.nelect
Outcar.spin
Outcar.total_mag
Outcar.as_dict()
Outcar.read_avg_core_poten()
Outcar.read_chemical_shielding()
Outcar.read_core_state_eigen()
Outcar.read_corrections()
Outcar.read_cs_core_contribution()
Outcar.read_cs_g0_contribution()
Outcar.read_cs_raw_symmetrized_tensors()
Outcar.read_elastic_tensor()
Outcar.read_electrostatic_potential()
Outcar.read_fermi_contact_shift()
Outcar.read_freq_dielectric()
Outcar.read_igpar()
Outcar.read_internal_strain_tensor()
Outcar.read_lcalcpol()
Outcar.read_lepsilon()
Outcar.read_lepsilon_ionic()
Outcar.read_neb()
Outcar.read_nmr_efg()
Outcar.read_nmr_efg_tensor()
Outcar.read_onsite_density_matrices()
Outcar.read_pattern()
Outcar.read_piezo_tensor()
Outcar.read_pseudo_zval()
Outcar.read_table_pattern()
Procar
Procar.data
Procar.weights
Procar.phase_factors
Procar.nbands
Procar.nkpoints
Procar.nions
Procar.nspins
Procar.is_soc
Procar.kpoints
Procar.occupancies
Procar.eigenvalues
Procar.xyz_data
Procar.get_occupation()
Procar.get_projection_on_elements()
Procar.read()
UnconvergedVASPWarning
VaspParseError
Vaspout()
Vasprun
Vasprun.ionic_steps
Vasprun.tdos
Vasprun.idos
Vasprun.pdos
Vasprun.efermi
Vasprun.eigenvalues
Vasprun.projected_eigenvalues
Vasprun.projected_magnetisation
Vasprun.dielectric_data
Vasprun.nionic_steps
Vasprun.force_constants
Vasprun.normalmode_eigenvals
Vasprun.normalmode_eigenvecs
Vasprun.md_data
Vasprun.incar
Vasprun.parameters
Vasprun.kpoints
Vasprun.actual_kpoints
Vasprun.actual_kpoints_weights
Vasprun.atomic_symbols
Vasprun.potcar_symbols
Vasprun.kpoints_opt_props
Vasprun.as_dict()
Vasprun.calculate_efermi()
Vasprun.complete_dos
Vasprun.complete_dos_normalized
Vasprun.converged
Vasprun.converged_electronic
Vasprun.converged_ionic
Vasprun.dielectric
Vasprun.eigenvalue_band_properties
Vasprun.epsilon_ionic
Vasprun.epsilonassets
Vasprun.epsilonassets_wolfe
Vasprun.final_energy
Vasprun.get_band_structure()
Vasprun.get_computed_entry()
Vasprun.get_potcars()
Vasprun.get_trajectory()
Vasprun.hubbards
Vasprun.is_hubbard
Vasprun.is_spin
Vasprun.md_n_steps
Vasprun.optical_absorption_coeff
Vasprun.run_type
Vasprun.structures
Vasprun.update_charge_from_potcar()
Vasprun.update_potcar_spec()
VolumetricData
VolumetricData.parse_file()
VolumetricData.write_file()
WSWQ
WSWQ.nspin
WSWQ.nkpoints
WSWQ.nbands
WSWQ.me_real
WSWQ.me_imag
WSWQ.data
WSWQ.from_file()
WSWQ.me_imag
WSWQ.me_real
WSWQ.nbands
WSWQ.nkpoints
WSWQ.nspin
Wavecar
Wavecar.vasp_type
Wavecar.nk
Wavecar.nb
Wavecar.encut
Wavecar.efermi
Wavecar.a
Wavecar.b
Wavecar.vol
Wavecar.kpoints
Wavecar.band_energy
Wavecar.Gpoints
Wavecar.coeffs
Wavecar.evaluate_wavefunc()
Wavecar.fft_mesh()
Wavecar.get_parchg()
Wavecar.write_unks()
Waveder
Waveder.cder_real
Waveder.cder_imag
Waveder.cder
Waveder.cder_imag
Waveder.cder_real
Waveder.from_binary()
Waveder.from_formatted()
Waveder.get_orbital_derivative_between_states()
Waveder.nbands
Waveder.nkpoints
Waveder.nspin
Xdatcar
Xdatcar.structures
Xdatcar.comment
Xdatcar.concatenate()
Xdatcar.get_str()
Xdatcar.natoms
Xdatcar.site_symbols
Xdatcar.write_file()
get_adjusted_fermi_level()
get_band_structure_from_vasp_multiple_branches()
pymatgen.io.vasp.sets module
BadInputSetWarning
CINEBSet
DictSet
LobsterSet
LobsterSet.CONFIG
LobsterSet.address_basis_file
LobsterSet.incar_updates
LobsterSet.ismear
LobsterSet.isym
LobsterSet.kpoints_updates
LobsterSet.reciprocal_density
LobsterSet.user_potcar_functional
LobsterSet.user_supplied_basis
MITMDSet
MITMDSet.CONFIG
MITMDSet.end_temp
MITMDSet.incar_updates
MITMDSet.kpoints_updates
MITMDSet.nsteps
MITMDSet.spin_polarized
MITMDSet.start_temp
MITMDSet.structure
MITMDSet.time_step
MITNEBSet
MITRelaxSet
MITRelaxSet.CONFIG
MP24RelaxSet
MP24RelaxSet.CONFIG
MP24RelaxSet.auto_ismear
MP24RelaxSet.auto_kspacing
MP24RelaxSet.dispersion
MP24RelaxSet.inherit_incar
MP24RelaxSet.kspacing_update
MP24RelaxSet.xc_functional
MP24StaticSet
MP24StaticSet.auto_kspacing
MP24StaticSet.incar_updates
MP24StaticSet.inherit_incar
MP24StaticSet.lcalcpol
MP24StaticSet.lepsilon
MPAbsorptionSet
MPAbsorptionSet.CONFIG
MPAbsorptionSet.SUPPORTED_MODES
MPAbsorptionSet.copy_wavecar
MPAbsorptionSet.force_gamma
MPAbsorptionSet.incar_updates
MPAbsorptionSet.inherit_incar
MPAbsorptionSet.kpoints_updates
MPAbsorptionSet.mode
MPAbsorptionSet.nbands
MPAbsorptionSet.nbands_factor
MPAbsorptionSet.nedos
MPAbsorptionSet.nkred
MPAbsorptionSet.reciprocal_density
MPHSEBSSet
MPHSEBSSet.CONFIG
MPHSEBSSet.added_kpoints
MPHSEBSSet.copy_chgcar
MPHSEBSSet.dedos
MPHSEBSSet.incar_updates
MPHSEBSSet.kpoints_line_density
MPHSEBSSet.kpoints_updates
MPHSEBSSet.mode
MPHSEBSSet.nbands_factor
MPHSEBSSet.optics
MPHSEBSSet.reciprocal_density
MPHSEBSSet.zero_weighted_reciprocal_density
MPHSERelaxSet
MPHSERelaxSet.CONFIG
MPHSERelaxSet.incar_updates
MPHSERelaxSet.vdw
MPMDSet
MPMDSet.CONFIG
MPMDSet.end_temp
MPMDSet.incar_updates
MPMDSet.kpoints_updates
MPMDSet.nsteps
MPMDSet.spin_polarized
MPMDSet.start_temp
MPMDSet.time_step
MPMetalRelaxSet
MPMetalRelaxSet.CONFIG
MPMetalRelaxSet.incar_updates
MPMetalRelaxSet.kpoints_updates
MPNMRSet
MPNMRSet.CONFIG
MPNMRSet.incar_updates
MPNMRSet.inherit_incar
MPNMRSet.isotopes
MPNMRSet.kpoints_updates
MPNMRSet.mode
MPNMRSet.reciprocal_density
MPNMRSet.small_gap_multiply
MPNonSCFSet
MPNonSCFSet.CONFIG
MPNonSCFSet.copy_chgcar
MPNonSCFSet.dedos
MPNonSCFSet.incar_updates
MPNonSCFSet.inherit_incar
MPNonSCFSet.kpoints_line_density
MPNonSCFSet.kpoints_updates
MPNonSCFSet.mode
MPNonSCFSet.nbands_factor
MPNonSCFSet.nedos
MPNonSCFSet.optics
MPNonSCFSet.reciprocal_density
MPNonSCFSet.small_gap_multiply
MPRelaxSet
MPRelaxSet.CONFIG
MPSOCSet
MPSOCSet.CONFIG
MPSOCSet.copy_chgcar
MPSOCSet.incar_updates
MPSOCSet.inherit_incar
MPSOCSet.kpoints_updates
MPSOCSet.lcalcpol
MPSOCSet.lepsilon
MPSOCSet.magmom
MPSOCSet.nbands_factor
MPSOCSet.reciprocal_density
MPSOCSet.saxis
MPSOCSet.small_gap_multiply
MPSOCSet.structure
MPScanRelaxSet
MPScanRelaxSet.CONFIG
MPScanRelaxSet.auto_ismear
MPScanRelaxSet.auto_kspacing
MPScanRelaxSet.bandgap
MPScanRelaxSet.user_potcar_functional
MPScanStaticSet
MPScanStaticSet.auto_kspacing
MPScanStaticSet.incar_updates
MPScanStaticSet.inherit_incar
MPScanStaticSet.lcalcpol
MPScanStaticSet.lepsilon
MPStaticSet
MPStaticSet.CONFIG
MPStaticSet.incar_updates
MPStaticSet.inherit_incar
MPStaticSet.kpoints_updates
MPStaticSet.lcalcpol
MPStaticSet.lepsilon
MPStaticSet.reciprocal_density
MPStaticSet.small_gap_multiply
MVLElasticSet
MVLElasticSet.CONFIG
MVLElasticSet.incar_updates
MVLElasticSet.potim
MVLGBSet
MVLGBSet.CONFIG
MVLGBSet.incar_updates
MVLGBSet.is_metal
MVLGBSet.k_product
MVLGBSet.kpoints_updates
MVLGBSet.slab_mode
MVLGWSet
MVLGWSet.CONFIG
MVLGWSet.SUPPORTED_MODES
MVLGWSet.copy_wavecar
MVLGWSet.force_gamma
MVLGWSet.from_prev_calc()
MVLGWSet.incar_updates
MVLGWSet.inherit_incar
MVLGWSet.kpoints_updates
MVLGWSet.mode
MVLGWSet.nbands
MVLGWSet.nbands_factor
MVLGWSet.ncores
MVLGWSet.reciprocal_density
MVLNPTMDSet
MVLNPTMDSet.CONFIG
MVLNPTMDSet.end_temp
MVLNPTMDSet.incar_updates
MVLNPTMDSet.kpoints_updates
MVLNPTMDSet.nsteps
MVLNPTMDSet.spin_polarized
MVLNPTMDSet.start_temp
MVLNPTMDSet.time_step
MVLRelax52Set
MVLRelax52Set.CONFIG
MVLRelax52Set.user_potcar_functional
MVLScanRelaxSet
MVLScanRelaxSet.CONFIG
MVLScanRelaxSet.incar_updates
MVLScanRelaxSet.user_potcar_functional
MVLSlabSet
MVLSlabSet.CONFIG
MVLSlabSet.as_dict()
MVLSlabSet.auto_dipole
MVLSlabSet.bulk
MVLSlabSet.incar_updates
MVLSlabSet.k_product
MVLSlabSet.kpoints_updates
MVLSlabSet.set_mix
MatPESStaticSet
MatPESStaticSet.CONFIG
MatPESStaticSet.inherit_incar
MatPESStaticSet.prev_incar
MatPESStaticSet.xc_functional
NEBSet
NEBSet.poscar
NEBSet.poscars
NEBSet.write_input()
VaspInputGenerator
VaspInputSet
VaspInputSet.as_dict()
VaspInputSet.auto_ismear
VaspInputSet.auto_ispin
VaspInputSet.auto_kspacing
VaspInputSet.auto_lreal
VaspInputSet.auto_metal_kpoints
VaspInputSet.bandgap
VaspInputSet.bandgap_tol
VaspInputSet.calculate_ng()
VaspInputSet.config_dict
VaspInputSet.constrain_total_magmom
VaspInputSet.estimate_nbands()
VaspInputSet.files_to_transfer
VaspInputSet.force_gamma
VaspInputSet.from_directory()
VaspInputSet.from_prev_calc()
VaspInputSet.get_input_set()
VaspInputSet.get_vasp_input()
VaspInputSet.incar
VaspInputSet.incar_updates
VaspInputSet.inherit_incar
VaspInputSet.international_monoclinic
VaspInputSet.kpoints
VaspInputSet.kpoints_updates
VaspInputSet.nelect
VaspInputSet.override_from_prev_calc()
VaspInputSet.poscar
VaspInputSet.potcar
VaspInputSet.potcar_functional
VaspInputSet.potcar_symbols
VaspInputSet.prev_incar
VaspInputSet.prev_kpoints
VaspInputSet.reduce_structure
VaspInputSet.sort_structure
VaspInputSet.standardize
VaspInputSet.structure
VaspInputSet.sym_prec
VaspInputSet.use_structure_charge
VaspInputSet.user_incar_settings
VaspInputSet.user_kpoints_settings
VaspInputSet.user_potcar_functional
VaspInputSet.user_potcar_settings
VaspInputSet.validate_magmom
VaspInputSet.vdw
VaspInputSet.write_input()
auto_kspacing()
batch_write_input()
get_structure_from_prev_run()
get_valid_magmom_struct()
get_vasprun_outcar()
next_num_with_prime_factors()
primes_less_than()
standardize_structure()
pymatgen
pymatgen.io.vasp package
Edit on GitHub
pymatgen.io.vasp package

This package implements modules for input and output to and from VASP. It
imports the key classes form both vasp_input and vasp_output to allow most
classes to be simply called as pymatgen.io.vasp.Incar for example, to retain
backwards compatibility.
Submodules

pymatgen.io.vasp.help module

Get help with VASP parameters from VASP wiki.
class
VaspDoc
[source]

Bases:
object
A VASP documentation helper.
Init for VaspDoc.
classmethod
get_help
(
tag
:
str
,
fmt
:
str
=
'text'
)
→
str
[source]

Get help on a VASP tag.
Parameters
:
tag
(
str
) – VASP tag, e.g. ISYM.
Returns
:
Help text.
classmethod
get_incar_tags
(
)
→
list
[
str
]
[source]

Get a list of all INCAR tags from the VASP wiki.
print_help
(
tag
:
str
)
→
None
[source]

Print the help for a TAG.
Parameters
:
tag
(
str
) – Tag used in VASP.
print_jupyter_help
(
tag
:
str
)
→
None
[source]

Display HTML help in ipython notebook.
Parameters
:
tag
(
str
) – Tag used in VASP.
pymatgen.io.vasp.inputs module

Classes for reading/manipulating/writing VASP input files.
All major VASP input files.
exception
BadIncarWarning
[source]

Bases:
UserWarning
Warning class for bad INCAR parameters.
exception
BadPoscarWarning
[source]

Bases:
UserWarning
Warning class for bad POSCAR entries.
class
Incar
(
params
:
Mapping
[
str
,
Any
]
|
None
=
None
)
[source]

Bases:
UserDict
,
MSONable
A case-insensitive dictionary to read/write INCAR files with additional helper functions.
Keys are stored in uppercase to allow case-insensitive access (set, get, del, update, setdefault).
String values are capitalized by default, except for keys specified
in the
lower_str_keys/as_is_str_keys
of the
proc_val
method.
Clean up params and create an Incar object.
Parameters
:
params
(
dict
) – INCAR parameters as a dictionary.
Warning
BadIncarWarning: If there are duplicate in keys (case insensitive).
as_dict
(
)
→
dict
[source]

MSONable dict.
check_params
(
)
→
None
[source]

Check INCAR for invalid tags or values.
If a tag doesn’t exist, calculation will still run, however VASP
will ignore the tag and set it as default without letting you know.
copy
(
)
→
Self
[source]

diff
(
other
:
Self
)
→
dict
[
str
,
dict
[
str
,
Any
]
]
[source]

Diff function for Incar. Compare two Incars and indicate which
parameters are the same and which are not. Useful for checking whether
two runs were done using the same parameters.
Parameters
:
other
(
Incar
) – The other Incar object to compare to.
Returns
:
of the following format:
{“Same” : parameters_that_are_the_same, “Different”: parameters_that_are_different}
Note that the parameters are return as full dictionaries of values. E.g. {“ISIF”:3}
Return type
:
dict[str, dict]
classmethod
from_dict
(
dct
:
dict
[
str
,
Any
]
)
→
Self
[source]

Parameters
:
dct
(
dict
) – Serialized Incar.
Returns
:
Incar
classmethod
from_file
(
filename
:
PathLike
)
→
Self
[source]

Read an Incar object from a file.
Parameters
:
filename
(
str
) – Filename for file
Returns
:
Incar object
classmethod
from_str
(
string
:
str
)
→
Self
[source]

Read an Incar object from a string.
Parameters
:
string
(
str
) – Incar string
Returns
:
Incar object
get
(
key
:
str
,
default
:
Any
=
None
)
→
Any
[source]

Get a value for a case-insensitive key, return default if not found.
get_str
(
sort_keys
:
bool
=
False
,
pretty
:
bool
=
False
)
→
str
[source]

Get a string representation of the INCAR. Differ from the
__str__ method to provide options for pretty printing.
Parameters
:
sort_keys
(
bool
) – Whether to sort the INCAR parameters
alphabetically. Defaults to False.
pretty
(
bool
) – Whether to pretty align output.
Defaults to False.
static
proc_val
(
key
:
str
,
val
:
str
)
→
list
|
bool
|
float
|
int
|
str
[source]

Helper method to convert INCAR parameters to proper types
like ints, floats, lists, etc.
Parameters
:
key
(
str
) – INCAR parameter key.
val
(
str
) – Value of INCAR parameter.
write_file
(
filename
:
PathLike
)
→
None
[source]

Write Incar to a file.
Parameters
:
filename
(
str
) – filename to write to.
class
Kpoints
(
comment
:
str
=
'Default
gamma'
,
num_kpts
:
int
=
0
,
style
:
KpointsSupportedModes
=
KpointsSupportedModes.Gamma
,
kpts
:
Sequence
[
Kpoint
]
=
((1,
1,
1),)
,
kpts_shift
:
tuple
[
float
,
float
,
float
]
=
(0,
0,
0)
,
kpts_weights
:
list
[
float
]
|
None
=
None
,
coord_type
:
Literal
[
'Reciprocal'
,
'Cartesian'
]
|
None
=
None
,
labels
:
list
[
str
]
|
None
=
None
,
tet_number
:
int
=
0
,
tet_weight
:
float
=
0
,
tet_connections
:
list
[
tuple
]
|
None
=
None
)
[source]

Bases:
MSONable
KPOINTS reader/writer.
Highly flexible constructor for Kpoints object. The flexibility comes
at the cost of usability and in general, it is recommended that you use
the default constructor only if you know exactly what you are doing and
requires the flexibility. For most usage cases, the three automatic
schemes can be constructed far more easily using the convenience static
constructors (automatic, gamma_automatic, monkhorst_automatic) and it
is recommended that you use those.
The default behavior of the constructor is for a Gamma-centered,
1x1x1 KPOINTS with no shift.
Parameters
:
comment
(
str
) – String comment for Kpoints. Defaults to “Default gamma”.
num_kpts
– Following VASP method of defining the KPOINTS file, this
parameter is the number of kpoints specified. If set to 0
(or negative), VASP automatically generates the KPOINTS.
style
– Style for generating KPOINTS. Use one of the
Kpoints.supported_modes enum types.
kpts
(
2D array
) – Array of kpoints. Even when only a single
specification is required, e.g. in the automatic scheme,
the kpts should still be specified as a 2D array. e.g.
[(20,),] or [(2, 2, 2),].
kpts_shift
(
3x1 array
) – Shift for kpoints.
kpts_weights
(
list
[
float
]
) – Optional weights for explicit kpoints.
coord_type
– In line-mode, this variable specifies whether the
Kpoints were given in Cartesian or Reciprocal coordinates.
labels
– In line-mode, this should provide a list of labels for
each kpt. It is optional in explicit kpoint mode as comments for
k-points.
tet_number
– For explicit kpoints, specifies the number of
tetrahedrons for the tetrahedron method.
tet_weight
– For explicit kpoints, specifies the weight for each
tetrahedron for the tetrahedron method.
tet_connections
– For explicit kpoints, specifies the connections
of the tetrahedrons for the tetrahedron method.
Format is a list of tuples, [ (sym_weight, [tet_vertices]),
…]
as_dict
(
)
→
dict
[
str
,
Any
]
[source]

MSONable dict.
classmethod
automatic
(
subdivisions
:
int
,
comment
:
str
=
'Fully
automatic
kpoint
scheme'
)
→
Self
[source]

Constructor for a fully automatic Kpoint grid, with
Gamma-centered grids and the number of subdivisions
along each reciprocal lattice vector determined by the scheme in the
VASP manual.
Parameters
:
subdivisions
(
int
) – Number of subdivisions along
each reciprocal lattice vector.
comment
(
str
) – Comment in Kpoints.
Returns
:
Kpoints
classmethod
automatic_density
(
structure
:
Structure
|
IStructure
,
kppa
:
float
,
force_gamma
:
bool
=
False
,
comment
:
str
|
None
=
None
)
→
Self
[source]

Get an automatic Kpoints object based on a structure and a kpoint
density. Uses Gamma centered meshes for hexagonal cells and face-centered cells,
Monkhorst-Pack grids otherwise.
Algorithm:
Uses a simple approach scaling the number of divisions along each
reciprocal lattice vector proportional to its length.
Parameters
:
structure
(
Structure
) – Input structure.
kppa
(
float
) – Grid density.
force_gamma
(
bool
) – Force a gamma centered mesh (default is to
use gamma only for hexagonal cells or odd meshes).
comment
(
str
) – Comment in Kpoints.
Returns
:
Kpoints
classmethod
automatic_density_by_lengths
(
structure
:
Structure
|
IStructure
,
length_densities
:
Sequence
[
float
]
,
force_gamma
:
bool
=
False
,
comment
:
str
|
None
=
None
)
→
Self
[source]

Get an automatic Kpoints object based on a structure and a k-point
density normalized by lattice constants.
Algorithm:
For a given dimension, the number of k-points is chosen as
length_density = # of kpoints * lattice constant, e.g. [50.0, 50.0, 1.0] would
have k-points of 50/a x 50/b x 1/c.
Parameters
:
structure
(
Structure
) – Input structure.
length_densities
(
list
[
float
]
) – Defines the density of k-points in each.
dimension
[
50.0
(
e.g.
)
50.0
1.0
]
.
force_gamma
(
bool
) – Force a gamma centered mesh.
comment
(
str
) – Comment in Kpoints.
Returns
:
Kpoints
classmethod
automatic_density_by_vol
(
structure
:
Structure
|
IStructure
,
kppvol
:
int
,
force_gamma
:
bool
=
False
,
comment
:
str
|
None
=
None
)
→
Self
[source]

Get an automatic Kpoints object based on a structure and a kpoint
density per inverse Angstrom^3 of reciprocal cell.
Algorithm:
Same as automatic_density()
Parameters
:
structure
(
Structure
) – Input structure.
kppvol
(
int
) – Grid density per Angstrom^(-3) of reciprocal cell.
force_gamma
(
bool
) – Force a gamma centered mesh.
comment
(
str
) – Comment in Kpoints.
Returns
:
Kpoints
classmethod
automatic_gamma_density
(
structure
:
Structure
|
IStructure
,
kppa
:
float
,
comment
:
str
|
None
=
None
)
→
Self
[source]

Get an automatic Kpoints object based on a structure and a kpoint
density. Uses Gamma centered meshes always. For GW.
Algorithm:
Uses a simple approach scaling the number of divisions along each
reciprocal lattice vector proportional to its length.
Parameters
:
structure
(
Structure
) – Input structure
kppa
(
float
) – Grid density
comment
(
str
) – Comment in Kpoints.
classmethod
automatic_linemode
(
divisions
:
int
,
ibz
:
HighSymmKpath
,
comment
:
str
=
'Line_mode
KPOINTS
file'
)
→
Self
[source]

Convenient static constructor for a KPOINTS in mode line_mode.
gamma centered Monkhorst-Pack grids and the number of subdivisions
along each reciprocal lattice vector determined by the scheme in the
VASP manual.
Parameters
:
divisions
(
int
) – Parameter determining the number of k-points along each high symmetry line.
ibz
(
HighSymmKpath
) – HighSymmKpath object (pymatgen.symmetry.bandstructure).
comment
(
str
) – Comment in Kpoints.
Returns
:
Kpoints object
copy
(
)
→
Self
[source]

Make a copy of the Kpoints object.
classmethod
from_dict
(
dct
:
dict
[
str
,
Any
]
)
→
Self
[source]

Parameters
:
dct
(
dict
) – Dict representation.
Returns
:
Kpoints
classmethod
from_file
(
filename
:
PathLike
)
→
Self
[source]

Read a Kpoints object from a KPOINTS file.
Parameters
:
filename
(
PathLike
) – File to read.
Returns
:
Kpoints object
classmethod
from_str
(
string
:
str
)
→
Self
[source]

Reads a Kpoints object from a KPOINTS string.
Parameters
:
string
(
str
) – KPOINTS string.
Returns
:
Kpoints object
classmethod
gamma_automatic
(
kpts
:
tuple
[
int
,
int
,
int
]
=
(1,
1,
1)
,
shift
:
tuple
[
float
,
float
,
float
]
=
(0,
0,
0)
,
comment
:
str
=
'Automatic
kpoint
scheme'
)
→
Self
[source]

Construct an automatic Gamma-centered Kpoint grid.
Parameters
:
kpts
– Subdivisions N_1, N_2 and N_3 along reciprocal lattice
vectors. Defaults to (1, 1, 1)
shift
– Shift to be applied to the kpoints. Defaults to (0, 0, 0).
comment
(
str
) – Comment in Kpoints.
Returns
:
Kpoints
property
kpts
:
list
[
Kpoint
]
[source]

A sequence of Kpoints, where each Kpoint is a tuple of 3 or 1.
classmethod
monkhorst_automatic
(
kpts
:
tuple
[
int
,
int
,
int
]
=
(2,
2,
2)
,
shift
:
tuple
[
float
,
float
,
float
]
=
(0,
0,
0)
,
comment
:
str
=
'Automatic
kpoint
scheme'
)
→
Self
[source]

Construct an automatic Monkhorst-Pack Kpoint grid.
Parameters
:
kpts
– Subdivisions N_1, N_2, N_3 along reciprocal lattice
vectors. Defaults to (2, 2, 2)
shift
– Shift to be applied to the kpoints. Defaults to (0, 0, 0).
comment
(
str
) – Comment in Kpoints.
Returns
:
Kpoints
property
style
:
KpointsSupportedModes
[source]

Style for kpoint generation. One of Kpoints_supported_modes enum.
supported_modes
[source]

alias of
KpointsSupportedModes
write_file
(
filename
:
PathLike
)
→
None
[source]

Write Kpoints to a file.
Parameters
:
filename
(
PathLike
) – Filename to write to.
class
KpointsSupportedModes
(
value
)
[source]

Bases:
Enum
Enum type of all supported modes for Kpoint generation.
Automatic
=
0
[source]

Cartesian
=
4
[source]

Gamma
=
1
[source]

Line_mode
=
3
[source]

Monkhorst
=
2
[source]

Reciprocal
=
5
[source]

classmethod
from_str
(
mode
:
str
)
→
Self
[source]

Parameters
:
mode
– String.
Returns
:
Kpoints_supported_modes
class
Orbital
(
n
,
l
,
j
,
E
,
occ
)
[source]

Bases:
NamedTuple
Create new instance of Orbital(n, l, j, E, occ)
E
:
float
[source]

Alias for field number 3
j
:
float
[source]

Alias for field number 2
l
:
int
[source]

Alias for field number 1
n
:
int
[source]

Alias for field number 0
occ
:
float
[source]

Alias for field number 4
class
OrbitalDescription
(
l
,
E
,
Type
,
Rcut
,
Type2
,
Rcut2
)
[source]

Bases:
NamedTuple
Create new instance of OrbitalDescription(l, E, Type, Rcut, Type2, Rcut2)
E
:
float
[source]

Alias for field number 1
Rcut
:
float
[source]

Alias for field number 3
Rcut2
:
float
|
None
[source]

Alias for field number 5
Type
:
int
[source]

Alias for field number 2
Type2
:
int
|
None
[source]

Alias for field number 4
l
:
int
[source]

Alias for field number 0
exception
PmgVaspPspDirError
[source]

Bases:
ValueError
Error thrown when PMG_VASP_PSP_DIR is not configured, but POTCAR is requested.
class
Poscar
(
structure
:
Structure
|
IStructure
,
comment
:
str
|
None
=
None
,
selective_dynamics
:
ArrayLike
|
None
=
None
,
true_names
:
bool
=
True
,
velocities
:
ArrayLike
|
None
=
None
,
predictor_corrector
:
ArrayLike
|
None
=
None
,
predictor_corrector_preamble
:
str
|
None
=
None
,
lattice_velocities
:
ArrayLike
|
None
=
None
,
sort_structure
:
bool
=
False
)
[source]

Bases:
MSONable
Represent the data in a POSCAR or CONTCAR file.
structure
[source]

Associated Structure.
comment
[source]

Optional comment string.
true_names
[source]

Boolean indication whether Poscar contains actual real names parsed
from either a POTCAR or the POSCAR itself.
selective_dynamics
[source]

Selective dynamics attribute for each site if available.
A Nx3 array of booleans.
velocities
[source]

Velocities for each site (typically read in from a CONTCAR).
A Nx3 array of floats.
predictor_corrector
[source]

Predictor corrector coordinates and derivatives for each site;
i.e. a list of three 1x3 arrays for each site (typically read in from an MD CONTCAR).
predictor_corrector_preamble
[source]

Predictor corrector preamble contains the predictor-corrector key,
POTIM, and thermostat parameters that precede the site-specific predictor corrector data in MD CONTCAR.
lattice_velocities
[source]

Lattice velocities and current lattice (typically read
in from an MD CONTCAR). A 6x3 array of floats.
temperature
[source]

Temperature of velocity Maxwell-Boltzmann initialization.
Initialized to -1 (MB hasn’t been performed).
Parameters
:
structure
(
Structure
) – Structure object.
comment
(
str
|
None
,
optional
) – Optional comment line for POSCAR. Defaults to unit
cell formula of structure. Defaults to None.
selective_dynamics
(
ArrayLike
|
None
,
optional
) – Bool values for selective dynamics,
where N is the number of sites. Defaults to None.
true_names
(
bool
,
optional
) – Set to False if the names in the POSCAR are not
well-defined and ambiguous. This situation arises commonly in
VASP < 5 where the POSCAR sometimes does not contain element
symbols. Defaults to True.
velocities
(
ArrayLike
|
None
,
optional
) – Velocities for the POSCAR. Typically parsed
in MD runs or can be used to initialize velocities. Defaults to None.
predictor_corrector
(
ArrayLike
|
None
,
optional
) – Predictor corrector for the POSCAR.
Typically parsed in MD runs. Defaults to None.
predictor_corrector_preamble
(
str
|
None
,
optional
) – Preamble to the predictor
corrector. Defaults to None.
lattice_velocities
(
ArrayLike
|
None
,
optional
) – Lattice velocities and current
lattice for the POSCAR. Available in MD runs with variable cell. Defaults to None.
sort_structure
(
bool
,
optional
) – Whether to sort the structure. Useful if species
are not grouped properly together. Defaults to False.
as_dict
(
)
→
dict
[source]

MSONable dict.
classmethod
from_dict
(
dct
:
dict
)
→
Self
[source]

Parameters
:
dct
(
dict
) – Dict representation.
Returns
:
Poscar
classmethod
from_file
(
filename
:
PathLike
,
check_for_potcar
:
bool
=
True
,
read_velocities
:
bool
=
True
,
**
kwargs
:
dict
[
str
,
Any
]
)
→
Self
[source]

Read POSCAR from a file.
The code will try its best to determine the elements in the POSCAR in
the following order:
1. If check_for_potcar is True, the code will try to check if a POTCAR
is in the same directory as the POSCAR and use elements from that by
default. (This is the VASP default sequence of priority).
2. If the input file is VASP5-like and contains element symbols in the
6th line, the code will use that if check_for_potcar is False or there
is no POTCAR found.
3. Failing (2), the code will check if a symbol is provided at the end
of each coordinate.
If all else fails, the code will just assign the first n elements in
increasing atomic number, where n is the number of species, to the
Poscar, where a warning would be issued. For example, H, He, Li, ….
This will ensure at least a unique element is assigned to each site and
any analysis that does not require specific elemental properties should work.
Parameters
:
filename
(
str
) – File name containing Poscar data.
check_for_potcar
(
bool
) – Whether to check if a POTCAR is present
in the same directory as the POSCAR. Defaults to True.
read_velocities
(
bool
) – Whether to read or not velocities if they
are present in the POSCAR. Default is True.
Returns
:
Poscar object.
classmethod
from_str
(
data
:
str
,
default_names
:
list
[
str
]
|
None
=
None
,
read_velocities
:
bool
=
True
)
→
Self
[source]

Read POSCAR from a string.
The code will try its best to determine the elements in the POSCAR in
the following order:
1. If default_names are supplied and valid, it will use those. Usually,
default names comes from an external source, such as a POTCAR in the
same directory.
2. If there are no valid default names but the input file is VASP5-like
and contains element symbols in the 6th line, the code will use that.
3. Failing (2), the code will check if a symbol is provided at the end
of each coordinate.
If all else fails, the code will just assign the first n elements in
increasing atomic number, where n is the number of species, to the
Poscar. For example, H, He, Li, …. This will ensure at least a
unique element is assigned to each site and any analysis that does not
require specific elemental properties should work fine.
Parameters
:
data
(
str
) – String containing Poscar data.
default_names
(
[
str
]
) – Default symbols for the POSCAR file,
usually coming from a POTCAR in the same directory. This
could be used to convert a VASP 4 POSCAR to POSCAR 5/6 format.
read_velocities
(
bool
) – Whether to read or not velocities if they
are present in the POSCAR. Default is True.
Returns
:
Poscar object.
get_str
(
direct
:
bool
=
True
,
vasp4_compatible
:
bool
=
False
,
significant_figures
:
int
=
16
)
→
str
[source]

Return a string to be written as a POSCAR file. By default, site
symbols are written, which is compatible for VASP >= 5.
Parameters
:
direct
(
bool
) – Whether coordinates are output in direct or
Cartesian. Defaults to True.
vasp4_compatible
(
bool
) – Set to True to omit site symbols on 6th
line to maintain backward VASP 4.x compatibility. Defaults
to False.
significant_figures
(
int
) – Number of significant digits to
output all quantities. Defaults to 16. Note that positions are
output in fixed point, while velocities are output in
scientific format.
Returns
:
representation of POSCAR.
Return type
:
str
get_string
(
direct
:
bool
=
True
,
vasp4_compatible
:
bool
=
False
,
significant_figures
:
int
=
16
)
→
str
[source]

Return a string to be written as a POSCAR file. By default, site
symbols are written, which is compatible for VASP >= 5.
Parameters
:
direct
(
bool
) – Whether coordinates are output in direct or
Cartesian. Defaults to True.
vasp4_compatible
(
bool
) – Set to True to omit site symbols on 6th
line to maintain backward VASP 4.x compatibility. Defaults
to False.
significant_figures
(
int
) – Number of significant digits to
output all quantities. Defaults to 16. Note that positions are
output in fixed point, while velocities are output in
scientific format.
Returns
:
representation of POSCAR.
Return type
:
str
property
lattice_velocities
:
ArrayLike
|
None
[source]

Lattice velocities in Poscar (including the current lattice vectors).
property
natoms
:
list
[
int
]
[source]

Sequence of number of sites of each type associated with the Poscar.
Similar to 7th line in VASP 5+ POSCAR or the 6th line in VASP 4 POSCAR.
property
predictor_corrector
:
ArrayLike
|
None
[source]

Predictor corrector in Poscar.
property
predictor_corrector_preamble
:
str
|
None
[source]

Predictor corrector preamble in Poscar.
property
selective_dynamics
:
ArrayLike
|
None
[source]

Selective dynamics in Poscar.
set_temperature
(
temperature
:
float
)
→
None
[source]

Initialize the velocities based on Maxwell-Boltzmann distribution.
Removes linear, but not angular drift (same as VASP).
Scale the energies to the exact temperature (microcanonical ensemble)
Velocities are given in A/fs. This is the VASP default when
direct/cartesian is not specified (even when positions are given in
direct coordinates).
Overwrite imported velocities, if any.
Parameters
:
temperature
(
float
) – Temperature in Kelvin.
property
site_symbols
:
list
[
str
]
[source]

Sequence of symbols associated with the Poscar. Similar to 6th line in VASP 5+ POSCAR.
property
velocities
:
ArrayLike
|
None
[source]

Velocities in Poscar.
write_file
(
filename
:
PathLike
,
**
kwargs
)
→
None
[source]

Write POSCAR to a file. The supported kwargs are the same as those for
the Poscar.get_str method and are passed through directly.
class
Potcar
(
symbols
:
Sequence
[
str
]
|
None
=
None
,
functional
:
str
|
None
=
None
,
sym_potcar_map
:
dict
[
str
,
str
]
|
None
=
None
)
[source]

Bases:
list
,
MSONable
Read and write POTCAR files for calculations. Consists of a list of PotcarSingle.
Parameters
:
symbols
(
list
[
str
]
) – Element symbols for POTCAR. This should correspond
to the symbols used by VASP. e.g. “Mg”, “Fe_pv”, etc.
functional
(
str
) – Functional used. To know what functional options
there are, use Potcar.FUNCTIONAL_CHOICES. Note that VASP has
different versions of the same functional. By default, the old
PBE functional is used. If you want the newer ones, use PBE_52 or
PBE_54. Note that if you intend to compare your results with the
Materials Project, you should use the default setting. You can also
override the default by setting PMG_DEFAULT_FUNCTIONAL in your
.pmgrc.yaml.
sym_potcar_map
(
dict
) – Allows a user to specify a specific element
symbol to raw POTCAR mapping.
FUNCTIONAL_CHOICES
:
ClassVar
[
tuple
]
=
('PBE',
'PBE_52',
'PBE_52_W_HASH',
'PBE_54',
'PBE_54_W_HASH',
'PBE_64',
'LDA',
'LDA_52',
'LDA_52_W_HASH',
'LDA_54',
'LDA_54_W_HASH',
'LDA_64',
'PW91',
'LDA_US',
'PW91_US',
'Perdew_Zunger81')
[source]

as_dict
(
)
→
dict
[source]

MSONable dict representation.
classmethod
from_dict
(
dct
:
dict
)
→
Potcar
[source]

Parameters
:
dct
(
dict
) – Dict representation.
Returns
:
Potcar
classmethod
from_file
(
filename
:
str
)
[source]

Reads Potcar from file.
Parameters
:
filename
– Filename
Returns
:
Potcar
classmethod
from_spec
(
potcar_spec
:
list
[
dict
]
,
functionals
:
list
[
str
]
|
None
=
None
)
→
Potcar
[source]

Generate a POTCAR from a list of POTCAR spec dicts.
If a set of POTCARs
for the same functional
cannot be found, raises a ValueError.
:param potcar_spec: list[dict]
List of POTCAR specs, from Potcar.spec or [PotcarSingle.spec]
Parameters
:
functionals
– list[str] or None (default)
If a list of strings, the functionals to restrict the search to.
Returns
:
Potcar, a POTCAR using a single functional that matches the input spec.
classmethod
from_str
(
data
:
str
)
[source]

Read Potcar from a string.
Parameters
:
data
– Potcar as a string.
Returns
:
Potcar
set_symbols
(
symbols
:
Sequence
[
str
]
,
functional
:
str
|
None
=
None
,
sym_potcar_map
:
dict
[
str
,
str
]
|
None
=
None
)
→
None
[source]

Initialize the POTCAR from a set of symbols. Currently, the POTCARs can
be fetched from a location specified in .pmgrc.yaml. Use pmg config
to add this setting.
Parameters
:
symbols
(
list
[
str
]
) – A list of element symbols
functional
(
str
) – The functional to use. If None, the setting
PMG_DEFAULT_FUNCTIONAL in .pmgrc.yaml is used, or if this is
not set, it will default to PBE.
sym_potcar_map
(
dict
) – A map of symbol to raw POTCAR string. If
sym_potcar_map is specified, POTCARs will be generated from
the given map data rather than the config file location.
property
spec
:
list
[
dict
]
[source]

POTCAR spec for all POTCARs in this instance.
Parameters
:
extra_spec
– Sequence[str] or None (default)
A list of extra POTCAR fields to include in the spec.
If None, defaults to [“symbol”] (needed for compatibility with LOBSTER).
Returns
:
list[dict], a list of PotcarSingle.spec dicts
property
symbols
:
list
[
str
]
[source]

The atomic symbols of all the atoms in the POTCAR file.
write_file
(
filename
:
PathLike
)
→
None
[source]

Write Potcar to a file.
Parameters
:
filename
(
PathLike
) – filename to write to.
write_potcar_spec
(
filename
:
str
=
'POTCAR.spec.json.gz'
)
→
None
[source]

Write POTCAR spec to file.
Parameters
:
filename
– str = “POTCAR.spec.json.gz”
The name of a file to write the POTCAR spec to.
class
PotcarSingle
(
data
:
str
,
symbol
:
str
|
None
=
None
)
[source]

Bases:
object
Object for a
single
POTCAR. The builder assumes the POTCAR contains
the complete untouched string “data” and a dict of keywords.
data
[source]

POTCAR data as a string.
Type
:
str
keywords
[source]

Keywords parsed from the POTCAR as a dict. All keywords are also
accessible as attributes in themselves. e.g. potcar.enmax, potcar.encut, etc.
Type
:
dict
MD5 hashes of the entire POTCAR file and the actual data are validated
against a database of known good hashes. Appropriate warnings or errors
are raised if validation fails.
Parameters
:
data
(
str
) – Complete, single and raw POTCAR file as a string.
symbol
(
str
) – POTCAR symbol corresponding to the filename suffix
e.g. “Tm_3” for POTCAR.TM_3”.
If not given, pymatgen will attempt to extract the symbol
from the file itself, but is not always reliable!
property
atomic_no
:
int
[source]

Attempt to return the atomic number based on the VRHFIN keyword.
static
compare_potcar_stats
(
potcar_stats_1
:
dict
,
potcar_stats_2
:
dict
,
tolerance
:
float
=
1e-06
,
check_potcar_fields
:
Sequence
[
str
]
=
['header',
'data']
)
→
bool
[source]

Compare PotcarSingle._summary_stats to assess if they are the same within a tolerance.
Parameters
:
potcar_stats_1
– dict
Dict of potcar summary stats from the first PotcarSingle, from the PotcarSingle._summary stats attr
potcar_stats_2
– dict
Second dict of summary stats
tolerance
– float = 1.e-6
Tolerance to assess equality of numeric statistical values
check_potcar_fields
– Sequence[str] = [“header”, “data”]
The specific fields of the POTCAR to check, whether just the “header”, just the “data”, or both
Returns
:
bool
Whether the POTCARs are identical according to their summary stats.
copy
(
)
→
Self
[source]

Return a copy of the PotcarSingle.
Returns
:
PotcarSingle
property
electron_configuration
:
list
[
tuple
[
int
,
str
,
float
]
]
[source]

Valence electronic configuration corresponding to the ZVAL,
read from the “Atomic configuration” section of POTCAR.
Returns
:
A list of tuples containing:
n (int): Principal quantum number.
subshell (str): Subshell notation (s, p, d, f).
occ (float): Occupation number, limited to ZVAL.
Return type
:
list[tuple[int, str, float]]
property
element
:
str
[source]

Attempt to return the atomic symbol based on the VRHFIN keyword.
classmethod
from_file
(
filename
:
PathLike
)
→
Self
[source]

Read PotcarSingle from file.
Parameters
:
filename
– Filename.
Returns
:
PotcarSingle
classmethod
from_symbol_and_functional
(
symbol
:
str
,
functional
:
str
|
None
=
None
)
→
Self
[source]

Make a PotcarSingle from a symbol and functional.
Parameters
:
symbol
(
str
) – Symbol, e.g. Li_sv
functional
(
str
) – Functional, e.g. PBE
Returns
:
PotcarSingle
property
functional
:
str
|
None
[source]

Functional associated with PotcarSingle.
property
functional_class
:
str
|
None
[source]

Functional class associated with PotcarSingle.
functional_dir
:
ClassVar
[
dict
[
str
,
str
]
]
=
{'LDA':
'POT_LDA_PAW',
'LDA_52':
'POT_LDA_PAW_52',
'LDA_52_W_HASH':
'POTPAW_LDA_52',
'LDA_54':
'POT_LDA_PAW_54',
'LDA_54_W_HASH':
'POTPAW_LDA_54',
'LDA_64':
'POT_LDA_PAW_64',
'LDA_US':
'POT_LDA_US',
'PBE':
'POT_GGA_PAW_PBE',
'PBE_52':
'POT_GGA_PAW_PBE_52',
'PBE_52_W_HASH':
'POTPAW_PBE_52',
'PBE_54':
'POT_GGA_PAW_PBE_54',
'PBE_54_W_HASH':
'POTPAW_PBE_54',
'PBE_64':
'POT_PAW_PBE_64',
'PW91':
'POT_GGA_PAW_PW91',
'PW91_US':
'POT_GGA_US_PW91',
'Perdew_Zunger81':
'POT_LDA_PAW'}
[source]

functional_tags
:
ClassVar
[
dict
[
str
,
dict
[
Literal
[
'name'
,
'class'
]
,
str
]
]
]
=
{'91':
{'class':
'GGA',
'name':
'PW91'},
'am':
{'class':
'GGA',
'name':
'AM05'},
'ca':
{'class':
'LDA',
'name':
'Perdew-Zunger81'},
'hl':
{'class':
'LDA',
'name':
'Hedin-Lundquist'},
'lm':
{'class':
'GGA',
'name':
'Langreth-Mehl-Hu'},
'pb':
{'class':
'GGA',
'name':
'Perdew-Becke'},
'pe':
{'class':
'GGA',
'name':
'PBE'},
'ps':
{'class':
'GGA',
'name':
'PBEsol'},
'pw':
{'class':
'GGA',
'name':
'PW86'},
'rp':
{'class':
'GGA',
'name':
'revPBE'},
'wi':
{'class':
'LDA',
'name':
'Wigner
Interpolation'}}
[source]

get_electron_configuration
(
tol
:
float
=
0.01
)
→
list
[
tuple
[
int
,
str
,
float
]
]
[source]

Valence electronic configuration corresponding to the ZVAL,
read from the “Atomic configuration” section of POTCAR.
Parameters
:
tol
(
float
) –
Tolerance for occupation numbers.
- Orbitals with an occupation below
tol
are considered empty.
- Accumulation of electrons stops once the total occupation
reaches
ZVAL - tol
, preventing unnecessary additions.
Returns
:
A list of tuples containing:
n (int): Principal quantum number.
subshell (str): Subshell notation (s, p, d, f).
occ (float): Occupation number, limited to ZVAL.
Return type
:
list[tuple[int, str, float]]
property
hash_sha256_from_file
:
str
|
None
[source]

SHA256 hash of the POTCAR file as read from the file. None if no SHA256 hash is found.
identify_potcar
(
mode
:
Literal
[
'data'
,
'file'
]
=
'data'
,
data_tol
:
float
=
1e-06
)
→
tuple
[
list
[
str
]
,
list
[
str
]
]
[source]

Identify the symbol and compatible functionals associated with this PotcarSingle.
This method checks the summary statistics of either the POTCAR metadadata
(PotcarSingle._summary_stats[key][“header”] for key in (“keywords”, “stats”) )
or the entire POTCAR file (PotcarSingle._summary_stats) against a database
of hashes for POTCARs distributed with VASP 5.4.4.
Parameters
:
mode
(
"data"
or
"file"
) – “data” mode checks the POTCAR header keywords
and stats only while “file” mode checks the entire summary stats.
data_tol
(
float
) – Tolerance for comparing the summary statistics of the POTCAR
with the reference statistics.
Returns
:
List of symbols associated with the PotcarSingle
potcar_functionals (list): List of potcar functionals associated with
the PotcarSingle
Return type
:
symbol (list)
identify_potcar_hash_based
(
mode
:
Literal
[
'data'
,
'file'
]
=
'data'
)
→
tuple
[
list
[
str
]
,
list
[
str
]
]
[source]

Identify the symbol and compatible functionals associated with this PotcarSingle.
This method checks the MD5 hash of either the POTCAR metadadata (PotcarSingle.md5_header_hash)
or the entire POTCAR file (PotcarSingle.md5_computed_file_hash) against a database
of hashes for POTCARs distributed with VASP 5.4.4.
Parameters
:
mode
(
"data"
|
"file"
) – “data” mode checks the hash of the POTCAR metadata in self.keywords,
while “file” mode checks the hash of the entire POTCAR file.
Returns
:
List of symbols associated with the PotcarSingle
potcar_functionals (list): List of potcar functionals associated with
the PotcarSingle
Return type
:
symbol (list)
property
is_valid
:
bool
[source]

Check that POTCAR matches reference metadata.
Parsed metadata is stored in self._summary_stats as a human-readable dict,
self._summary_stats = {
“keywords”: {
“header”: list[str],
“data”: list[str],
},
“stats”: {
“header”: dict[float],
“data”: dict[float],
},
}.
Rationale:
Each POTCAR is structured as
Header (self.keywords)
Data (actual pseudopotential values in data blocks)
For the Data block of POTCAR, there are unformatted data blocks
of unknown length and contents/data type, e.g. you might see
<float> <bool>
<Data Keyword>
<int> <int> <float>
<float> … <float>
<Data Keyword>
<float> … <float>
but this is impossible to process algorithmically without a full POTCAR schema.
Note also that POTCARs can contain
different
data keywords
All keywords found in the header, essentially self.keywords, and the data block
(<Data Keyword> above) are stored in self._summary_stats[“keywords”]
To avoid issues of copyright, statistics (mean, mean of abs vals, variance, max, min)
for the numeric values in the header and data sections of POTCAR are stored
in self._summary_stats[“stats”]
tol is then used to match statistical values within a tolerance
property
md5_computed_file_hash
:
str
[source]

MD5 hash of the entire PotcarSingle.
property
md5_header_hash
:
str
[source]

MD5 hash of the metadata defining the PotcarSingle.
property
nelectrons
:
float
[source]

Number of electrons.
parse_functions
:
ClassVar
[
dict
[
str
,
Any
]
]
=
{'COPYR':
<method
'strip'
of
'str'
objects>,
'DEXC':
<function
_parse_float>,
'EATOM':
<function
_parse_float>,
'EAUG':
<function
_parse_float>,
'EMMIN':
<function
_parse_float>,
'ENMAX':
<function
_parse_float>,
'ENMIN':
<function
_parse_float>,
'GGA':
<function
_parse_list>,
'ICORE':
<function
_parse_int>,
'IUNSCR':
<function
_parse_int>,
'LCOR':
<function
_parse_bool>,
'LEXCH':
<method
'strip'
of
'str'
objects>,
'LPAW':
<function
_parse_bool>,
'LULTRA':
<function
_parse_bool>,
'LUNSCR':
<function
_parse_bool>,
'NDATA':
<function
_parse_int>,
'POMASS':
<function
_parse_float>,
'QCUT':
<function
_parse_float>,
'QGAM':
<function
_parse_float>,
'RAUG':
<function
_parse_float>,
'RCLOC':
<function
_parse_float>,
'RCORE':
<function
_parse_float>,
'RDEP':
<function
_parse_float>,
'RDEPT':
<function
_parse_float>,
'RMAX':
<function
_parse_float>,
'RPACOR':
<function
_parse_float>,
'RRKJ':
<function
_parse_list>,
'RWIGS':
<function
_parse_float>,
'SHA256':
<method
'strip'
of
'str'
objects>,
'STEP':
<function
_parse_list>,
'TITEL':
<method
'strip'
of
'str'
objects>,
'VRHFIN':
<method
'strip'
of
'str'
objects>,
'ZVAL':
<function
_parse_float>}
[source]

property
potential_type
:
Literal
[
'NC'
,
'PAW'
,
'US'
]
[source]

NC (Norm-conserving), US (Ultra-soft), PAW (Projector augmented wave).
Type
:
Type of PSP
property
sha256_computed_file_hash
:
str
[source]

Compute a SHA256 hash of the PotcarSingle EXCLUDING lines starting with ‘SHA256’ and ‘COPYR’.
spec
(
extra_spec
:
Sequence
[
str
]
|
None
=
None
)
→
dict
[
str
,
Any
]
[source]

POTCAR spec used in vasprun.xml.
Parameters
:
extra_spec
– Sequence[str] or None (default)
A list of extra POTCAR fields to include in the spec.
If None, defaults to no extra spec.
Returns
:
dict of POTCAR spec
property
symbol
:
str
[source]

The POTCAR symbol, e.g. W_pv.
verify_potcar
(
)
→
tuple
[
bool
,
bool
]
[source]

Attempt to verify the integrity of the POTCAR data.
This method checks the whole file (removing only the SHA256
metadata) against the SHA256 hash in the header if this is found.
If no SHA256 hash is found in the file, the file hash (md5 hash of the
whole file) is checked against all POTCAR file hashes known to pymatgen.
Returns
:
has_sha256 and passed_hash_check.
Return type
:
tuple[bool, bool]
write_file
(
filename
:
str
)
→
None
[source]

Write PotcarSingle to a file.
Parameters
:
filename
(
str
) – File to write to.
exception
UnknownPotcarWarning
[source]

Bases:
UserWarning
Warning raised when POTCAR hashes do not pass validation.
class
VaspInput
(
incar
:
Mapping
[
str
,
Any
]
,
kpoints
:
Kpoints
|
None
,
poscar
:
Poscar
,
potcar
:
Potcar
|
str
|
None
,
potcar_spec
:
bool
=
False
,
optional_files
:
dict
[
PathLike
,
object
]
|
None
=
None
,
**
kwargs
)
[source]

Bases:
dict
,
MSONable
Contain a set of VASP input objects corresponding to a run.
Initialize a VaspInput object with the given input files.
Parameters
:
incar
(
Incar
) – The Incar object.
kpoints
(
Kpoints
) – The Kpoints object.
poscar
(
Poscar
) – The Poscar object.
potcar
(
Potcar
or
str
) – The Potcar object.
potcar_spec
(
bool = False
) – used to share POTCAR info without license issues.
True –> POTCAR is a list of symbols, write POTCAR.spec
False –> POTCAR is a VASP POTCAR, write POTCAR
optional_files
(
dict
) – Other input files supplied as a dict of {filename: object}.
The object should follow standard pymatgen conventions in implementing a
as_dict() and from_dict method.
**kwargs
– Additional keyword arguments to be stored in the VaspInput object.
as_dict
(
)
→
dict
[source]

MSONable dict.
copy
(
deep
:
bool
=
True
)
→
Self
[source]

Deep copy of VaspInput.
classmethod
from_dict
(
dct
:
dict
)
→
Self
[source]

Parameters
:
dct
(
dict
) – Dict representation.
Returns
:
VaspInput
classmethod
from_directory
(
input_dir
:
PathLike
,
optional_files
:
dict
|
None
=
None
)
→
Self
[source]

Read in a set of VASP inputs from a directory. Note that only the
standard INCAR, POSCAR, POTCAR and KPOINTS files are read unless
optional_filenames is specified.
Parameters
:
input_dir
(
PathLike
) – Directory to read VASP input from.
optional_files
(
dict
) – Optional files to read in as a
dict of {filename: Object type}. Objects must have
from_file method.
property
incar
:
Incar
[source]

INCAR object.
property
kpoints
:
Kpoints
|
None
[source]

KPOINTS object.
property
poscar
:
Poscar
[source]

POSCAR object.
property
potcar
:
Potcar
|
str
|
None
[source]

POTCAR or POTCAR.spec object.
run_vasp
(
run_dir
:
PathLike
=
'.'
,
vasp_cmd
:
list
|
None
=
None
,
output_file
:
PathLike
=
'vasp.out'
,
err_file
:
PathLike
=
'vasp.err'
)
→
None
[source]

Write input files and run VASP.
Parameters
:
run_dir
– Where to write input files and do the run.
vasp_cmd
– Args to be supplied to run VASP. Otherwise, the
PMG_VASP_EXE in .pmgrc.yaml is used.
output_file
– File to write output.
err_file
– File to write err.
write_input
(
output_dir
:
PathLike
=
'.'
,
make_dir_if_not_present
:
bool
=
True
,
cif_name
:
str
|
None
=
None
,
zip_name
:
str
|
None
=
None
,
files_to_transfer
:
dict
|
None
=
None
)
→
None
[source]

Write VASP inputs to a directory.
Parameters
:
output_dir
(
PathLike
) – Directory to write to.
Defaults to current directory (“.”).
make_dir_if_not_present
(
bool
) – Create the directory if not
present. Defaults to True.
cif_name
(
str
or
None
) – If a str, the name of the CIF file
to write the POSCAR to (the POSCAR will also be written).
zip_name
(
str
or
None
) – If a str, the name of the zip to
archive the VASP input set to.
files_to_transfer
(
dict
) –
A dictionary of
{ < input filename >: < output filepath >}.
This allows the transfer of < input filename > files from
a previous calculation to < output filepath >.
pymatgen.io.vasp.optics module

Classes for parsing and manipulating VASP optical properties calculations.
class
DielectricFunctionCalculator
(
cder_real
:
NDArray
,
cder_imag
:
NDArray
,
eigs
:
NDArray
,
kweights
:
NDArray
,
nedos
:
int
,
deltae
:
float
,
ismear
:
int
,
sigma
:
float
,
efermi
:
float
,
cshift
:
float
,
ispin
:
int
,
volume
:
float
)
[source]

Bases:
MSONable
Post-process VASP optical properties calculations.
This objects helps load the different parameters from the vasprun.xml file but allows users to override
them as needed.
The standard vasprun.xml from an
LOPTICS=.True.
calculation already contains
the complex frequency dependent dielectric functions.  However you have no way to decompose
the different contributions.  Since the
WAVEDER
file is also written during an optical calculation,
you can reconstruct the dielectric functions purely in Python and have full control over contribution
from different bands and k-points.
VASP’s linear optics follow these steps:
Calculate the imaginary part
Perform symmetry operations (this is not implemented here)
Calculate the real part
Currently, this Calculator only works for
ISYM=0
calculations since we cannot guarantee that our
externally defined symmetry operations are the same as VASP’s. This can be fixed by printing the
symmetry operators into the vasprun.xml file. If this happens in future versions of VASP,
we can dramatically speed up the calculations here by considering only the irreducible kpoints.
property
cder
[source]

Complex CDER from WAVEDER.
cder_imag
:
NDArray
[source]

cder_real
:
NDArray
[source]

cshift
:
float
[source]

deltae
:
float
[source]

efermi
:
float
[source]

eigs
:
NDArray
[source]

classmethod
from_directory
(
directory
:
PathLike
)
→
Self
[source]

Construct a DielectricFunction from a directory containing
vasprun.xml and WAVEDER files.
classmethod
from_vasp_objects
(
vrun
:
Vasprun
,
waveder
:
Waveder
)
→
Self
[source]

Construct a DielectricFunction from Vasprun, Kpoint, and Waveder.
Parameters
:
vrun
– Vasprun object
kpoint
– Kpoint object
waveder
– Waveder object
get_epsilon
(
idir
:
int
,
jdir
:
int
,
efermi
:
float
|
None
=
None
,
nedos
:
int
|
None
=
None
,
deltae
:
float
|
None
=
None
,
ismear
:
int
|
None
=
None
,
sigma
:
float
|
None
=
None
,
cshift
:
float
|
None
=
None
,
mask
:
NDArray
|
None
=
None
)
→
tuple
[
NDArray
,
NDArray
]
[source]

Compute the frequency dependent dielectric function.
Parameters
:
idir
– First direction of the dielectric tensor
jdir
– Second direction of the dielectric tensor
efermi
– Fermi energy
nedos
– Number of points in the DOS
deltae
– Energy step in the DOS
ismear
– Smearing method (only has 0:gaussian, >0:Methfessel-Paxton)
sigma
– Smearing width
cshift
– Complex shift used for Kramer-Kronig transformation
mask
– Mask for the bands/kpoint/spin index to include in the calculation
ismear
:
int
[source]

ispin
:
int
[source]

kweights
:
NDArray
[source]

nedos
:
int
[source]

plot_weighted_transition_data
(
idir
:
int
,
jdir
:
int
,
mask
:
NDArray
|
None
=
None
,
min_val
:
float
=
0.0
)
[source]

Data for plotting the weight matrix elements as a scatter plot.
Since the computation of the final spectrum (especially the smearing part)
is still fairly expensive.  This function can be used to check the values
of some portion of the spectrum (defined by the mask).
In a sense, we are looking at the imaginary part of the dielectric function
before the smearing is applied.
Parameters
:
idir
– First direction of the dielectric tensor.
jdir
– Second direction of the dielectric tensor.
mask
– Mask to apply to the CDER for the bands/kpoint/spin
index to include in the calculation
min_val
– Minimum value below this value the matrix element will not be shown.
sigma
:
float
[source]

volume
:
float
[source]

delta_func
(
x
:
NDArray
,
ismear
:
int
)
→
NDArray
[source]

Replication of VASP’s delta function.
delta_methfessel_paxton
(
x
:
NDArray
,
n
:
int
)
→
NDArray
[source]

D_n (x) = exp -x^2 * sum_i=0^n A_i H_2i(x)
where H is a Hermite polynomial and
A_i = (-1)^i / ( i! 4^i sqrt(pi) ).
epsilon_imag
(
cder
:
NDArray
,
eigs
:
NDArray
,
kweights
:
ArrayLike
,
efermi
:
float
,
nedos
:
int
,
deltae
:
float
,
ismear
:
int
,
sigma
:
float
,
idir
:
int
,
jdir
:
int
,
mask
:
NDArray
|
None
=
None
)
→
tuple
[
NDArray
,
NDArray
]
[source]

Replicate the EPSILON_IMAG function of VASP.
Parameters
:
cder
– The data written to the WAVEDER (nbands, nbands, nkpoints, nspin, diri, dirj)
eigs
– The eigenvalues (nbands, nkpoints, nspin)
kweights
– The kpoint weights (nkpoints)
efermi
– The fermi energy
nedos
– The sampling of the energy values
deltae
– The energy grid spacing
ismear
– The smearing parameter used by the
step_func
.
sigma
– The width of the smearing
idir
– The first direction of the dielectric tensor
jdir
– The second direction of the dielectric tensor
mask
– Mask for the bands/kpoint/spin index to include in the calculation
Returns
:
Array of size
nedos
with the imaginary part of the dielectric function.
Return type
:
np.ndarray
get_delta
(
x0
:
float
,
sigma
:
float
,
nx
:
int
,
dx
:
float
,
ismear
:
int
=
3
)
→
NDArray
[source]

Get the smeared delta function to be added to form the spectrum.
This replaces the
SLOT
function from VASP. Uses finite differences instead of
evaluating the delta function since the step function is more likely to have analytic form.
Parameters
:
x0
– The center of the dielectric function.
sigma
– The width of the smearing
nx
– The number of grid points in the output grid.
dx
– The gridspacing of the output grid.
ismear
– The smearing parameter used by the
step_func
.
Returns
:
Array of size
nx
with delta function on the desired outputgrid.
Return type
:
np.ndarray
get_step
(
x0
:
float
,
sigma
:
float
,
nx
:
int
,
dx
:
float
,
ismear
:
int
)
→
NDArray
[source]

Get the smeared step function to be added to form the spectrum.
This replaces the
SLOT
function from VASP.
Parameters
:
x0
– The center of the dielectric function.
sigma
– The width of the smearing
nx
– The number of grid points in the output grid.
dx
– The gridspacing of the output grid.
ismear
– The smearing parameter used by the
step_func
.
Returns
:
Array of size
nx
with step function on the desired outputgrid.
Return type
:
np.ndarray
kramers_kronig
(
eps
:
NDArray
,
nedos
:
int
,
deltae
:
float
,
cshift
:
float
=
0.1
)
→
NDArray
[source]

Perform the Kramers-Kronig transformation.
Perform the Kramers-Kronig transformation exactly as VASP does it.
The input eps should be complex and the imaginary part of the dielectric function
should be stored as the real part of the complex input array.
The output should be the complex dielectric function.
Parameters
:
eps
– The dielectric function with the imaginary part stored as the real part
and nothing in the imaginary part.
nedos
– The sampling of the energy values
deltae
– The energy grid spacing
cshift
– The shift of the imaginary part of the dielectric function.
Returns
:
Array of size
nedos
with the complex dielectric function.
Return type
:
np.ndarray
step_func
(
x
:
NDArray
,
ismear
:
int
)
→
NDArray
[source]

Replication of VASP’s step function.
step_methfessel_paxton
(
x
:
NDArray
,
n
:
int
)
→
NDArray
[source]

S_n (x) = (1 + erf x)/2 - exp -x^2 * sum_i=1^n A_i H_{2i-1}(x)
where H is a Hermite polynomial and
A_i = (-1)^i / ( i! 4^i sqrt(pi) ).
pymatgen.io.vasp.outputs module

Classes for reading/manipulating/writing VASP output files.
class
BSVasprun
(
filename
:
PathLike
,
parse_projected_eigen
:
bool
|
str
=
False
,
parse_potcar_file
:
bool
|
str
=
False
,
occu_tol
:
float
=
1e-08
,
separate_spins
:
bool
=
False
)
[source]

Bases:
Vasprun
A highly optimized version of Vasprun that parses only eigenvalues for
bandstructures. All other properties like structures, parameters,
etc. are ignored.
Parameters
:
filename
– Filename to parse
parse_projected_eigen
– Whether to parse the projected
eigenvalues. Defaults to False. Set to True to obtain projected
eigenvalues.
Note that this can take an extreme amount of time
and memory.
So use this wisely.
parse_potcar_file
– Whether to parse the potcar file to read
the potcar hashes for the potcar_spec attribute. Defaults to True,
where no hashes will be determined and the potcar_spec dictionaries
will read {“symbol”: ElSymbol, “hash”: None}. By Default, looks in
the same directory as the vasprun.xml, with same extensions as
Vasprun.xml. If a string is provided, looks at that filepath.
occu_tol
– Sets the minimum tol for the determination of the
vbm and cbm. Usually the default of 1e-8 works well enough,
but there may be pathological cases.
separate_spins
(
bool
) – Whether the band gap, CBM, and VBM should be
reported for each individual spin channel. Defaults to False,
which computes the eigenvalue band properties independent of
the spin orientation. If True, the calculation must be spin-polarized.
as_dict
(
)
→
dict
[source]

JSON-serializable dict representation.
class
BandgapProps
(
vbm
:
'float
|
None'
=
None
,
cbm
:
'float
|
None'
=
None
,
direct_gap_eigenvalues
:
'tuple[float,
float]
|
None'
=
None
,
efermi
:
'float
|
None'
=
None
,
vbm_k
:
'tuple[float,
float,
float]
|
None'
=
None
,
cbm_k
:
'tuple[float,
float,
float]
|
None'
=
None
,
direct_gap_k
:
'tuple[float,
float,
float]
|
None'
=
None
)
[source]

Bases:
MSONable
cbm
:
float
|
None
=
None
[source]

cbm_k
:
tuple
[
float
,
float
,
float
]
|
None
=
None
[source]

direct_gap_eigenvalues
:
tuple
[
float
,
float
]
|
None
=
None
[source]

direct_gap_k
:
tuple
[
float
,
float
,
float
]
|
None
=
None
[source]

efermi
:
float
|
None
=
None
[source]

vbm
:
float
|
None
=
None
[source]

vbm_k
:
tuple
[
float
,
float
,
float
]
|
None
=
None
[source]

class
Chgcar
(
poscar
:
Poscar
|
Structure
,
data
:
dict
[
str
,
NDArray
]
,
data_aug
:
dict
[
str
,
NDArray
]
|
None
=
None
)
[source]

Bases:
VolumetricData
CHGCAR file reader.
Parameters
:
poscar
(
Poscar
|
Structure
) – Object containing structure.
data
– Actual data.
data_aug
– Augmentation charge data.
classmethod
from_file
(
filename
:
str
)
→
Self
[source]

Read a CHGCAR file.
Parameters
:
filename
(
str
) – Path to CHGCAR file.
Returns
:
Chgcar
property
net_magnetization
:
float
|
None
[source]

Net magnetic moment from Chgcar.
class
Dynmat
(
filename
:
PathLike
)
[source]

Bases:
object
DYNMAT file reader.
data
[source]

A nested dict containing the DYNMAT data of the form:
[atom <int>][disp <int>][‘dispvec’] =
displacement vector (part of first line in dynmat block, e.g. “0.01 0 0”)
[atom <int>][disp <int>][‘dynmat’] =
<list> list of dynmat lines for this atom and this displacement
Type
:
dict
Authors: Patrick Huck
Parameters
:
filename
– Name of file containing DYNMAT.
get_phonon_frequencies
(
)
→
list
[
float
]
[source]

Calculate phonon frequencies.
WARNING: This method is most likely incorrect or suboptimal,
hence for demonstration purposes only.
Returns
:
phonon frequencies.
Return type
:
list[float]
property
masses
:
list
[
float
]
[source]

The list of atomic masses.
property
natoms
:
int
[source]

The number of atoms.
property
ndisps
:
int
[source]

The number of displacements.
property
nspecs
:
int
[source]

The number of species.
class
Eigenval
(
filename
:
PathLike
,
occu_tol
:
float
=
1e-08
,
separate_spins
:
bool
=
False
)
[source]

Bases:
object
EIGENVAL file reader.
filename
[source]

The input file.
Type
:
PathLike
occu_tol
[source]

Tolerance for determining occupation in band properties.
Type
:
float
ispin
[source]

Spin polarization tag.
Type
:
int
nelect
[source]

Number of electrons.
Type
:
int
nkpt
[source]

Number of kpoints.
Type
:
int
nbands
[source]

Number of bands.
Type
:
int
kpoints
[source]

List of kpoints.
Type
:
list
kpoints_weights
[source]

Weights of each kpoint in the BZ, should sum to 1.
Type
:
list
eigenvalues
[source]

Eigenvalues as a dict of {(spin): NDArray(shape=(nkpt, nbands, 2))}.
This representation is based on actual ordering in VASP and is meant as an intermediate representation
to be converted into proper objects. The kpoint index is 0-based (unlike the 1-based indexing in VASP).
Type
:
dict
Read input from filename to construct Eigenval object.
Parameters
:
filename
(
PathLike
) – filename of EIGENVAL to read.
occu_tol
(
float
) – tolerance for determining band gap.
separate_spins
(
bool
) – whether the band gap, CBM, and VBM should be
reported for each individual spin channel. Defaults to False,
which computes the eigenvalue band properties independent of
the spin orientation. If True, the calculation must be spin-polarized.
property
eigenvalue_band_properties
:
tuple
[
float
,
float
,
float
,
bool
]
|
tuple
[
tuple
[
float
,
float
]
,
tuple
[
float
,
float
]
,
tuple
[
float
,
float
]
,
tuple
[
bool
,
bool
]
]
[source]

Band properties from the eigenvalues as a tuple of
(band gap, cbm, vbm, is_band_gap_direct).
In the case of separate_spins=True,
the band gap, cbm, vbm, and is_band_gap_direct are each tuples of 2,
with index 0 representing the spin-up channel and index 1 representing
the spin-down channel.
class
Elfcar
(
poscar
:
Poscar
|
Structure
,
data
:
dict
[
str
,
NDArray
]
)
[source]

Bases:
VolumetricData
Read an ELFCAR file which contains the Electron Localization Function (ELF).
For ELF, “total” key refers to Spin.up, and “diff” refers to Spin.down.
This also contains information on the kinetic energy density.
Parameters
:
poscar
(
Poscar
or
Structure
) – Object containing structure.
data
– Actual data.
classmethod
from_file
(
filename
:
str
)
→
Self
[source]

Read a ELFCAR file.
Parameters
:
filename
– Filename
Returns
:
Elfcar
get_alpha
(
)
→
VolumetricData
[source]

Get the parameter alpha where ELF = 1/(1 + alpha^2).
class
KpointOptProps
(
tdos
:
Dos
|
None
=
None
,
idos
:
Dos
|
None
=
None
,
pdos
:
list
|
None
=
None
,
efermi
:
float
|
None
=
None
,
eigenvalues
:
dict
|
None
=
None
,
projected_eigenvalues
:
dict
|
None
=
None
,
projected_magnetisation
:
NDArray
|
None
=
None
,
kpoints
:
Kpoints
|
None
=
None
,
actual_kpoints
:
list
|
None
=
None
,
actual_kpoints_weights
:
list
|
None
=
None
,
dos_has_errors
:
bool
|
None
=
None
)
[source]

Bases:
object
Simple container class to store KPOINTS_OPT data in a separate namespace. Used by Vasprun.
actual_kpoints
:
list
|
None
=
None
[source]

actual_kpoints_weights
:
list
|
None
=
None
[source]

dos_has_errors
:
bool
|
None
=
None
[source]

efermi
:
float
|
None
=
None
[source]

eigenvalues
:
dict
|
None
=
None
[source]

idos
:
Dos
|
None
=
None
[source]

kpoints
:
Kpoints
|
None
=
None
[source]

pdos
:
list
|
None
=
None
[source]

projected_eigenvalues
:
dict
|
None
=
None
[source]

projected_magnetisation
:
NDArray
|
None
=
None
[source]

tdos
:
Dos
|
None
=
None
[source]

class
Locpot
(
poscar
:
Poscar
,
data
:
dict
[
str
,
NDArray
]
,
**
kwargs
)
[source]

Bases:
VolumetricData
LOCPOT file reader.
Parameters
:
poscar
(
Poscar
) – Poscar object containing structure.
data
(
NDArray
) – Actual data.
classmethod
from_file
(
filename
:
PathLike
,
**
kwargs
)
→
Self
[source]

Read a LOCPOT file.
Parameters
:
filename
(
PathLike
) – Path to LOCPOT file.
Returns
:
Locpot
class
Oszicar
(
filename
:
PathLike
)
[source]

Bases:
object
OSZICAR parser for VASP.
In general, while OSZICAR is useful for a quick look at the output from a VASP run,
we recommend using the Vasprun parser instead, which gives far richer information.
electronic_steps
[source]

All electronic steps. e.g.
[[{“rms”: 160.0, “E”: 4507.24605593, “dE”: 4507.2, “N”: 1, “deps”: -17777.0, “ncg”: 16576}, …], [….]
where electronic_steps[index] refers the list of electronic steps in one ionic_step,
electronic_steps[index][subindex] refers to a particular electronic step at subindex in ionic step at
index. The dict of properties depends on the type of VASP run, but in general, “E”, “dE” and “rms” should
be present in almost all runs.
Type
:
list[list[dict]]
ionic_steps
[source]

All ionic_steps, e.g.
[{“dE”: -526.36, “E0”: -526.36024, “mag”: 0.0, “F”: -526.36024}, …]
This is the typical output from VASP at the end of each ionic step. The stored dict might be different
depending on the type of VASP run.
Type
:
list[dict[str, float]]
Parameters
:
filename
(
PathLike
) – The file to parse.
property
all_energies
:
tuple
[
tuple
[
float
|
str
,
...
]
,
...
]
[source]

Compilation of all energies from all electronic steps and ionic steps
as a tuple of list of energies, e.g.
((4507.24605593, 143.824705755, -512.073149912, …), …).
as_dict
(
)
→
dict
[
str
,
list
]
[source]

MSONable dict.
property
final_energy
[source]

class
Outcar
(
filename
:
PathLike
)
[source]

Bases:
object
Parser for data in OUTCAR that is not available in vasprun.xml.
Note, this class works a bit differently than most of the other
VASP parsers, since OUTCAR can be very different depending on which
“type of run” performed.
Creating an Outcar instance with a filename reads “regular parameters” that
are always present. One can then call a specific reader method depending on the
type of run being performed, including (see the docstring of corresponding
method for more details):
read_avg_core_poten
read_chemical_shielding
read_core_state_eigen
read_corrections
read_cs_core_contribution
read_cs_g0_contribution
read_cs_raw_symmetrized_tensors
read_elastic_tensor
read_electrostatic_potential
read_fermi_contact_shift
read_freq_dielectric
read_igpar
read_internal_strain_tensor
read_lcalcpol
read_lepsilon
read_lepsilon_ionic
read_neb
read_nmr_efg
read_nmr_efg_tensor
read_onsite_density_matrices
read_piezo_tensor
read_pseudo_zval
read_table_pattern
magnetization
[source]

Magnetization on each ion, e.g.
({“d”: 0.0, “p”: 0.003, “s”: 0.002, “tot”: 0.005}, … ).
Type
:
tuple[dict[str, float]]
chemical_shielding
[source]

Chemical shielding on each ion with core and valence contributions.
Type
:
dict
unsym_cs_tensor
[source]

Unsymmetrized chemical shielding tensor matrixes on each ion.
e.g. [[[sigma11, sigma12, sigma13], [sigma21, sigma22, sigma23], [sigma31, sigma32, sigma33]], …]
Type
:
list
cs_g0_contribution
[source]

G=0 contribution to chemical shielding. 2D rank 3 matrix.
Type
:
NDArray
cs_core_contribution
[source]

Core contribution to chemical shielding. e.g.
{‘Mg’: -412.8, ‘C’: -200.5, ‘O’: -271.1}
Type
:
dict[str, float]
efg
[source]

Electric Field Gradient (EFG) tensor on each ion, e.g.
({“cq”: 0.1, “eta”, 0.2, “nuclear_quadrupole_moment”: 0.3}, {“cq”: 0.7, “eta”, 0.8,
“nuclear_quadrupole_moment”: 0.9}, …)
Type
:
tuple[dict[str, float]]
charge
[source]

Charge on each ion, e.g.
({“p”: 0.154, “s”: 0.078, “d”: 0.0, “tot”: 0.232}, …)
Type
:
tuple[dict[str, float]]
is_stopped
[source]

True if OUTCAR is from a stopped run (using STOPCAR, see VASP Manual).
Type
:
bool
run_stats
[source]

Various useful run stats including “System time (sec)”,
“Total CPU time used (sec)”, “Elapsed time (sec)”, “Maximum memory used (kb)”,
“Average memory used (kb)”, “User time (sec)”, “cores”.
Type
:
dict[str, float | None]
elastic_tensor
[source]

Total elastic moduli (Kbar) is given in a 6x6 array matrix.
Type
:
NDArray
drift
[source]

Total drift for each step in eV/Atom.
Type
:
NDArray
ngf
[source]

Dimensions for the Augmentation grid.
Type
:
tuple
sampling_radii
[source]

Size of the sampling radii in VASP for the test charges for the electrostatic
potential at each atom. Total array size is the number of elements present in the calculation.
Type
:
NDArray
electrostatic_potential
[source]

Average electrostatic potential at each atomic position in order of
the atoms in POSCAR.
Type
:
NDArray
final_energy_contribs
[source]

Individual contributions to the total final energy.
Include contributions from keys, e.g.:
{‘DENC’: -505778.5184347, ‘EATOM’: 15561.06492564, ‘EBANDS’: -804.53201231, ‘EENTRO’: -0.08932659,
‘EXHF’: 0.0, ‘Ediel_sol’: 0.0, ‘PAW double counting’: 664.6726974100002, ‘PSCENC’: 742.48691646,
‘TEWEN’: 489742.86847338, ‘XCENC’: -169.64189814}
Type
:
dict[str, float]
efermi
[source]

Fermi energy.
Type
:
float
filename
[source]

Filename.
Type
:
PathLike
final_energy
[source]

Final energy after extrapolation of sigma back to 0, i.e. energy(sigma->0).
Type
:
float
final_energy_wo_entrp
[source]

Final energy before extrapolation of sigma, i.e. energy without entropy.
Type
:
float
final_fr_energy
[source]

Final “free energy”, i.e. free energy TOTEN.
Type
:
float
has_onsite_density_matrices
[source]

Whether onsite density matrices have been set.
Type
:
bool
lcalcpol
[source]

If LCALCPOL has been set.
Type
:
bool
lepsilon
[source]

If LEPSILON has been set.
Type
:
bool
nelect
[source]

The number of electrons in the calculation.
Type
:
float
spin
[source]

If spin-polarization is enabled via ISPIN.
Type
:
bool
total_mag
[source]

Total magnetization (in terms of the number of unpaired electrons).
Type
:
float
Authors: Rickard Armiento, Shyue Ping Ong
Parameters
:
filename
(
PathLike
) – OUTCAR file to parse.
as_dict
(
)
→
dict
[
str
,
Any
]
[source]

MSONable dict.
read_avg_core_poten
(
)
→
list
[
list
[
float
]
]
[source]

Read the core potential at each ionic step.
Returns
:
The average core potentials for each atom of each ionic
step as: [[avg_core_pot, ], ].
Return type
:
list[list[float]]
Example
The average core potential of the 2nd atom of the structure at the
last ionic step is: [-1][1].
read_chemical_shielding
(
)
→
None
[source]

Parse the NMR chemical shieldings data. Only the second part “absolute, valence and core”
will be parsed. And only the three right most field (ISO_SHIELDING, SPAN, SKEW) will be retrieved.
Renders accessible from self.data:
chemical_shielding (dict[Literal[“valence_only”, “valence_and_core”], list[list[float]]]):
Chemical shieldings in the order of atoms from the OUTCAR. Maryland notation is adopted.
read_core_state_eigen
(
)
→
list
[
dict
[
str
,
list
[
float
]
]
]
[source]

Read the core state eigenenergies at each ionic step.
Returns
:
The atom such as [{“AO”: [core_state_eig, ]}, ].
The core state eigenenergie list for each AO is over all ionic step.
Return type
:
list[dict[str, list[float]]]
Example
The core state eigenenergie of the 2s AO of the 6th atom of the
structure at the last ionic step is [5][“2s”][-1].
read_corrections
(
reverse
:
bool
=
True
,
terminate_on_match
:
bool
=
True
)
→
None
[source]

Read the dipol qudropol correction.
Parameters
:
reverse
(
bool
) – Whether to start from end of OUTCAR. Defaults to True.
terminate_on_match
(
bool
) – Whether to terminate once match is found. Defaults to True.
Renders accessible from self.data:
dipol_quadrupol_correction (float): Dipol qudropol correction.
read_cs_core_contribution
(
)
→
None
[source]

Parse the core contribution of NMR chemical shielding.
Renders accessible from self.data:
cs_core_contribution (dict[str, float]): Core contribution from each element.
read_cs_g0_contribution
(
)
→
None
[source]

Parse the G0 contribution of NMR chemical shielding.
Renders accessible from self.data:
cs_g0_contribution (list[list[float]]): G0 contribution matrix.
read_cs_raw_symmetrized_tensors
(
)
→
None
[source]

Parse the matrix form of NMR tensor before corrected to table.
Renders accessible from self.data:
unsym_cs_tensor (list[list[list[float]]]): Unsymmetrized tensors in the order of atoms.
read_elastic_tensor
(
)
→
None
[source]

Parse the elastic tensor data.
Renders accessible from self.data:
elastic_tensor[list[list[float]]]: 6x6 array corresponding to the elastic tensor.
read_electrostatic_potential
(
)
→
None
[source]

Parse the eletrostatic potential for the last ionic step.
Renders accessible as attributes:
ngf (list[int, int, int]): Number of grid points along x, y, z dimensions.
sampling_radii (list[float, float, float]): Test charge radii.
electrostatic_potential (list[float]): The eletrostatic potential.
read_fermi_contact_shift
(
)
→
None
[source]

Read Fermi contact (isotropic) hyperfine coupling parameter.
Output example:
1      -0.002    -0.002    -0.051     0.000    -0.052
2      -0.002    -0.002    -0.051     0.000    -0.052
3       0.056     0.056     0.321    -0.048     0.321
————————————————————-
which corresponds to:
[[-0.002, -0.002, -0.051, 0.0, -0.052],
[-0.002, -0.002, -0.051, 0.0, -0.052],
[0.056, 0.056, 0.321, -0.048, 0.321]] from ‘fch’ data.
Renders accessible from self.data:
fermi_contact_shift (dict[Literal[“fch”, “dh”, “th”], list[list[float]]]):
Fermi contact (isotropic) hyperfine coupling parameter.
read_freq_dielectric
(
)
→
None
[source]

Parse the frequency dependent dielectric function (obtained with LOPTICS).
Renders accessible as attributes:
plasma_frequencies (dict[Literal[“intraband”, “interband”], NDArray[float64]]):
plasma frequency in eV.
dielectric_energies (NDArray[float64]): Dielectric energies.
dielectric_tensor_function (NDArray[complex128]): Dielectric tensor function.
read_igpar
(
)
→
None
[source]

Read IGPAR.
See VASP sections “LBERRY, IGPAR, NPPSTR, DIPOL” for info on
what these are.
Renders accessible as attributes:
er_ev (dict[Spin, NDArray[float]]): e<r>_ev.
er_bp (dict[Spin, NDArray[float]]): e<r>_bp.
er_ev_tot (NDArray[float]): spin up + spin down summed.
er_bp_tot (NDArray[float]): spin up + spin down summed.
p_elec (int): spin up + spin down summed.
p_ion (int): spin up + spin down summed.
read_internal_strain_tensor
(
)
→
None
[source]

Read the internal strain tensor.
Renders accessible as attributes:
internal_strain_tensor (list[NDArray[float64]]): Voigt notation tensors for each site.
read_lcalcpol
(
)
→
None
[source]

Read the LCALCPOL.
Renders accessible as attributes:
p_elec (NDArray[float64]): Total electronic dipole moment.
p_ion (NDArray[float64]): Ionic dipole moment.
p_sp1 (NDArray[float] | None): Spin up.
p_sp2 (NDArray[float] | None): Spin down.
read_lepsilon
(
)
→
None
[source]

Read a LEPSILON run.
Renders accessible as attributes:
dielectric_tensor (list[list[float]]): Dielectric tensor.
piezo_tensor (list[list[float]]): The piezo tensor.
read_lepsilon_ionic
(
)
→
None
[source]

Read the ionic component of a LEPSILON run.
Renders accessible as attributes:
dielectric_ionic_tensor (list[list[float]]): Ionic dielectric tensor.
piezo_ionic_tensor (list[list[float]]): Ionic piezoelectric tensor.
read_neb
(
reverse
:
bool
=
True
,
terminate_on_match
:
bool
=
True
)
→
None
[source]

Read NEB data. This only works with OUTCARs from both normal
VASP NEB calculations or from the CI NEB method implemented by
Henkelman et al.
Parameters
:
reverse
(
bool
) – Read files in reverse. Defaults to false. Useful for
large files, especially when used with terminate_on_match.
Defaults to True here since we usually want only the final value.
terminate_on_match
(
bool
) – Whether to terminate when there is at
least one match in each key in pattern. Defaults to True here
since we usually want only the final value.
Renders accessible from self.data:
energy (float): Final energy.
tangent_force (float): Final tangent force.
read_nmr_efg
(
)
→
None
[source]

Parse the NMR Electric Field Gradient interpreted values.
Renders accessible from self.data:
efg (list[dict[Literal[“cq”, “eta”, “nuclear_quadrupole_moment”], float]]):
Electric Field Gradient tensors in the order of atoms.
Each dict key/value pair corresponds to a component of the tensors.
read_nmr_efg_tensor
(
)
→
list
[
NDArray
[
np.float64
]
]
[source]

Parses the NMR Electric Field Gradient Raw Tensors.
Returns
:
Electric Field Gradient Tensors in the order of atoms.
Return type
:
list[NDArray[float64]]
Renders accessible from self.data:
unsym_efg_tensor (list[NDArray[float64]]): Electric Field Gradient
Tensors in the order of atoms.
read_onsite_density_matrices
(
)
→
None
[source]

Parse the onsite density matrices.
Renders accessible from self.data:
onsite_density_matrices (list[dict[Spin, list[list[float]]]]):
Onsite density matrices with index corresponding to atom index in Structure.
read_pattern
(
patterns:
dict[str,
str],
reverse:
bool
=
False,
terminate_on_match:
bool
=
False,
postprocess:
Callable
=
<class
'str'>
)
→
None
[source]

General pattern reading. Use monty’s regrep method and take the same
arguments.
Parameters
:
patterns
(
dict
[
str
,
str
]
) – Patterns, e.g.
{“energy”: r”energy\(sigma->0\)\s+=\s+([\d\-.]+)”}.
reverse
(
bool
) – Read files in reverse. Defaults to false. Useful for
large files like OUTCARs, especially when used with
terminate_on_match.
terminate_on_match
(
bool
) – Whether to terminate when there is at
least one match for each key in patterns.
postprocess
(
Callable
) – A post processing function to convert all
matches. Defaults to str, i.e., no change.
Renders accessible from self.data:
Any attribute in patterns. For example,
{“energy”: r”energy\(sigma->0\)\s+=\s+([\d\-.]+)”} will set the
value of self.data[“energy”] = [[-1234], [-3453], …], to the
results from regex and postprocess. Note that the values
are list[list], because you can grep multiple items on one line.
read_piezo_tensor
(
)
→
None
[source]

Parse the piezo tensor data.
Renders accessible from self.data:
piezo_tensor (list[list[float]]): The piezo tensor.
read_pseudo_zval
(
)
→
None
[source]

Create a pseudopotential valence electron number (ZVAL) dictionary.
Renders accessible as attributes:
zval_dict (dict[str, float]): ZVAL for each element.
read_table_pattern
(
header_pattern:
str
,
row_pattern:
str
,
footer_pattern:
str
,
postprocess:
Callable
=
<class
'str'>
,
attribute_name:
str
|
None
=
None
,
last_one_only:
bool
=
True
,
first_one_only:
bool
=
False
)
→
list
[source]

Parse table-like data. A table composes of three parts: header,
main body, footer. All the data matches “row pattern” in the main body
will be returned.
Parameters
:
header_pattern
(
str
) – The regular expression pattern matches the
table header. This pattern should match all the text
immediately before the main body of the table. For multiple
sections table match the text until the section of
interest. MULTILINE and DOTALL options are enforced, as a
result, the “.” meta-character will also match “n” in this
section.
row_pattern
(
str
) – The regular expression matches a single line in
the table. Capture interested field using regular expression
groups.
footer_pattern
(
str
) – The regular expression matches the end of the
table. E.g. a long dash line.
postprocess
(
Callable
) – A post processing function to convert all
matches. Defaults to str, i.e., no change.
attribute_name
(
str
) – Name of this table. If present the parsed data
will be attached to “data. e.g. self.data[“efg”] = […]
last_one_only
(
bool
) – All the tables will be parsed, if this option
is set to True, only the last table will be returned. The
enclosing list will be removed. i.e. Only a single table will
be returned. Default to be True. Incompatible with first_one_only.
first_one_only
(
bool
) – Only the first occurrence of the table will be
parsed and the parsing procedure will stop. The enclosing list
will be removed. i.e. Only a single table will be returned.
Incompatible with last_one_only.
Returns
:
List of tables or a single table if last_one_only/first_one_only is True.
1) A table is a list of rows. 2) A row is either a list of attribute
values in case the capturing group is defined without name in row_pattern,
or a dict in case that named capturing groups are defined by row_pattern.
class
Procar
(
filename
:
PathLike
|
list
[
PathLike
]
)
[source]

Bases:
MSONable
PROCAR file reader.
Updated to use code from easyunfold (
https://smtg-bham.github.io/easyunfold
; band-structure
unfolding package) to allow SOC PROCAR parsing, and parsing multiple PROCAR files together.
easyunfold’s PROCAR parser can be used if finer control over projections (k-point weighting,
normalisation per band, quick orbital sub-selection etc) is needed.
data
[source]

The PROCAR data of the form below. It should VASP uses 1-based indexing,
but all indices are converted to 0-based here.
{spin: np.array accessed with (k-point index, band index, ion index, orbital index)}
Type
:
dict
weights
[source]

The weights associated with each k-point as an array of length nkpoints.
Type
:
NDArray
phase_factors
[source]

Phase factors, where present (e.g. LORBIT = 12). A dict of the form:
{spin: complex np.array accessed with (k-point index, band index, ion index, orbital index)}
Type
:
dict
nbands
[source]

Number of bands.
Type
:
int
nkpoints
[source]

Number of k-points.
Type
:
int
nions
[source]

Number of ions.
Type
:
int
nspins
[source]

Number of spins.
Type
:
int
is_soc
[source]

Whether the PROCAR contains spin-orbit coupling (LSORBIT = True) data.
Type
:
bool
kpoints
[source]

The k-points as an np.array of shape (nkpoints, 3).
Type
:
NDArray
occupancies
[source]

The occupancies of the bands as a dict of the form:
{spin: np.array accessed with (k-point index, band index)}
Type
:
dict
eigenvalues
[source]

The eigenvalues of the bands as a dict of the form:
{spin: np.array accessed with (k-point index, band index)}
Type
:
dict
xyz_data
[source]

The PROCAR projections data along the x,y and z magnetisation projection
directions, with is_soc = True (see VASP wiki for more info).
{‘x’/’y’/’z’: np.array accessed with (k-point index, band index, ion index, orbital index)}
Type
:
dict
Parameters
:
filename
– The path to PROCAR(.gz) file to read, or list of paths.
get_occupation
(
atom_index
:
int
,
orbital
:
str
)
→
dict
[source]

Get the occupation for a particular orbital of a particular atom.
Parameters
:
atom_num
(
int
) – Index of atom in the PROCAR. It should be noted
that VASP uses 1-based indexing for atoms, but this is
converted to 0-based indexing in this parser to be
consistent with representation of structures in pymatgen.
orbital
(
str
) – An orbital. If it is a single character, e.g. s,
p, d or f, the sum of all s-type, p-type, d-type or f-type
orbitals occupations are returned respectively. If it is a
specific orbital, e.g. px, dxy, etc., only the occupation
of that orbital is returned.
Returns
:
Sum occupation of orbital of atom.
Return type
:
dict
get_projection_on_elements
(
structure
:
Structure
)
→
dict
[
Spin
,
list
[
list
[
dict
[
str
,
float
]
]
]
]
[source]

Get a dict of projections on elements.
Parameters
:
structure
(
Structure
) – Input structure.
Returns
:
[band index][kpoint index][{Element: values}]].
Return type
:
A dict as {Spin
read
(
filenames
:
list
[
PathLike
]
)
[source]

Read in PROCAR projections data, possibly from multiple files.
Parameters
:
filenames
– List of PROCAR files to read.
exception
UnconvergedVASPWarning
[source]

Bases:
Warning
Warning for unconverged VASP run.
exception
VaspParseError
[source]

Bases:
ParseError
Exception class for VASP parsing.
Vaspout
(
filename
:
str
|
Path
,
occu_tol
:
float
=
1e-08
,
parse_dos
:
bool
=
True
,
parse_eigen
:
bool
=
True
,
parse_projected_eigen
:
bool
=
False
,
separate_spins
:
bool
=
False
,
store_potcar
:
bool
=
True
)
→
None
[source]

Class to read vaspout.h5 files.
This class inherits from Vasprun, as the vaspout.h5 file is intended
to be a forward-looking replacement for vasprun.xml.
Thus to later accommodate a smooth transition to vaspout.h5, this class
uses the same structure as Vasprun but overrides many of its methods.
Parameters
:
filename
(
str
or
Path
) – The name of the vaspout.h5 file to parse, can be compressed.
occu_tol
(
float = 1e-8
) – Sets the minimum tol for the determination of the
vbm and cbm. Usually the default of 1e-8 works well enough,
but there may be pathological cases.
parse_dos
(
bool = True
) – Whether to parse the dos. Defaults to True. Set
to False to shave off significant time from the parsing if you
are not interested in getting those data.
parse_eigen
(
bool = True
) – Whether to parse the eigenvalues. Defaults to
True. Set to False to shave off significant time from the
parsing if you are not interested in getting those data.
parse_projected_eigen
(
bool = False
) – Whether to parse the projected
eigenvalues and magnetization. Defaults to False. Set to True to obtain
projected eigenvalues and magnetization.
Note that this can take an
extreme amount of time and memory.
So use this wisely.
separate_spins
(
bool
) – Whether the band gap, CBM, and VBM should be
reported for each individual spin channel. Defaults to False,
which computes the eigenvalue band properties independent of
the spin orientation. If True, the calculation must be spin-polarized.
store_potcar
(
bool
) – Whether to store the full POTCAR data.
class
Vasprun
(
filename
:
PathLike
,
ionic_step_skip
:
int
|
None
=
None
,
ionic_step_offset
:
int
=
0
,
parse_dos
:
bool
=
True
,
parse_eigen
:
bool
=
True
,
parse_projected_eigen
:
bool
=
False
,
parse_potcar_file
:
PathLike
|
bool
=
True
,
occu_tol
:
float
=
1e-08
,
separate_spins
:
bool
=
False
,
exception_on_bad_xml
:
bool
=
True
)
[source]

Bases:
MSONable
Vastly improved cElementTree-based parser for vasprun.xml files. Uses
iterparse to support incremental parsing of large files.
Speedup over Dom is at least 2x for smallish files (~1 Mb) to orders of
magnitude for larger files (~10 Mb).
VASP results
ionic_steps
[source]

All ionic steps in the run as a list of {“structure”: structure at end of run,
“electronic_steps”: {All electronic step data in vasprun file}, “stresses”: stress matrix}.
Type
:
list
tdos
[source]

Total dos calculated at the end of run. Note that this is rounded to 4 decimal
places by VASP.
Type
:
Dos
idos
[source]

Integrated dos calculated at the end of run. Rounded to 4 decimal places by VASP.
Type
:
Dos
pdos
[source]

List of list of PDos objects. Access as pdos[atomindex][orbitalindex].
Type
:
list
efermi
[source]

Fermi energy.
Type
:
float
eigenvalues
[source]

Final eigenvalues as a dict of {(spin, kpoint index):[[eigenvalue, occu]]}.
The kpoint index is 0-based (unlike the 1-based indexing in VASP).
Type
:
dict
projected_eigenvalues
[source]

Final projected eigenvalues as a dict of {spin: nd-array}.
To access a particular value, you need to do
Vasprun.projected_eigenvalues[spin][kpoint index][band index][atom index][orbital_index].
The kpoint, band and atom indices are 0-based (unlike the 1-based indexing in VASP).
Type
:
dict
projected_magnetisation
[source]

Final projected magnetization as a numpy array with the
shape (nkpoints, nbands, natoms, norbitals, 3). Where the last axis is the contribution in the
3 Cartesian directions. This attribute is only set if spin-orbit coupling (LSORBIT = True) or
non-collinear magnetism (LNONCOLLINEAR = True) is turned on in the INCAR.
Type
:
NDArray
dielectric_data
[source]

Dictionary, with the tag comment as key, containing other variants of
the real and imaginary part of the dielectric constant (e.g., computed by RPA) in function of
the energy (frequency). Optical properties (e.g. absorption coefficient) can be obtained through this.
The data is given as a tuple of 3 values containing each of them the energy, the real part tensor,
and the imaginary part tensor ([energies],[[real_partxx,real_partyy,real_partzz,real_partxy,
real_partyz,real_partxz]],[[imag_partxx,imag_partyy,imag_partzz,imag_partxy, imag_partyz, imag_partxz]]).
The data can be the current, density or freq_dependent (BSE) dielectric data.
Type
:
dict
nionic_steps
[source]

The total number of ionic steps. This number is always equal to the total number
of steps in the actual run even if ionic_step_skip is used.
Type
:
int
force_constants
[source]

Force constants computed in phonon DFPT run(IBRION = 8).
The data is a 4D array of shape (natoms, natoms, 3, 3).
Type
:
NDArray
normalmode_eigenvals
[source]

Normal mode frequencies. 1D array of size 3*natoms.
Type
:
NDArray
normalmode_eigenvecs
[source]

Normal mode eigen vectors. 3D array of shape (3*natoms, natoms, 3).
Type
:
NDArray
md_data
[source]

Available only for ML MD runs, i.e., INCAR with ML_LMLFF = .TRUE. md_data is a list of
dict with the following format: [{‘energy’: {‘e_0_energy’: -525.07195568, ‘e_fr_energy’: -525.07195568,
‘e_wo_entrp’: -525.07195568, ‘kinetic’: 3.17809233, ‘lattice kinetic’: 0.0, ‘nosekinetic’: 1.323e-5,
‘nosepot’: 0.0, ‘total’: -521.89385012}, ‘forces’: [[0.17677989, 0.48309874, 1.85806696], …],
‘structure’: Structure object}].
Type
:
list
incar
[source]

Incar object for parameters specified in INCAR file.
Type
:
Incar
parameters
[source]

Incar object with parameters that VASP actually used, including all defaults.
Type
:
Incar
kpoints
[source]

Kpoints object for KPOINTS specified in run.
Type
:
Kpoints
actual_kpoints
[source]

List of actual kpoints, e.g. [[0.25, 0.125, 0.08333333], [-0.25, 0.125, 0.08333333],
[0.25, 0.375, 0.08333333], ….].
Type
:
list
actual_kpoints_weights
[source]

List of kpoint weights, e.g. [0.04166667, 0.04166667, 0.04166667, 0.04166667,
0.04166667, ….].
Type
:
list
atomic_symbols
[source]

List of atomic symbols, e.g. [“Li”, “Fe”, “Fe”, “P”, “P”, “P”].
Type
:
list
potcar_symbols
[source]

List of POTCAR symbols. e.g. [“PAW_PBE Li 17Jan2003”, “PAW_PBE Fe 06Sep2000”, ..].
Type
:
list
kpoints_opt_props
[source]

Object whose attributes are the data from KPOINTS_OPT (if present,
else None). Attributes of the same name have the same format and meaning as Vasprun (or they are
None if absent). Attributes are: tdos, idos, pdos, efermi, eigenvalues, projected_eigenvalues,
projected magnetisation, kpoints, actual_kpoints, actual_kpoints_weights, dos_has_errors.
Type
:
object
Author: Shyue Ping Ong
Parameters
:
filename
(
str
) – Filename to parse
ionic_step_skip
(
int
) – If ionic_step_skip is a number > 1,
only every ionic_step_skip ionic steps will be read for
structure and energies. This is very useful if you are parsing
very large vasprun.xml files and you are not interested in every
single ionic step. Note that the final energies may not be the
actual final energy in the vasprun.
ionic_step_offset
(
int
) – Used together with ionic_step_skip. If set,
the first ionic step read will be offset by the amount of
ionic_step_offset. For example, if you want to start reading
every 10th structure but only from the 3rd structure onwards,
set ionic_step_skip to 10 and ionic_step_offset to 3. Main use
case is when doing statistical structure analysis with
extremely long time scale multiple VASP calculations of
varying numbers of steps.
parse_dos
(
bool
) – Whether to parse the dos. Defaults to True. Set
to False to shave off significant time from the parsing if you
are not interested in getting those data.
Note that the DOS output from VASP is rounded to 4 decimal places,
which can give some slight inaccuracies.
parse_eigen
(
bool
) – Whether to parse the eigenvalues. Defaults to
True. Set to False to shave off significant time from the
parsing if you are not interested in getting those data.
parse_projected_eigen
(
bool
) – Whether to parse the projected
eigenvalues and magnetization. Defaults to False. Set to True to obtain
projected eigenvalues and magnetization.
Note that this can take an
extreme amount of time and memory.
So use this wisely.
parse_potcar_file
(
bool
|
PathLike
) – Whether to parse the potcar file to read
the potcar hashes for the potcar_spec attribute. Defaults to True,
where no hashes will be determined and the potcar_spec dictionaries
will read {“symbol”: ElSymbol, “hash”: None}. By Default, looks in
the same directory as the vasprun.xml, with same extensions as
Vasprun.xml. If a path is provided, look at that path.
occu_tol
(
float
) – Sets the minimum tol for the determination of the
vbm and cbm. Usually the default of 1e-8 works well enough,
but there may be pathological cases.
separate_spins
(
bool
) – Whether the band gap, CBM, and VBM should be
reported for each individual spin channel. Defaults to False,
which computes the eigenvalue band properties independent of
the spin orientation. If True, the calculation must be spin-polarized.
exception_on_bad_xml
(
bool
) – Whether to throw a ParseException if a
malformed XML is detected. Default to True, which ensures only
proper vasprun.xml are parsed. You can set to False if you want
partial results (e.g., if you are monitoring a calculation during a
run), but use the results with care. A warning is issued.
as_dict
(
)
→
dict
[source]

JSON-serializable dict representation.
calculate_efermi
(
tol
:
float
=
0.001
)
→
float
[source]

Calculate the Fermi level using a robust algorithm.
Sometimes VASP can set the Fermi level inside a band
due to issues in the way band occupancies are handled.
This method tries to detect and correct this.
More details:
https://www.vasp.at/forum/viewtopic.php?f=4&t=17981
.
property
complete_dos
:
CompleteDos
[source]

A CompleteDos object which incorporates the total DOS and all projected DOS.
property
complete_dos_normalized
:
CompleteDos
[source]

A CompleteDos object which incorporates the total DOS and all projected DOS.
Normalized by the volume of the unit cell with units of states/eV/unit cell
volume.
property
converged
:
bool
[source]

Whether a relaxation run has both ionically and
electronically converged.
property
converged_electronic
:
bool
[source]

Whether electronic step converged in the final ionic step.
property
converged_ionic
:
bool
[source]

Whether ionic step convergence has been reached, i.e. VASP
exited before reaching the max ionic steps for a relaxation run.
In case IBRION=0 (MD) or EDIFFG=0, returns True if the max ionic
steps are reached.
property
dielectric
:
tuple
[
list
,
list
,
list
]
[source]

The real and imaginary part of the dielectric constant (e.g.,
computed by RPA) in function of the energy (frequency).
Optical properties (e.g. absorption coefficient) can be obtained through this.
Returns
:
The data is given as a tuple of 3 for the energy, the real part
tensor, and the imaginary part tensor:
([energies], [[real_partxx, real_partyy, real_partzz, real_partxy,
real_partyz, real_partxz]], [[imag_partxx, imag_partyy, imag_partzz,
imag_partxy, imag_partyz, imag_partxz]]).
property
eigenvalue_band_properties
:
tuple
[
float
,
float
,
float
,
bool
]
|
tuple
[
tuple
[
float
,
float
]
,
tuple
[
float
,
float
]
,
tuple
[
float
,
float
]
,
tuple
[
bool
,
bool
]
]
[source]

Band properties from the eigenvalues as a tuple,
(band gap, cbm, vbm, is_band_gap_direct).
In the case of separate_spins=True, the band gap, cbm, vbm, and is_band_gap_direct are each
lists of length 2, with index 0 representing the spin-up channel and index 1 representing the
spin-down channel.
property
epsilon_ionic
:
list
[
float
]
[source]

The ionic part of the static dielectric constant.
Present when it’s a DFPT run (LEPSILON=TRUE) and IBRION=5, 6, 7 or 8.
property
epsilonassets
:
list
[
float
]
[source]

The static part of the dielectric constant.
Present only when it’s a DFPT run (LEPSILON=TRUE).
property
epsilonassets_wolfe
:
list
[
float
]
[source]

The static part of the dielectric constant without any local
field effects. Present only when it’s a DFPT run (LEPSILON=TRUE).
property
final_energy
[source]

get_band_structure
(
kpoints_filename
:
str
|
None
=
None
,
efermi
:
float
|
Literal
[
'smart'
]
|
None
=
None
,
line_mode
:
bool
=
False
,
force_hybrid_mode
:
bool
=
False
,
ignore_kpoints_opt
:
bool
=
False
)
→
BandStructureSymmLine
|
BandStructure
[source]

Get the band structure.
Parameters
:
kpoints_filename
– Full path of the KPOINTS file from which
the band structure is generated.
If None is provided, the code will try to intelligently
determine the appropriate KPOINTS file by substituting the
filename of the vasprun.xml with KPOINTS (or KPOINTS_OPT).
The latter is the default behavior.
efermi
– The Fermi energy associated with the bandstructure, in eV. By
default (None), uses the value reported by VASP in vasprun.xml. To
manually set the Fermi energy, pass a float. Pass ‘smart’ to use the
calculate_efermi()
method, which calculates the Fermi level by first
checking whether it lies within a small tolerance (by default 0.001 eV)
of a band edge) If it does, the Fermi level is placed in the center of
the bandgap. Otherwise, the value is identical to the value reported by
VASP.
line_mode
– Force the band structure to be considered as
a run along symmetry lines. (Default: False)
force_hybrid_mode
– Makes it possible to read in self-consistent band
structure calculations for every type of functional. (Default: False)
ignore_kpoints_opt
– Normally, if KPOINTS_OPT data exists, it has
the band structure data. Set this flag to ignore it. (Default: False)
Returns
:
BandStructure (or more specifically a BandStructureSymmLine object if the run
is detected to be a run along symmetry lines)
Two types of runs along symmetry lines are accepted: non-sc with
Line-Mode in the KPOINT file or hybrid, self-consistent with a
uniform grid+a few kpoints along symmetry lines (explicit KPOINTS
file) (it’s not possible to run a non-sc band structure with hybrid
functionals). The explicit KPOINTS file needs to have data on the
kpoint label as commentary.
If VASP was run with KPOINTS_OPT, it reads the data from that
file unless told otherwise. This overrides hybrid mode.
get_computed_entry
(
inc_structure
:
bool
=
True
,
parameters
:
list
[
str
]
|
None
=
None
,
data
:
dict
|
None
=
None
,
entry_id
:
str
|
None
=
None
)
→
ComputedStructureEntry
|
ComputedEntry
[source]

Get a ComputedEntry or ComputedStructureEntry from the Vasprun.
Parameters
:
inc_structure
(
bool
) – Whether to return ComputedStructureEntries
instead of ComputedEntries.
parameters
(
list
) – Input parameters to include. It has to be one of
the properties supported by the Vasprun object. If is None,
a default set of parameters that are
necessary for typical post-processing will be set.
data
(
dict
) – Output data to include. Have to be the properties
supported by the Vasprun object.
entry_id
(
str
) – An entry id for the ComputedEntry.
Defaults to “vasprun-{current datetime}”
Returns
:
ComputedStructureEntry/ComputedEntry
get_potcars
(
path
:
PathLike
|
bool
)
→
Potcar
|
None
[source]

Get the POTCAR from the specified path.
Parameters
:
path
(
PathLike
|
bool
) – If a str or Path, the path to search for POTCARs.
If a bool, whether to take the search path from the specified vasprun.xml
Returns
:
The POTCAR from the specified path or None if not found/no path specified.
Return type
:
Potcar
| None
get_trajectory
(
)
→
Trajectory
[source]

Get a Trajectory, an alternative representation of self.structures
as a single object. Forces are added as site properties.
Returns
:
Trajectory
property
hubbards
:
dict
[
str
,
float
]
[source]

Hubbard U values used for a GGA+U run, otherwise an empty dict.
property
is_hubbard
:
bool
[source]

Whether is a DFT+U run.
property
is_spin
:
bool
[source]

Whether is spin-polarized.
property
md_n_steps
:
int
[source]

Number of steps for MD runs.
Count all the actual MD steps if ML enabled.
property
optical_absorption_coeff
:
list
[
float
]
|
None
[source]

The optical absorption coefficient from the dielectric constants.
Note that this method is only implemented for optical properties
calculated with GGA and BSE.
property
run_type
:
str
[source]

The run type. Currently detects GGA, metaGGA, HF, HSE, B3LYP,
and hybrid functionals based on relevant INCAR tags. LDA is assigned if
PAW POTCARs are used and no other functional is detected.
Hubbard U terms and vdW corrections are detected automatically as well.
property
structures
:
list
[
Structure
]
[source]

List of Structures for each ionic step.
update_charge_from_potcar
(
path
:
PathLike
|
bool
)
→
None
[source]

Update the charge of a structure based on the POTCARs found.
Parameters
:
path
(
PathLike
|
bool
) – Path to search for POTCARs.
update_potcar_spec
(
path
:
PathLike
|
bool
)
→
None
[source]

Update the specs based on the POTCARs found.
Parameters
:
path
(
PathLike
|
bool
) – Path to search for POTCARs.
Note that the vasprun.xml spec typically hasn’t included the POTCAR symbols,
since these are derived from the TITEL.
class
VolumetricData
(
structure
:
Structure
|
IStructure
,
data
:
dict
[
str
,
np.ndarray
]
,
distance_matrix
:
dict
|
None
=
None
,
data_aug
:
dict
[
str
,
NDArray
]
|
None
=
None
)
[source]

Bases:
VolumetricData
Container for volumetric data that allows
for reading/writing with Poscar-type data.
Typically, this constructor is not used directly and the static
from_file constructor is used. This constructor is designed to allow
summation and other operations between VolumetricData objects.
Parameters
:
structure
(
Structure
) – associated with the volumetric data
data
(
dict
[
str
,
NDArray
]
) – Actual volumetric data.
distance_matrix
(
NDArray
) – A pre-computed distance matrix if available.
Useful so pass distance_matrices between sums,
short-circuiting an otherwise expensive operation.
data_aug
(
NDArray
) – Any extra information associated with volumetric data
(typically augmentation charges)
static
parse_file
(
filename
:
PathLike
)
→
tuple
[
Poscar
,
dict
,
dict
]
[source]

Parse a generic volumetric data file in the VASP like format.
Used by subclasses for parsing files.
Parameters
:
filename
(
PathLike
) – Path of file to parse.
Returns
:
Poscar object, data dict, data_aug dict
Return type
:
tuple[
Poscar
, dict, dict]
write_file
(
file_name
:
PathLike
,
vasp4_compatible
:
bool
=
False
)
→
None
[source]

Write the VolumetricData object to a VASP compatible file.
Parameters
:
file_name
(
PathLike
) – The output file.
vasp4_compatible
(
bool
) – True if the format is VASP4 compatible.
class
WSWQ
(
nspin
:
int
,
nkpoints
:
int
,
nbands
:
int
,
me_real
:
NDArray
,
me_imag
:
NDArray
)
[source]

Bases:
MSONable
Read a WSWQ file.
The WSWQ file is used to calculation the wave function overlaps between:
W: Wavefunctions in the current directory’s WAVECAR file.
WQ: Wavefunctions stored in the WAVECAR.qqq file.
The overlap is computed using the overlap operator S
which make the PAW wavefunctions orthogonormal:
<W_k,m| S | W_k,n> = delta_{mn}
The WSWQ file contains matrix elements of the overlap operator S evaluated
between the planewave wavefunctions W and WQ:
COVL_k,mn = < W_s,k,m | S | WQ_s,k,n >
The indices of WSWQ.data are:
[spin][kpoint][band_i][band_j]
nspin
[source]

Number of spin channels
Type
:
int
nkpoints
[source]

Number of k-points
Type
:
int
nbands
[source]

Number of bands
Type
:
int
me_real
[source]

Real part of the overlap matrix elements
Type
:
NDArray
me_imag
[source]

Imaginary part of the overlap matrix elements
Type
:
NDArray
property
data
:
NDArray
[source]

Complex overlap matrix.
classmethod
from_file
(
filename
:
str
)
→
Self
[source]

Construct a WSWQ object from a file.
Parameters
:
filename
(
str
) – Name of WSWQ file.
Returns
:
WSWQ object.
me_imag
:
NDArray
[source]

me_real
:
NDArray
[source]

nbands
:
int
[source]

nkpoints
:
int
[source]

nspin
:
int
[source]

class
Wavecar
(
filename
:
PathLike
=
'WAVECAR'
,
verbose
:
bool
=
False
,
precision
:
Literal
[
'normal'
,
'accurate'
]
=
'normal'
,
vasp_type
:
Literal
[
'std'
,
'gam'
,
'ncl'
]
|
None
=
None
)
[source]

Bases:
object
Container for the (pseudo-) wavefunctions from VASP.
Coefficients are read from the given WAVECAR file and the corresponding
G-vectors are generated using the algorithm developed in WaveTrans (see
acknowledgments below). To understand how the wavefunctions are evaluated,
please see the evaluate_wavefunc docstring.
It should be noted that the pseudopotential augmentation is not included in
the WAVECAR file. As a result, some caution should be exercised when
deriving value from this information.
The usefulness of this class is to allow the user to do projections or band
unfolding style manipulations of the wavefunction. An example of this can
be seen in the work of Shen et al. 2017
(
https://doi.org/10.1103/PhysRevMaterials.1.065001
).
vasp_type
[source]

The VASP type WAVECAR was generated with.
Type
:
“std” | “gam” | “ncl”
nk
[source]

Number of k-points from the WAVECAR.
Type
:
int
nb
[source]

Number of bands per k-point.
Type
:
int
encut
[source]

Energy cutoff (used to define G_{cut}).
Type
:
float
efermi
[source]

Fermi energy.
Type
:
float
a
[source]

Primitive lattice vectors of the cell (e.g. a_1 = self.a[0, :]).
Type
:
NDArray
b
[source]

Reciprocal lattice vectors of the cell (e.g. b_1 = self.b[0, :]).
Type
:
NDArray
vol
[source]

The volume of the unit cell in real space.
Type
:
float
kpoints
[source]

A list of k-points read from the WAVECAR file.
Type
:
NDArray
band_energy
[source]

A list of band eigenenergies (and corresponding occupancies) for each kpoint,
where the first index corresponds to the index of the k-point (e.g. self.band_energy[kp]).
Type
:
list
Gpoints
[source]

A list of generated G-points for each k-point (a double list), which
are used with the coefficients for each k-point and band to recreate
the wavefunction (e.g. self.Gpoints[kp] is the list of G-points for
k-point kp). The G-points depend on the k-point and reciprocal lattice
and therefore are identical for each band at the same k-point. Each
G-point is represented by integer multipliers (e.g. assuming
Gpoints[kp][n] == [n_1, n_2, n_3], then
G_n = n_1*b_1 + n_2*b_2 + n_3*b_3)
Type
:
list
coeffs
[source]

A list of coefficients for each k-point and band for reconstructing the wavefunction.
For non-spin-polarized, the first index corresponds to the kpoint and the second corresponds to the band
(e.g. self.coeffs[kp][b] corresponds to k-point kp and band b). For spin-polarized calculations,
the first index is for the spin. If the calculation was non-collinear, then self.coeffs[kp][b] will have
two columns (one for each component of the spinor).
Type
:
list
Acknowledgments:
This code is based upon the Fortran program, WaveTrans, written by
R. M. Feenstra and M. Widom from the Dept. of Physics at Carnegie
Mellon University. To see the original work, please visit:
https://www.andrew.cmu.edu/user/feenstra/wavetrans/
Author: Mark Turiansky
Extract information from the given WAVECAR.
Parameters
:
filename
(
PathLike
) – input file. Defaults to WAVECAR.
verbose
(
bool
) – determines whether processing information is shown
precision
(
str
) – determines how fine the fft mesh is (normal or
accurate), only the first letter matters.
vasp_type
(
str
) – determines the VASP type that is used, allowed
values are {‘std’, ‘gam’, ‘ncl’} (only first letter is required).
evaluate_wavefunc
(
kpoint
:
int
,
band
:
int
,
r
:
NDArray
,
spin
:
int
=
0
,
spinor
:
int
=
0
)
→
np.complex64
[source]

Evaluate the wavefunction for a given position, r.
The wavefunction is given by the k-point and band. It is evaluated
at the given position by summing over the components. Formally,
psi_n^k (r) = sum_{i=1}^N c_i^{n,k} exp (i (k + G_i^{n,k}) cdot r)
where psi_n^k is the wavefunction for the nth band at k-point k, N is
the number of plane waves, c_i^{n,k} is the ith coefficient that
corresponds to the nth band and k-point k, and G_i^{n,k} is the ith
G-point corresponding to k-point k.
NOTE: This function is very slow; a discrete fourier transform is the
preferred method of evaluation (see Wavecar.fft_mesh).
Parameters
:
kpoint
(
int
) – the index of the kpoint where the wavefunction will be evaluated.
band
(
int
) – the index of the band where the wavefunction will be evaluated.
r
(
NDArray
) – the position where the wavefunction will be evaluated.
spin
(
int
) – spin index for the desired wavefunction (only for
ISPIN = 2, default = 0).
spinor
(
int
) – component of the spinor that is evaluated (only used
if vasp_type == ‘ncl’).
Returns
:
A complex value corresponding to the evaluation of the wavefunction.
fft_mesh
(
kpoint
:
int
,
band
:
int
,
spin
:
int
=
0
,
spinor
:
int
=
0
,
shift
:
bool
=
True
)
→
NDArray
[source]

Place the coefficients of a wavefunction onto an fft mesh.
Once the mesh has been obtained, a discrete fourier transform can be
used to obtain real-space evaluation of the wavefunction. The output
of this function can be passed directly to numpy’s fft function. For
.. rubric:: Example
mesh = Wavecar(‘WAVECAR’).fft_mesh(kpoint, band)
evals = np.fft.ifftn(mesh)
Parameters
:
kpoint
(
int
) – the index of the kpoint where the wavefunction will be evaluated
band
(
int
) – the index of the band where the wavefunction will be evaluated
spin
(
int
) – the spin of the wavefunction for the desired
wavefunction (only for ISPIN = 2, default = 0)
spinor
(
int
) – component of the spinor that is evaluated (only used
if vasp_type == ‘ncl’)
shift
(
bool
) – determines if the zero frequency coefficient is
placed at index (0, 0, 0) or centered
Returns
:
a numpy ndarray representing the 3D mesh of coefficients
get_parchg
(
poscar
:
Poscar
,
kpoint
:
int
,
band
:
int
,
spin
:
int
|
None
=
None
,
spinor
:
int
|
None
=
None
,
phase
:
bool
=
False
,
scale
:
int
=
2
)
→
Chgcar
[source]

Generate a Chgcar object, which is the charge density of the specified
wavefunction.
This function generates a Chgcar object with the charge density of the
wavefunction specified by band and kpoint (and spin, if the WAVECAR
corresponds to a spin-polarized calculation). The phase tag is a
feature that is not present in VASP. For a real wavefunction, the phase
tag being turned on means that the charge density is multiplied by the
sign of the wavefunction at that point in space. A warning is generated
if the phase tag is on and the chosen kpoint is not Gamma.
Note: Augmentation from the PAWs is NOT included in this function. The
maximal charge density will differ from the PARCHG from VASP, but the
qualitative shape of the charge density will match.
Parameters
:
poscar
(
pymatgen.io.vasp.inputs.Poscar
) – Poscar object that has the
structure associated with the WAVECAR file
kpoint
(
int
) – the index of the kpoint for the wavefunction
band
(
int
) – the index of the band for the wavefunction
spin
(
int
) – optional argument to specify the spin. If the Wavecar
has ISPIN = 2, spin is None generates a Chgcar with total spin
and magnetization, and spin == {0, 1} specifies just the spin
up or down component.
spinor
(
int
) – optional argument to specify the spinor component
for noncollinear data wavefunctions (allowed values of None,
0, or 1)
phase
(
bool
) – flag to determine if the charge density is multiplied
by the sign of the wavefunction. Only valid for real
wavefunctions.
scale
(
int
) – scaling for the FFT grid. The default value of 2 is at
least as fine as the VASP default.
Returns
:
A Chgcar object.
write_unks
(
directory
:
PathLike
)
→
None
[source]

Write the UNK files to the given directory.
Write the cell-periodic part of the Bloch wavefunctions from the
WAVECAR file to each of the UNK files. There will be one UNK file for
each of the kpoints in the WAVECAR file.
Note
Wannier90 expects the full kpoint grid instead of the symmetry-
reduced one that VASP stores the wavefunctions on. You should run
a nscf calculation with ISYM=0 to obtain the correct grid.
Parameters
:
directory
(
PathLike
) – directory to write the UNK files.
class
Waveder
(
cder_real
:
NDArray
,
cder_imag
:
NDArray
)
[source]

Bases:
MSONable
Representation of the WAVEDER file.
The LOPTICS tag produces a WAVEDER file which contains the derivative of the orbitals with respect to k.
Since the data is complex, we need to split it into the real and imaginary parts for JSON serialization.
Note
The way that VASP writes the WAVEDER and WAVEDERF has slightly different logic when indexing the bands.
This results in the formatted WAVDERF only indexing between filled bands. (i.e. all the matrix elements
are between the states i=1:8 and j=1:8 in a two atom Si calculation, which is likely a VASP bug).
As such, it is recommended to used the hidden
LVEL=.True.
flag in VASP which will force indexing over
all bands.
The order of the indices of the data are:
[
band index1,
band index2,
kpoint index,
spin index,
cartesian direction,
]
cder_real
[source]

Real part of the derivative of the orbitals with respect to k.
Type
:
NDArray
cder_imag
[source]

Imaginary part of the derivative of the orbitals with respect to k.
Type
:
NDArray
Author: Miguel Dias Costa, Kamal Choudhary, Jimmy-Xuan Shen
property
cder
:
NDArray
[source]

The complex derivative of the orbitals with respect to k.
cder_imag
:
NDArray
[source]

cder_real
:
NDArray
[source]

classmethod
from_binary
(
filename
:
PathLike
,
data_type
:
Literal
[
'complex64'
,
'float64'
,
'float32'
]
=
'complex64'
)
→
Self
[source]

Read the WAVEDER file.
Parameters
:
filename
– Name of file containing WAVEDER.
data_type
– Data type of the WAVEDER file. Default is complex64.
If the file was generated with the “gamma” version of VASP,
the data type can be either “float64” or “float32”.
Returns
:
Waveder object.
classmethod
from_formatted
(
filename
:
PathLike
)
→
Self
[source]

Read the WAVEDERF file.
Note: This file is only produced when LOPTICS is true and VASP has been
recompiled after uncommenting the line that calls
WRT_CDER_BETWEEN_STATES_FORMATTED in linear_optics.F.
It is recommended to use
from_binary
instead since the binary file is
much smaller and contains the same information.
Parameters
:
filename
(
PathLike
) – The name of the WAVEDER file.
Returns
:
A Waveder object.
get_orbital_derivative_between_states
(
band_i
:
int
,
band_j
:
int
,
kpoint
:
int
,
spin
:
Literal
[
0
,
1
]
,
cart_dir
:
Literal
[
0
,
1
,
2
]
)
→
float
[source]

Get a float between bands band_i and band_j for k-point index,
spin-channel and Cartesian direction.
Parameters
:
band_i
(
int
) – Index of band i
band_j
(
int
) – Index of band j
kpoint
(
int
) – Index of k-point
spin
(
int
) – Spin-channel (0 or 1)
cart_dir
(
int
) – Index of Cartesian direction (0, 1, 2)
Returns
:
a float value
property
nbands
:
int
[source]

The number of bands.
property
nkpoints
:
int
[source]

The number of k-points.
property
nspin
:
int
[source]

The number of spin channels.
class
Xdatcar
(
filename
:
PathLike
,
ionicstep_start
:
int
=
1
,
ionicstep_end
:
int
|
None
=
None
,
comment
:
str
|
None
=
None
)
[source]

Bases:
object
XDATCAR parser. Only tested with VASP 5.x files.
structures
[source]

Structures parsed from XDATCAR.
Type
:
list[
Structure
]
comment
[source]

Optional comment.
Type
:
str
Authors: Ram Balachandran
Init a Xdatcar.
Parameters
:
filename
(
PathLike
) – The XDATCAR file.
ionicstep_start
(
int
) – Starting index of ionic step.
ionicstep_end
(
int
) – Ending index of ionic step.
comment
(
str
) – Optional comment attached to this set of structures.
concatenate
(
filename
:
PathLike
,
ionicstep_start
:
int
=
1
,
ionicstep_end
:
int
|
None
=
None
)
→
None
[source]

Concatenate structures in file to Xdatcar.
Parameters
:
filename
(
PathLike
) – The XDATCAR file to be concatenated.
ionicstep_start
(
int
) – Starting number of ionic step.
ionicstep_end
(
int
) – Ending number of ionic step.
TODO (rambalachandran): Check to ensure the new concatenating file
has the same lattice structure and atoms as the Xdatcar class.
get_str
(
ionicstep_start
:
int
=
1
,
ionicstep_end
:
int
|
None
=
None
,
significant_figures
:
int
=
8
)
→
str
[source]

Get Xdatcar as a string.
Parameters
:
ionicstep_start
(
int
) – Starting index of ionic step.
ionicstep_end
(
int
) – Ending index of ionic step.
significant_figures
(
int
) – Number of significant digits.
Returns
:
Xdatcar as a string.
Return type
:
str
property
natoms
:
list
[
int
]
[source]

Sequence of number of sites of each type associated with the Poscar.
Similar to 7th line in VASP 5+ Xdatcar.
property
site_symbols
:
list
[
str
]
[source]

Sequence of symbols associated with the Xdatcar.
Similar to 6th line in VASP 5+ Xdatcar.
write_file
(
filename
:
PathLike
,
**
kwargs
)
→
None
[source]

Write Xdatcar into a file.
Parameters
:
filename
(
PathLike
) – The output XDATCAR file.
**kwargs
– The same as those for the Xdatcar.get_str
method and are passed through directly.
get_adjusted_fermi_level
(
efermi
:
float
,
cbm
:
float
,
band_structure
:
BandStructureSymmLine
,
energy_step
:
float
=
0.01
)
→
float
[source]

When running a band structure computation, the Fermi level needs to be
taken from the static run that gave the charge density used for the non-self
consistent band structure run. Sometimes this Fermi level is too low
because of the mismatch between the uniform grid used in the static run
and the band structure k-points (e.g., the VBM is on Gamma and the Gamma
point is not in the uniform mesh).
Here we use a procedure looking for energy levels higher than the static
Fermi level and lower than the LUMO. If any of these levels make the
band structure appears insulating (not metallic anymore), we keep this
adjusted fermi level.
This procedure has shown to detect most insulators correctly.
Parameters
:
efermi
(
float
) – The Fermi energy of the static run.
cbm
(
float
) – The conduction band minimum of the static run.
band_structure
(
BandStructureSymmLine
) – A band structure object.
energy_step
(
float
) – The step length for increasing energy during search.
Returns
:
A new adjusted Fermi level.
Return type
:
float
get_band_structure_from_vasp_multiple_branches
(
dir_name
:
str
,
efermi
:
float
|
None
=
None
,
projections
:
bool
=
False
)
→
BandStructureSymmLine
|
BandStructure
|
None
[source]

Get band structure info from a VASP directory.
It takes into account that a run can be divided in several branches named
“branch_x”. If the run has not been divided in branches the method will
turn to parsing vasprun.xml directly.
Parameters
:
dir_name
– Directory containing all bandstructure runs.
efermi
– Efermi for bandstructure.
projections
– True if you want to get the data on site projections if
any. Note that this is sometimes very large
Returns
:
A BandStructure Object.
None is there’s a parsing error.
pymatgen.io.vasp.sets module

This module defines the VaspInputSet abstract base class and a concrete implementation for the parameters developed
and tested by the core team of pymatgen, including the Materials Virtual Lab, Materials Project and the MIT high
throughput project. The basic concept behind an input set is to specify a scheme to generate a consistent set of VASP
inputs from a structure without further user intervention. This ensures comparability across runs.
Read the following carefully before implementing new input sets:
99% of what needs to be done can be done by specifying user_incar_settings to override some of the defaults of
various input sets. Unless there is an extremely good reason to add a new set,
do not
add one. e.g. if you want
to turn the Hubbard U off, just set “LDAU”: False as a user_incar_setting.
All derivative input sets should inherit appropriate configurations (e.g., from MPRelaxSet), and more often than
not, VaspInputSet should be the superclass. Superclass delegation should be used where possible. In particular,
you are not supposed to implement your own as_dict or from_dict for derivative sets unless you know what you are
doing. Improper overriding the as_dict and from_dict protocols is the major cause of implementation headaches. If
you need an example, look at how the MPStaticSet is initialized.
The above are recommendations. The following are
UNBREAKABLE
rules:
All input sets must take in a structure, list of structures or None as the first argument. If None, the input set
should perform a stateless initialization and before any output can be written, a structure must be set.
user_incar_settings, user_kpoints_settings and user_<whatever>_settings are ABSOLUTE. Any new sets you implement
must obey this. If a user wants to override your settings, you assume he knows what he is doing. Do not
magically override user supplied settings. You can issue a warning if you think the user is wrong.
All input sets must save all supplied args and kwargs as instance variables. e.g. self.arg = arg and
self.kwargs = kwargs in the __init__. This ensures the as_dict and from_dict work correctly.
exception
BadInputSetWarning
[source]

Bases:
UserWarning
Warning class for bad but legal VASP inputs.
class
CINEBSet
(
structures
:
list
[
Structure
]
,
**
kwargs
)
[source]

Bases:
NEBSet
MAVRL-tested settings for CI-NEB calculations. Note that these parameters
requires the VTST modification of VASP from the Henkelman group. See
http://theory.cm.utexas.edu/vtsttools/
.
Parameters
:
structures
– Input structures.
**kwargs
– Keyword args supported by VaspInputSets.
class
DictSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
)
[source]

Bases:
VaspInputSet
Alias for VaspInputSet.
class
LobsterSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
'PBE_54'
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
('PBE_52'
,
'PBE_54'
,
'PBE_64')
,
isym:
int
=
0
,
ismear:
int
=
-5
,
reciprocal_density:
int
|
None
=
None
,
address_basis_file:
str
|
None
=
None
,
user_supplied_basis:
dict
|
None
=
None
)
[source]

Bases:
VaspInputSet
Input set to prepare VASP runs that can be digested by Lobster (See cohp.de).
Parameters
:
structure
(
Structure
) – input structure.
isym
(
int
) – ISYM entry for INCAR, only isym=-1 and isym=0 are allowed
ismear
(
int
) – ISMEAR entry for INCAR, only ismear=-5 and ismear=0 are allowed
reciprocal_density
(
int
) – density of k-mesh by reciprocal volume
user_supplied_basis
(
dict
) – dict including basis functions for all elements in
structure, e.g. {“Fe”: “3d 3p 4s”, “O”: “2s 2p”}; if not supplied, a
standard basis is used
address_basis_file
(
str
) – address to a file similar to
“BASIS_PBE_54_standard.yaml” in pymatgen.io.lobster.lobster_basis
user_potcar_settings
(
dict
) – dict including potcar settings for all elements in
structure, e.g. {“Fe”: “Fe_pv”, “O”: “O”}; if not supplied, a standard basis
is used.
**kwargs
– Other kwargs supported by VaspInputSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

address_basis_file
:
str
|
None
=
None
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
ismear
:
int
=
-5
[source]

isym
:
int
=
0
[source]

property
kpoints_updates
:
dict
[
str
,
int
]
[source]

Updates to the kpoints configuration for this calculation type.
reciprocal_density
:
int
|
None
=
None
[source]

user_potcar_functional
:
UserPotcarFunctional
=
'PBE_54'
[source]

user_supplied_basis
:
dict
|
None
=
None
[source]

class
MITMDSet
(
structure:
Structure
|
None
=
None
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
start_temp:
float
=
0.0
,
end_temp:
float
=
300.0
,
nsteps:
int
=
1000
,
time_step:
float
=
2
,
spin_polarized:
bool
=
False
)
[source]

Bases:
VaspInputSet
Write a VASP MD run. This DOES NOT do multiple stage runs.
Parameters
:
structure
(
Structure
) – Input structure.
start_temp
(
float
) – Starting temperature.
end_temp
(
float
) – Final temperature.
nsteps
(
int
) – Number of time steps for simulations. NSW parameter.
time_step
(
float
) – The time step for the simulation. The POTIM
parameter. Defaults to 2fs.
spin_polarized
(
bool
) – Whether to do spin polarized calculations.
The ISPIN parameter. Defaults to False.
**kwargs
– Other kwargs supported by VaspInputSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF':
1e-05,
'ENCUT':
520,
'IBRION':
2,
'ICHARG':
1,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'ISYM':
0,
'LDAU':
True,
'LDAUJ':
{'F':
{'Ag':
0,
'Co':
0,
'Cr':
0,
'Cu':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Nb':
0,
'Ni':
0,
'Re':
0,
'Ta':
0,
'V':
0,
'W':
0},
'O':
{'Ag':
0,
'Co':
0,
'Cr':
0,
'Cu':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Nb':
0,
'Ni':
0,
'Re':
0,
'Ta':
0,
'V':
0,
'W':
0},
'S':
{'Fe':
0,
'Mn':
0}},
'LDAUL':
{'F':
{'Ag':
2,
'Co':
2,
'Cr':
2,
'Cu':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Nb':
2,
'Ni':
2,
'Re':
2,
'Ta':
2,
'V':
2,
'W':
2},
'O':
{'Ag':
2,
'Co':
2,
'Cr':
2,
'Cu':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Nb':
2,
'Ni':
2,
'Re':
2,
'Ta':
2,
'V':
2,
'W':
2},
'S':
{'Fe':
2,
'Mn':
2.5}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Ag':
1.5,
'Co':
3.4,
'Cr':
3.5,
'Cu':
4,
'Fe':
4.0,
'Mn':
3.9,
'Mo':
4.38,
'Nb':
1.5,
'Ni':
6,
'Re':
2,
'Ta':
2,
'V':
3.1,
'W':
4.0},
'O':
{'Ag':
1.5,
'Co':
3.4,
'Cr':
3.5,
'Cu':
4,
'Fe':
4.0,
'Mn':
3.9,
'Mo':
4.38,
'Nb':
1.5,
'Ni':
6,
'Re':
2,
'Ta':
2,
'V':
3.1,
'W':
4.0},
'S':
{'Fe':
1.9,
'Mn':
2.5}},
'LORBIT':
'11',
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
200,
'NELMIN':
6,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'length':
25},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
{'hash':
'd6854224d20e3de6e6fd7399503791d1',
'symbol':
'Ac'},
'Ag':
{'hash':
'e8ffa02fe3f3a51338ac1ac91ae968b9',
'symbol':
'Ag'},
'Al':
{'hash':
'a6fd9a46aec185f4ad2acd0cbe4ae2fa',
'symbol':
'Al'},
'Ar':
{'hash':
'e782fc6292623b396091bf8b871c272f',
'symbol':
'Ar'},
'As':
{'hash':
'8005364db225a254e52cba350bedd032',
'symbol':
'As'},
'Au':
{'hash':
'a9182d436a13194b744640ac940ab9b0',
'symbol':
'Au'},
'B':
{'hash':
'18ed2875dfa6305324cec3d7d59273ae',
'symbol':
'B'},
'Ba':
{'hash':
'c0477913afb63dfae3439f3534fbf0ed',
'symbol':
'Ba_sv'},
'Be':
{'hash':
'fb974e44d56a8c62c6bbd1a1eb70c3a7',
'symbol':
'Be'},
'Bi':
{'hash':
'e29661c79d59abae3b3ba69eae24b1a5',
'symbol':
'Bi'},
'Br':
{'hash':
'40f9594b4506684a69158c8975cfb9d6',
'symbol':
'Br'},
'C':
{'hash':
'c0a8167dbb174fe492a3db7f5006c0f8',
'symbol':
'C'},
'Ca':
{'hash':
'eb006721e214c04b3c13146e81b3a27d',
'symbol':
'Ca_sv'},
'Cd':
{'hash':
'0506b2d0ac28d5fe2b5ced77a701aa86',
'symbol':
'Cd'},
'Ce':
{'hash':
'ff3a09f2ff91798e58eb4b9854e9be4a',
'symbol':
'Ce'},
'Cl':
{'hash':
'779b9901046c78fe51c5d80224642aeb',
'symbol':
'Cl'},
'Co':
{'hash':
'b169bca4e137294d2ab3df8cbdd09083',
'symbol':
'Co'},
'Cr':
{'hash':
'82c14307937c7509fda4e9bc023d243d',
'symbol':
'Cr'},
'Cs':
{'hash':
'096b53a7d80cc0086976bcda50d536e5',
'symbol':
'Cs_sv'},
'Cu':
{'hash':
'8ca4e43a30de0c397e51f16bbb20d678',
'symbol':
'Cu'},
'Dy':
{'hash':
'd4a05220ab0a2d4c03a76872ea724a1e',
'symbol':
'Dy_3'},
'Er':
{'hash':
'daa65a04877317f8c3c593ddeaa8a132',
'symbol':
'Er_3'},
'Eu':
{'hash':
'd466d046adf21f6146ee9644049ea268',
'symbol':
'Eu'},
'F':
{'hash':
'180141c33d032bfbfff30b3bea9d23dd',
'symbol':
'F'},
'Fe':
{'hash':
'9530da8244e4dac17580869b4adab115',
'symbol':
'Fe'},
'Ga':
{'hash':
'6e0b9d58412b1bfcd7252aff13d476c2',
'symbol':
'Ga'},
'Gd':
{'hash':
'1f0d42b1e5f6769d319d3f247992aeb9',
'symbol':
'Gd'},
'Ge':
{'hash':
'79e788788c31e196a460553010512d3f',
'symbol':
'Ge'},
'H':
{'hash':
'bb43c666e3d36577264afe07669e9582',
'symbol':
'H'},
'He':
{'hash':
'47f9434aa3db96c85d7c4b3e4c2df09b',
'symbol':
'He'},
'Hf':
{'hash':
'b113f150cbf9c736f8244a6c25b0482e',
'symbol':
'Hf'},
'Hg':
{'hash':
'c2f15dfb5fd53396c5427635e5019160',
'symbol':
'Hg'},
'Ho':
{'hash':
'661891464a27e87cf7e1324dd1893b77',
'symbol':
'Ho_3'},
'I':
{'hash':
'f4ff16a495dd361ff5824ee61b418bb0',
'symbol':
'I'},
'In':
{'hash':
'7df38c0cdb4e6d9a9b93f09d690bb3ae',
'symbol':
'In'},
'Ir':
{'hash':
'dbcf7dcc6f4fb40df7b3d26904f60a66',
'symbol':
'Ir'},
'K':
{'hash':
'3e84f86d37f203a4fb01de36af57e430',
'symbol':
'K_sv'},
'Kr':
{'hash':
'39b9b85ae3982e6c012fb549b2840ce5',
'symbol':
'Kr'},
'La':
{'hash':
'9b3ce03d18f7c0b40471a817ff91b287',
'symbol':
'La'},
'Li':
{'hash':
'65e83282d1707ec078c1012afbd05be8',
'symbol':
'Li'},
'Lu':
{'hash':
'd40a90babf1224b88ffb4c3273ac3848',
'symbol':
'Lu_3'},
'Mg':
{'hash':
'1771eb72adbbfa6310d66e7517e49930',
'symbol':
'Mg'},
'Mn':
{'hash':
'd082dba29b57ab59b3165e605dbf71b8',
'symbol':
'Mn'},
'Mo':
{'hash':
'84e18fd84a98e3d7fa8f055952410df0',
'symbol':
'Mo_pv'},
'N':
{'hash':
'b98fd027ddebc67da4063ff2cabbc04b',
'symbol':
'N'},
'Na':
{'hash':
'1a89e79f7e21d99e8cf5788979f6a987',
'symbol':
'Na'},
'Nb':
{'hash':
'7bcee99a4dc3094be0f9fd7961c02966',
'symbol':
'Nb_pv'},
'Nd':
{'hash':
'0c64e63070cee837c967283fffa001df',
'symbol':
'Nd'},
'Ne':
{'hash':
'52064eee378b9e37a295a674f1c278f0',
'symbol':
'Ne'},
'Ni':
{'hash':
'653f5772e68b2c7fd87ffd1086c0d710',
'symbol':
'Ni'},
'Np':
{'hash':
'20cb30b714200c4db870550b288ac4cd',
'symbol':
'Np'},
'O':
{'hash':
'7a25bc5b9a5393f46600a4939d357982',
'symbol':
'O'},
'Os':
{'hash':
'35c2cb48d48a9c38c40fb82bbe70626d',
'symbol':
'Os'},
'P':
{'hash':
'7dc3393307131ae67785a0cdacb61d5f',
'symbol':
'P'},
'Pa':
{'hash':
'a1fdb1089d0727f415416ec8082246ba',
'symbol':
'Pa'},
'Pb':
{'hash':
'704c2c967247d7f84090d2536c91877d',
'symbol':
'Pb'},
'Pd':
{'hash':
'a395eb3aaf2fcab12fac3030a1146f61',
'symbol':
'Pd'},
'Pm':
{'hash':
'a2c9485ea86b2a7cf175077e6e5c7b3e',
'symbol':
'Pm'},
'Pr':
{'hash':
'92f191499bf5346ea652bb806350ad87',
'symbol':
'Pr'},
'Pt':
{'hash':
'a604ea3c6a9cc23c739b762f625cf449',
'symbol':
'Pt'},
'Pu':
{'hash':
'f1d01e845dccc52d448679911f301a73',
'symbol':
'Pu'},
'Rb':
{'hash':
'e447c648d870b066b3514e6b800727ab',
'symbol':
'Rb_pv'},
'Re':
{'hash':
'72385e193c92a8acfe17ea49004c2be1',
'symbol':
'Re'},
'Rh':
{'hash':
'2c3dba3fcc6058ca1b1cfa75e45084bc',
'symbol':
'Rh'},
'Ru':
{'hash':
'7925f4d4b68076d70af7cd86eef9ba8d',
'symbol':
'Ru_pv'},
'S':
{'hash':
'd368db6899d8839859bbee4811a42a88',
'symbol':
'S'},
'Sb':
{'hash':
'd82c022b02fc5344e85bd1909f9ee3e7',
'symbol':
'Sb'},
'Sc':
{'hash':
'dc386f505ad0c43385a7715b4111cb75',
'symbol':
'Sc_sv'},
'Se':
{'hash':
'67a8804ede9f1112726e3d136978ef19',
'symbol':
'Se'},
'Si':
{'hash':
'b2b0ea6feb62e7cde209616683b8f7f5',
'symbol':
'Si'},
'Sm':
{'hash':
'e5e274e7cd99602ca81d146155abdf88',
'symbol':
'Sm_3'},
'Sn':
{'hash':
'849b0795e148f93113a06be8fd5f5001',
'symbol':
'Sn_d'},
'Sr':
{'hash':
'ca6a5429c120a0ab705824386a76fe5b',
'symbol':
'Sr_sv'},
'Ta':
{'hash':
'd4e2cfe9338ef80da592d5bb9dc782c7',
'symbol':
'Ta'},
'Tb':
{'hash':
'0790955c547003956c0fd4f080f7f508',
'symbol':
'Tb_3'},
'Tc':
{'hash':
'9592642886319309a39d55c5717c6f48',
'symbol':
'Tc'},
'Te':
{'hash':
'72719856e22fb1d3032df6f96d98a0f2',
'symbol':
'Te'},
'Th':
{'hash':
'aea79f322180fa6f0bfa74cb2a156dcf',
'symbol':
'Th'},
'Ti':
{'hash':
'c617e8b539c3f44a0ab6e8da2a92d318',
'symbol':
'Ti'},
'Tl':
{'hash':
'2aa0d5406aaab7ebfbc761da382f1352',
'symbol':
'Tl'},
'Tm':
{'hash':
'94a07cb7949b01305cb161da0cbfb492',
'symbol':
'Tm_3'},
'U':
{'hash':
'72702eabbb1bc02b4167590dc848ed5d',
'symbol':
'U'},
'V':
{'hash':
'7f1297a2e1d963e2a4d81b61f85e4ded',
'symbol':
'V_pv'},
'W':
{'hash':
'2a33e0d5c700640535f60ac0a12177ab',
'symbol':
'W_pv'},
'Xe':
{'hash':
'338472e581f58b41d37c002a5e22353b',
'symbol':
'Xe'},
'Y':
{'hash':
'4ed187e77cd54f198bb88020278b143d',
'symbol':
'Y_sv'},
'Yb':
{'hash':
'9f472bd422f640710f7d93e2d9ce89f4',
'symbol':
'Yb'},
'Zn':
{'hash':
'e35ee27f8483a63bb68dbc236a343af3',
'symbol':
'Zn'},
'Zr':
{'hash':
'd221d2c0bac4f8e81af2f5c42a314274',
'symbol':
'Zr'}},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

end_temp
:
float
=
300.0
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
property
kpoints_updates
:
Kpoints
[source]

Updates to the kpoints configuration for this calculation type.
nsteps
:
int
=
1000
[source]

spin_polarized
:
bool
=
False
[source]

start_temp
:
float
=
0.0
[source]

structure
:
Structure
|
None
=
None
[source]

time_step
:
float
=
2
[source]

class
MITNEBSet
(
structures
:
list
[
Structure
]
,
**
kwargs
)
[source]

Bases:
NEBSet
NEBSet using MITRelaxSet as parent. Retained for compatibility.
Parameters
:
structures
– List of Structure objects.
**kwargs
– Other kwargs supported by VaspInputSet.
class
MITRelaxSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
)
[source]

Bases:
VaspInputSet
Standard implementation of VaspInputSet utilizing parameters in the MIT
High-throughput project.
The parameters are chosen specifically for a high-throughput project,
which means in general pseudopotentials with fewer electrons were chosen.
Parameters
:
structure
(
Structure
) – The Structure to create inputs for. If None, the input
set is initialized without a Structure but one must be set separately before
the inputs are generated.
**kwargs
– Keywords supported by VaspInputSet.
Please refer:
A Jain, G. Hautier, C. Moore, S. P. Ong, C. Fischer, T. Mueller,
K. A. Persson, G. Ceder. A high-throughput infrastructure for density
functional theory calculations. Computational Materials Science,
2011, 50(8), 2295-2310. doi:10.1016/j.commatsci.2011.02.023
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF':
1e-05,
'ENCUT':
520,
'IBRION':
2,
'ICHARG':
1,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'ISYM':
0,
'LDAU':
True,
'LDAUJ':
{'F':
{'Ag':
0,
'Co':
0,
'Cr':
0,
'Cu':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Nb':
0,
'Ni':
0,
'Re':
0,
'Ta':
0,
'V':
0,
'W':
0},
'O':
{'Ag':
0,
'Co':
0,
'Cr':
0,
'Cu':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Nb':
0,
'Ni':
0,
'Re':
0,
'Ta':
0,
'V':
0,
'W':
0},
'S':
{'Fe':
0,
'Mn':
0}},
'LDAUL':
{'F':
{'Ag':
2,
'Co':
2,
'Cr':
2,
'Cu':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Nb':
2,
'Ni':
2,
'Re':
2,
'Ta':
2,
'V':
2,
'W':
2},
'O':
{'Ag':
2,
'Co':
2,
'Cr':
2,
'Cu':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Nb':
2,
'Ni':
2,
'Re':
2,
'Ta':
2,
'V':
2,
'W':
2},
'S':
{'Fe':
2,
'Mn':
2.5}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Ag':
1.5,
'Co':
3.4,
'Cr':
3.5,
'Cu':
4,
'Fe':
4.0,
'Mn':
3.9,
'Mo':
4.38,
'Nb':
1.5,
'Ni':
6,
'Re':
2,
'Ta':
2,
'V':
3.1,
'W':
4.0},
'O':
{'Ag':
1.5,
'Co':
3.4,
'Cr':
3.5,
'Cu':
4,
'Fe':
4.0,
'Mn':
3.9,
'Mo':
4.38,
'Nb':
1.5,
'Ni':
6,
'Re':
2,
'Ta':
2,
'V':
3.1,
'W':
4.0},
'S':
{'Fe':
1.9,
'Mn':
2.5}},
'LORBIT':
'11',
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
200,
'NELMIN':
6,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'length':
25},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
{'hash':
'd6854224d20e3de6e6fd7399503791d1',
'symbol':
'Ac'},
'Ag':
{'hash':
'e8ffa02fe3f3a51338ac1ac91ae968b9',
'symbol':
'Ag'},
'Al':
{'hash':
'a6fd9a46aec185f4ad2acd0cbe4ae2fa',
'symbol':
'Al'},
'Ar':
{'hash':
'e782fc6292623b396091bf8b871c272f',
'symbol':
'Ar'},
'As':
{'hash':
'8005364db225a254e52cba350bedd032',
'symbol':
'As'},
'Au':
{'hash':
'a9182d436a13194b744640ac940ab9b0',
'symbol':
'Au'},
'B':
{'hash':
'18ed2875dfa6305324cec3d7d59273ae',
'symbol':
'B'},
'Ba':
{'hash':
'c0477913afb63dfae3439f3534fbf0ed',
'symbol':
'Ba_sv'},
'Be':
{'hash':
'fb974e44d56a8c62c6bbd1a1eb70c3a7',
'symbol':
'Be'},
'Bi':
{'hash':
'e29661c79d59abae3b3ba69eae24b1a5',
'symbol':
'Bi'},
'Br':
{'hash':
'40f9594b4506684a69158c8975cfb9d6',
'symbol':
'Br'},
'C':
{'hash':
'c0a8167dbb174fe492a3db7f5006c0f8',
'symbol':
'C'},
'Ca':
{'hash':
'eb006721e214c04b3c13146e81b3a27d',
'symbol':
'Ca_sv'},
'Cd':
{'hash':
'0506b2d0ac28d5fe2b5ced77a701aa86',
'symbol':
'Cd'},
'Ce':
{'hash':
'ff3a09f2ff91798e58eb4b9854e9be4a',
'symbol':
'Ce'},
'Cl':
{'hash':
'779b9901046c78fe51c5d80224642aeb',
'symbol':
'Cl'},
'Co':
{'hash':
'b169bca4e137294d2ab3df8cbdd09083',
'symbol':
'Co'},
'Cr':
{'hash':
'82c14307937c7509fda4e9bc023d243d',
'symbol':
'Cr'},
'Cs':
{'hash':
'096b53a7d80cc0086976bcda50d536e5',
'symbol':
'Cs_sv'},
'Cu':
{'hash':
'8ca4e43a30de0c397e51f16bbb20d678',
'symbol':
'Cu'},
'Dy':
{'hash':
'd4a05220ab0a2d4c03a76872ea724a1e',
'symbol':
'Dy_3'},
'Er':
{'hash':
'daa65a04877317f8c3c593ddeaa8a132',
'symbol':
'Er_3'},
'Eu':
{'hash':
'd466d046adf21f6146ee9644049ea268',
'symbol':
'Eu'},
'F':
{'hash':
'180141c33d032bfbfff30b3bea9d23dd',
'symbol':
'F'},
'Fe':
{'hash':
'9530da8244e4dac17580869b4adab115',
'symbol':
'Fe'},
'Ga':
{'hash':
'6e0b9d58412b1bfcd7252aff13d476c2',
'symbol':
'Ga'},
'Gd':
{'hash':
'1f0d42b1e5f6769d319d3f247992aeb9',
'symbol':
'Gd'},
'Ge':
{'hash':
'79e788788c31e196a460553010512d3f',
'symbol':
'Ge'},
'H':
{'hash':
'bb43c666e3d36577264afe07669e9582',
'symbol':
'H'},
'He':
{'hash':
'47f9434aa3db96c85d7c4b3e4c2df09b',
'symbol':
'He'},
'Hf':
{'hash':
'b113f150cbf9c736f8244a6c25b0482e',
'symbol':
'Hf'},
'Hg':
{'hash':
'c2f15dfb5fd53396c5427635e5019160',
'symbol':
'Hg'},
'Ho':
{'hash':
'661891464a27e87cf7e1324dd1893b77',
'symbol':
'Ho_3'},
'I':
{'hash':
'f4ff16a495dd361ff5824ee61b418bb0',
'symbol':
'I'},
'In':
{'hash':
'7df38c0cdb4e6d9a9b93f09d690bb3ae',
'symbol':
'In'},
'Ir':
{'hash':
'dbcf7dcc6f4fb40df7b3d26904f60a66',
'symbol':
'Ir'},
'K':
{'hash':
'3e84f86d37f203a4fb01de36af57e430',
'symbol':
'K_sv'},
'Kr':
{'hash':
'39b9b85ae3982e6c012fb549b2840ce5',
'symbol':
'Kr'},
'La':
{'hash':
'9b3ce03d18f7c0b40471a817ff91b287',
'symbol':
'La'},
'Li':
{'hash':
'65e83282d1707ec078c1012afbd05be8',
'symbol':
'Li'},
'Lu':
{'hash':
'd40a90babf1224b88ffb4c3273ac3848',
'symbol':
'Lu_3'},
'Mg':
{'hash':
'1771eb72adbbfa6310d66e7517e49930',
'symbol':
'Mg'},
'Mn':
{'hash':
'd082dba29b57ab59b3165e605dbf71b8',
'symbol':
'Mn'},
'Mo':
{'hash':
'84e18fd84a98e3d7fa8f055952410df0',
'symbol':
'Mo_pv'},
'N':
{'hash':
'b98fd027ddebc67da4063ff2cabbc04b',
'symbol':
'N'},
'Na':
{'hash':
'1a89e79f7e21d99e8cf5788979f6a987',
'symbol':
'Na'},
'Nb':
{'hash':
'7bcee99a4dc3094be0f9fd7961c02966',
'symbol':
'Nb_pv'},
'Nd':
{'hash':
'0c64e63070cee837c967283fffa001df',
'symbol':
'Nd'},
'Ne':
{'hash':
'52064eee378b9e37a295a674f1c278f0',
'symbol':
'Ne'},
'Ni':
{'hash':
'653f5772e68b2c7fd87ffd1086c0d710',
'symbol':
'Ni'},
'Np':
{'hash':
'20cb30b714200c4db870550b288ac4cd',
'symbol':
'Np'},
'O':
{'hash':
'7a25bc5b9a5393f46600a4939d357982',
'symbol':
'O'},
'Os':
{'hash':
'35c2cb48d48a9c38c40fb82bbe70626d',
'symbol':
'Os'},
'P':
{'hash':
'7dc3393307131ae67785a0cdacb61d5f',
'symbol':
'P'},
'Pa':
{'hash':
'a1fdb1089d0727f415416ec8082246ba',
'symbol':
'Pa'},
'Pb':
{'hash':
'704c2c967247d7f84090d2536c91877d',
'symbol':
'Pb'},
'Pd':
{'hash':
'a395eb3aaf2fcab12fac3030a1146f61',
'symbol':
'Pd'},
'Pm':
{'hash':
'a2c9485ea86b2a7cf175077e6e5c7b3e',
'symbol':
'Pm'},
'Pr':
{'hash':
'92f191499bf5346ea652bb806350ad87',
'symbol':
'Pr'},
'Pt':
{'hash':
'a604ea3c6a9cc23c739b762f625cf449',
'symbol':
'Pt'},
'Pu':
{'hash':
'f1d01e845dccc52d448679911f301a73',
'symbol':
'Pu'},
'Rb':
{'hash':
'e447c648d870b066b3514e6b800727ab',
'symbol':
'Rb_pv'},
'Re':
{'hash':
'72385e193c92a8acfe17ea49004c2be1',
'symbol':
'Re'},
'Rh':
{'hash':
'2c3dba3fcc6058ca1b1cfa75e45084bc',
'symbol':
'Rh'},
'Ru':
{'hash':
'7925f4d4b68076d70af7cd86eef9ba8d',
'symbol':
'Ru_pv'},
'S':
{'hash':
'd368db6899d8839859bbee4811a42a88',
'symbol':
'S'},
'Sb':
{'hash':
'd82c022b02fc5344e85bd1909f9ee3e7',
'symbol':
'Sb'},
'Sc':
{'hash':
'dc386f505ad0c43385a7715b4111cb75',
'symbol':
'Sc_sv'},
'Se':
{'hash':
'67a8804ede9f1112726e3d136978ef19',
'symbol':
'Se'},
'Si':
{'hash':
'b2b0ea6feb62e7cde209616683b8f7f5',
'symbol':
'Si'},
'Sm':
{'hash':
'e5e274e7cd99602ca81d146155abdf88',
'symbol':
'Sm_3'},
'Sn':
{'hash':
'849b0795e148f93113a06be8fd5f5001',
'symbol':
'Sn_d'},
'Sr':
{'hash':
'ca6a5429c120a0ab705824386a76fe5b',
'symbol':
'Sr_sv'},
'Ta':
{'hash':
'd4e2cfe9338ef80da592d5bb9dc782c7',
'symbol':
'Ta'},
'Tb':
{'hash':
'0790955c547003956c0fd4f080f7f508',
'symbol':
'Tb_3'},
'Tc':
{'hash':
'9592642886319309a39d55c5717c6f48',
'symbol':
'Tc'},
'Te':
{'hash':
'72719856e22fb1d3032df6f96d98a0f2',
'symbol':
'Te'},
'Th':
{'hash':
'aea79f322180fa6f0bfa74cb2a156dcf',
'symbol':
'Th'},
'Ti':
{'hash':
'c617e8b539c3f44a0ab6e8da2a92d318',
'symbol':
'Ti'},
'Tl':
{'hash':
'2aa0d5406aaab7ebfbc761da382f1352',
'symbol':
'Tl'},
'Tm':
{'hash':
'94a07cb7949b01305cb161da0cbfb492',
'symbol':
'Tm_3'},
'U':
{'hash':
'72702eabbb1bc02b4167590dc848ed5d',
'symbol':
'U'},
'V':
{'hash':
'7f1297a2e1d963e2a4d81b61f85e4ded',
'symbol':
'V_pv'},
'W':
{'hash':
'2a33e0d5c700640535f60ac0a12177ab',
'symbol':
'W_pv'},
'Xe':
{'hash':
'338472e581f58b41d37c002a5e22353b',
'symbol':
'Xe'},
'Y':
{'hash':
'4ed187e77cd54f198bb88020278b143d',
'symbol':
'Y_sv'},
'Yb':
{'hash':
'9f472bd422f640710f7d93e2d9ce89f4',
'symbol':
'Yb'},
'Zn':
{'hash':
'e35ee27f8483a63bb68dbc236a343af3',
'symbol':
'Zn'},
'Zr':
{'hash':
'd221d2c0bac4f8e81af2f5c42a314274',
'symbol':
'Zr'}},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

class
MP24RelaxSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
=
False
,
auto_kspacing:
bool
=
True
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
xc_functional:
Literal['r2SCAN'
,
'PBE'
,
'PBEsol']
=
'r2SCAN'
,
dispersion:
Literal['rVV10'
,
'D4']
|
None
=
None
)
[source]

Bases:
VaspInputSet
Materials Project relax set after a 2023-2024 benchmarking effort.
By default, this uses r2SCAN as the xc functional.
For discussion around this benchmarking effort, see:
https://github.com/materialsproject/foundation/pull/26
Citation info:
- r2SCAN:
James W. Furness, Aaron D. Kaplan, Jinliang Ning, John P. Perdew, and Jianwei Sun.
Accurate and Numerically Efficient r2SCAN Meta-Generalized Gradient Approximation.
J. Phys. Chem. Lett. 11, 8208-8215 (2022) DOI: 10.1021/acs.jpclett.0c02405
r2SCAN-rVV10:
Jinliang Ning, Manish Kothakonda, James W. Furness, Aaron D. Kaplan, Sebastian Ehlert,
Jan Gerit Brandenburg, John P. Perdew, and Jianwei Sun.
Workhorse minimally empirical dispersion-corrected density functional with tests for
weakly bound systems: r2SCAN+rVV10.
Phys. Rev. B 106, 075422 (2022) DOI: 10.1103/PhysRevB.106.075422
r2SCAN-D4:
Sebastian Ehlert, Uwe Huniar, Jinliang Ning, James W. Furness, Jianwei Sun,
Aaron D. Kaplan, John P. Perdew, and Jan Gerit Brandenburg.
r2SCAN-D4: Dispersion corrected meta-generalized gradient approximation for general chemical applications.
J. Chem. Phys. 154, 061101 (2021) DOI: 10.1063/5.0041008
PBE:
John P. Perdew, Kieron Burke, and Matthias Ernzerhof,
Generalized Gradient Approximation Made Simple,
Phys. Rev. Lett. 77, 3865 (1996) DOI: 10.1103/PhysRevLett.77.3865
PBEsol:
John P. Perdew, Adrienn Ruzsinszky, Gábor I. Csonka, Oleg A. Vydrov,
Gustavo E. Scuseria, Lucian A. Constantin, Xiaolan Zhou, and Kieron Burke.
Restoring the Density-Gradient Expansion for Exchange in Solids and Surfaces.
Phys. Rev. Lett. 100, 136406 (2009) DOI: 10.1103/PhysRevLett.100.136406
PBE-D4 and PBEsol-D4:
Eike Caldeweyher,Jan-Michael Mewes, Sebastian Ehlert, and Stefan Grimme.
Extension and evaluation of the D4 London-dispersion model for periodic systems.
Phys. Chem. Chem. Phys. 22, 8499-8512 (2020) DOI: 10.1039/D0CP00502A
CONFIG
=
{'INCAR':
{'ALGO':
'Normal',
'EDIFF':
1e-05,
'EDIFFG':
-0.02,
'ENAUG':
1360,
'ENCUT':
680,
'GGA_COMPAT':
False,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
0,
'ISPIN':
2,
'KSPACING':
0.22,
'LAECHG':
True,
'LASPH':
True,
'LCHARG':
True,
'LELF':
False,
'LMAXMIX':
6,
'LMIXTAU':
True,
'LORBIT':
11,
'LREAL':
False,
'LVTOT':
True,
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'METAGGA':
'R2SCAN',
'NELM':
200,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'PARENT':
'PBE64Base',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Am':
'Am',
'Ar':
'Ar',
'As':
'As',
'At':
'At',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv_GW',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cf':
'Cf',
'Cl':
'Cl',
'Cm':
'Cm',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_h',
'Er':
'Er_h',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Fr':
'Fr_sv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_h',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_h',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_h',
'Po':
'Po_d',
'Pr':
'Pr_h',
'Pt':
'Pt',
'Pu':
'Pu',
'Ra':
'Ra_sv',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Rn':
'Rn',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_h',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_h',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_h',
'U':
'U',
'V':
'V_pv',
'W':
'W_sv',
'Xe':
'Xe_GW',
'Y':
'Y_sv',
'Yb':
'Yb_h',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE_64'}
[source]

auto_ismear
:
bool
=
False
[source]

auto_kspacing
:
bool
=
True
[source]

dispersion
:
Literal
[
'rVV10'
,
'D4'
]
|
None
=
None
[source]

inherit_incar
:
bool
=
False
[source]

property
kspacing_update
[source]

xc_functional
:
Literal
[
'r2SCAN'
,
'PBE'
,
'PBEsol'
]
=
'r2SCAN'
[source]

class
MP24StaticSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
=
False
,
auto_kspacing:
bool
=
True
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
xc_functional:
Literal['r2SCAN'
,
'PBE'
,
'PBEsol']
=
'r2SCAN'
,
dispersion:
Literal['rVV10'
,
'D4']
|
None
=
None
,
lepsilon:
bool
=
False
,
lcalcpol:
bool
=
False
)
[source]

Bases:
MP24RelaxSet
Create input files for a static calculation using MP24 parameters.
For class information, refer to
MP24RelaxSet
.
If you use this set, please consider citing the appropriate papers in
MP24RelaxSet
.
Parameters
:
structure
(
Structure
) – Structure from previous run.
bandgap
(
float
) – Bandgap of the structure in eV. The bandgap is used to
compute the appropriate k-point density and determine the smearing settings.
lepsilon
(
bool
) – Whether to add static dielectric calculation
lcalcpol
(
bool
) – Whether to turn on evaluation of the Berry phase approximations
for electronic polarization.
**kwargs
– Keywords supported by MP24RelaxSet.
auto_kspacing
:
bool
=
True
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
inherit_incar
:
bool
=
False
[source]

lcalcpol
:
bool
=
False
[source]

lepsilon
:
bool
=
False
[source]

class
MPAbsorptionSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
True
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
=
True
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
mode:
str
=
'IPA'
,
copy_wavecar:
bool
=
True
,
nbands_factor:
float
=
2
,
reciprocal_density:
float
=
400
,
nkred:
tuple[int
,
int
,
int]
|
None
=
None
,
nedos:
int
=
2001
,
nbands:
int
|
None
=
None
)
[source]

Bases:
VaspInputSet
MP input set for generating frequency dependent dielectrics.
Two modes are supported: “IPA” or “RPA”.
A typical sequence is mode=”STATIC” -> mode=”IPA” -> mode=”RPA”(optional)
For all steps other than the first one (static), the
recommendation is to use from_prev_calculation on the preceding run in
the series. It is important to ensure Gamma centred kpoints for the RPA step.
Parameters
:
structure
(
Structure
) – Input structure.
mode
(
str
) – Supported modes are “IPA”, “RPA”
copy_wavecar
(
bool
) – Whether to copy the WAVECAR from a previous run.
Defaults to True.
nbands
(
int
) – For subsequent calculations, it is generally
recommended to perform NBANDS convergence starting from the
NBANDS of the previous run for DIAG, and to use the exact same
NBANDS for RPA. This parameter is used by
from_previous_calculation to set nband.
nbands_factor
(
int
) – Multiplicative factor for NBANDS when starting
from a previous calculation. Only applies if mode==”IPA”.
Need to be tested for convergence.
reciprocal_density
– the k-points density
nkred
– the reduced number of kpoints to calculate, equal to the k-mesh.
Only applies in “RPA” mode because of the q->0 limit.
nedos
– the density of DOS, default: 2001.
**kwargs
– All kwargs supported by VaspInputSet. Typically, user_incar_settings is a
commonly used option.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

SUPPORTED_MODES
=
('IPA',
'RPA')
[source]

copy_wavecar
:
bool
=
True
[source]

force_gamma
:
bool
=
True
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
inherit_incar
:
bool
=
True
[source]

property
kpoints_updates
:
dict
[
str
,
float
]
[source]

Updates to the kpoints configuration for this calculation type.
Generate gamma center k-points mesh grid for optical calculation. It is not
mandatory for ‘ALGO = Exact’, but is requested by ‘ALGO = CHI’ calculation.
mode
:
str
=
'IPA'
[source]

nbands
:
int
|
None
=
None
[source]

nbands_factor
:
float
=
2
[source]

nedos
:
int
=
2001
[source]

nkred
:
tuple
[
int
,
int
,
int
]
|
None
=
None
[source]

reciprocal_density
:
float
=
400
[source]

class
MPHSEBSSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
added_kpoints:
list[tuple[float
,
float
,
float]]
=
<factory>
,
mode:
str
=
'gap'
,
reciprocal_density:
float
=
50
,
copy_chgcar:
bool
=
True
,
kpoints_line_density:
float
=
20
,
nbands_factor:
float
=
1.2
,
zero_weighted_reciprocal_density:
float
=
100
,
dedos:
float
=
0.02
,
optics:
bool
=
False
)
[source]

Bases:
VaspInputSet
Implementation of a VaspInputSet for HSE band structure computations.
Remember that HSE band structures must be self-consistent in VASP. A band structure
along symmetry lines for instance needs BOTH a uniform grid with appropriate weights
AND a path along the lines with weight 0.
Thus, the “uniform” mode is just like regular static SCF but allows adding custom
kpoints (e.g., corresponding to known VBM/CBM) to the uniform grid that have zero
weight (e.g., for better gap estimate).
The “gap” mode behaves just like the “uniform” mode, however, if starting from a
previous calculation, the VBM and CBM k-points will automatically be added to
added_kpoints
.
The “line” mode is just like “uniform” mode, but additionally adds k-points along
symmetry lines with zero weight.
The “uniform_dense” mode is like “uniform” mode but additionally adds a denser
uniform mesh with zero weight. This can be useful when calculating Fermi surfaces
or BoltzTraP/AMSET electronic transport using hybrid DFT.
Parameters
:
structure
(
Structure
) – Structure to compute
added_kpoints
(
list
) – a list of kpoints (list of 3 number list) added to the
run. The k-points are in fractional coordinates
mode
(
str
) – “Line” - generate k-points along symmetry lines for bandstructure.
“Uniform” - generate uniform k-points grid.
reciprocal_density
(
int
) – k-point density to use for uniform mesh.
copy_chgcar
(
bool
) – Whether to copy the CHGCAR of a previous run.
kpoints_line_density
(
int
) – k-point density for high symmetry lines
dedos
(
float
) – Energy difference used to set NEDOS, based on the total energy
range.
optics
(
bool
) – Whether to add LOPTICS (used for calculating optical response).
nbands_factor
(
float
) – Multiplicative factor for NBANDS when starting from a
previous calculation. Choose a higher number if you are doing an LOPTICS
calculation.
**kwargs
– Keywords supported by VaspInputSet.
CONFIG
=
{'INCAR':
{'ALGO':
'All',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'HFSCREEN':
0.2,
'IBRION':
2,
'ICHARG':
1,
'ISIF':
3,
'ISMEAR':
0,
'ISPIN':
2,
'LHFCALC':
True,
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'PRECFOCK':
'Fast',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
50},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE_52'}
[source]

added_kpoints
:
list
[
tuple
[
float
,
float
,
float
]
]
[source]

copy_chgcar
:
bool
=
True
[source]

dedos
:
float
=
0.02
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
kpoints_line_density
:
float
=
20
[source]

property
kpoints_updates
:
dict
[
str
,
Any
]
[source]

Updates to the kpoints configuration for this calculation type.
mode
:
str
=
'gap'
[source]

nbands_factor
:
float
=
1.2
[source]

optics
:
bool
=
False
[source]

reciprocal_density
:
float
=
50
[source]

zero_weighted_reciprocal_density
:
float
=
100
[source]

class
MPHSERelaxSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
Literal['dftd3'
,
'dftd3-bj']
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
)
[source]

Bases:
VaspInputSet
Same as the MPRelaxSet, but with HSE parameters and vdW corrections.
CONFIG
=
{'INCAR':
{'ALGO':
'All',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'HFSCREEN':
0.2,
'IBRION':
2,
'ICHARG':
1,
'ISIF':
3,
'ISMEAR':
0,
'ISPIN':
2,
'LHFCALC':
True,
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'PRECFOCK':
'Fast',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
50},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE_52'}
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
vdw
:
Literal
[
'dftd3'
,
'dftd3-bj'
]
|
None
=
None
[source]

class
MPMDSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
start_temp:
float
=
0.0
,
end_temp:
float
=
300.0
,
nsteps:
int
=
1000
,
time_step:
float
|
None
=
None
,
spin_polarized:
bool
=
False
)
[source]

Bases:
VaspInputSet
This a modified version of the old MITMDSet pre 2018/03/12.
This set serves as the basis for the amorphous skyline paper.
Aykol, M.; Dwaraknath, S. S.; Sun, W.; Persson, K. A. Thermodynamic
Limit for Synthesis of Metastable Inorganic Materials. Sci. Adv. 2018,
4 (4).
Class for writing a VASP MD run. This DOES NOT do multiple stage runs.
Precision remains normal, to increase accuracy of stress tensor.
Parameters
:
structure
(
Structure
) – Input structure.
start_temp
(
int
) – Starting temperature.
end_temp
(
int
) – Final temperature.
nsteps
(
int
) – Number of time steps for simulations. NSW parameter.
time_step
(
float
) – The time step for the simulation. The POTIM
parameter. Defaults to None, which will set it automatically
to 2.0 fs for non-hydrogen containing structures and 0.5 fs
for hydrogen containing structures.
spin_polarized
(
bool
) – Whether to do spin polarized calculations.
The ISPIN parameter. Defaults to False.
**kwargs
– Other kwargs supported by VaspInputSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

end_temp
:
float
=
300.0
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
property
kpoints_updates
:
Kpoints
[source]

Updates to the kpoints configuration for this calculation type.
nsteps
:
int
=
1000
[source]

spin_polarized
:
bool
=
False
[source]

start_temp
:
float
=
0.0
[source]

time_step
:
float
|
None
=
None
[source]

class
MPMetalRelaxSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
)
[source]

Bases:
VaspInputSet
Implementation of VaspInputSet utilizing parameters in the public
Materials Project, but with tuning for metals. Key things are a denser
k point density, and a.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

property
incar_updates
:
dict
[source]

Updates to the INCAR config for this calculation type.
property
kpoints_updates
:
dict
[source]

Updates to the kpoints configuration for this calculation type.
class
MPNMRSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
=
True
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
mode:
Literal['cs'
,
'efg']
=
'cs'
,
isotopes:
list
=
<factory>
,
reciprocal_density:
int
=
100
,
small_gap_multiply:
tuple[float
,
float]
|
None
=
None
)
[source]

Bases:
VaspInputSet
Init a MPNMRSet.
Parameters
:
structure
(
Structure
) – Structure from previous run.
mode
(
str
) – The NMR calculation to run
“cs”: for Chemical Shift
“efg” for Electric Field Gradient
isotopes
(
list
) – list of Isotopes for quadrupole moments
reciprocal_density
(
int
) – density of k-mesh by reciprocal volume.
lepsilon
(
bool
) – Whether to add static dielectric calculation
lcalcpol
(
bool
) – Whether to turn on evaluation of the Berry phase approximations
for electronic polarization
reciprocal_density
– For static calculations, we usually set the
reciprocal density by volume. This is a convenience arg to change
that, rather than using user_kpoints_settings. Defaults to 100,
which is ~50% more than that of standard relaxation calculations.
small_gap_multiply
(
[
float
,
float
]
) – If the gap is less than
1st index, multiply the default reciprocal_density by the 2nd
index.
**kwargs
– Keywords supported by MPRelaxSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
inherit_incar
:
bool
=
True
[source]

isotopes
:
list
[source]

property
kpoints_updates
:
dict
[
str
,
Any
]
[source]

Updates to the kpoints configuration for this calculation type.
mode
:
Literal
[
'cs'
,
'efg'
]
=
'cs'
[source]

reciprocal_density
:
int
=
100
[source]

small_gap_multiply
:
tuple
[
float
,
float
]
|
None
=
None
[source]

class
MPNonSCFSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
=
True
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
mode:
str
=
'line'
,
nedos:
int
=
2001
,
dedos:
float
=
0.005
,
reciprocal_density:
float
=
100
,
kpoints_line_density:
float
=
20
,
optics:
bool
=
False
,
copy_chgcar:
bool
=
True
,
nbands_factor:
float
=
1.2
,
small_gap_multiply:
tuple[float
,
float]
|
None
=
None
)
[source]

Bases:
VaspInputSet
Init a MPNonSCFSet. Typically, you would use the classmethod
from_prev_calc to initialize from a previous SCF run.
Parameters
:
structure
(
Structure
) – Structure to compute
mode
(
str
) – Line, Uniform or Boltztrap mode supported.
nedos
(
int
) – nedos parameter. Default to 2001.
dedos
(
float
) – setting nedos=0 and uniform mode in from_prev_calc,
an automatic nedos will be calculated using the total energy range
divided by the energy step dedos
reciprocal_density
(
int
) – density of k-mesh by reciprocal
volume (defaults to 100)
kpoints_line_density
(
int
) – Line density for Line mode.
optics
(
bool
) – whether to add dielectric function
copy_chgcar
– Whether to copy the old CHGCAR when starting from a
previous calculation.
nbands_factor
(
float
) – Multiplicative factor for NBANDS when starting
from a previous calculation. Choose a higher number if you are
doing an LOPTICS calculation.
small_gap_multiply
(
[
float
,
float
]
) – When starting from a previous
calculation, if the gap is less than 1st index, multiply the default
reciprocal_density by the 2nd index.
**kwargs
– Keywords supported by MPRelaxSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

copy_chgcar
:
bool
=
True
[source]

dedos
:
float
=
0.005
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
inherit_incar
:
bool
=
True
[source]

kpoints_line_density
:
float
=
20
[source]

property
kpoints_updates
:
dict
[
str
,
Any
]
[source]

Updates to the KPOINTS configuration for this calculation type.
mode
:
str
=
'line'
[source]

nbands_factor
:
float
=
1.2
[source]

nedos
:
int
=
2001
[source]

optics
:
bool
=
False
[source]

reciprocal_density
:
float
=
100
[source]

small_gap_multiply
:
tuple
[
float
,
float
]
|
None
=
None
[source]

class
MPRelaxSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
)
[source]

Bases:
VaspInputSet
Implementation of VaspInputSet utilizing parameters in the public
Materials Project. Typically, the pseudopotentials chosen contain more
electrons than the MIT parameters, and the k-point grid is ~50% more dense.
The LDAUU parameters are also different due to the different PSPs used,
which result in different fitted values.
Parameters
:
structure
(
Structure
) – The Structure to create inputs for. If None, the input
set is initialized without a Structure but one must be set separately before
the inputs are generated.
**kwargs
– Keywords supported by VaspInputSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

class
MPSOCSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
=
True
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
saxis:
tuple[int
,
int
,
int]
=
(0
,
0
,
1)
,
nbands_factor:
float
=
1.2
,
lepsilon:
bool
=
False
,
lcalcpol:
bool
=
False
,
reciprocal_density:
float
=
100
,
small_gap_multiply:
tuple[float
,
float]
|
None
=
None
,
magmom:
list[tuple[float
,
float
,
float]]
|
None
=
None
,
copy_chgcar:
bool
=
True
)
[source]

Bases:
VaspInputSet
An input set for running spin-orbit coupling (SOC) calculations.
Parameters
:
structure
(
Structure
) – the structure must have the ‘magmom’ site
property and each magnetic moment value must have 3
components. eg:
magmom
=
[[0,0,2],
...]
saxis
(
tuple
) – magnetic moment orientation
copy_chgcar
– Whether to copy the old CHGCAR. Defaults to True.
nbands_factor
(
float
) – Multiplicative factor for NBANDS. Choose a
higher number if you are doing an LOPTICS calculation.
reciprocal_density
(
int
) – density of k-mesh by reciprocal volume.
small_gap_multiply
(
[
float
,
float
]
) – If the gap is less than
1st index, multiply the default reciprocal_density by the 2nd
index.
lepsilon
(
bool
) – Whether to add static dielectric calculation
lcalcpol
(
bool
) – Whether to turn on evaluation of the Berry phase approximations
for electronic polarization
magmom
(
list
[
list
[
float
]
]
) – Override for the structure magmoms.
**kwargs
– Keywords supported by VaspInputSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

copy_chgcar
:
bool
=
True
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
inherit_incar
:
bool
=
True
[source]

property
kpoints_updates
:
dict
[
str
,
Any
]
[source]

Updates to the kpoints configuration for this calculation type.
lcalcpol
:
bool
=
False
[source]

lepsilon
:
bool
=
False
[source]

magmom
:
list
[
tuple
[
float
,
float
,
float
]
]
|
None
=
None
[source]

nbands_factor
:
float
=
1.2
[source]

reciprocal_density
:
float
=
100
[source]

saxis
:
tuple
[
int
,
int
,
int
]
=
(0,
0,
1)
[source]

small_gap_multiply
:
tuple
[
float
,
float
]
|
None
=
None
[source]

property
structure
:
Structure
|
None
[source]

Structure.
class
MPScanRelaxSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
'PBE_54'
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
True
,
auto_ismear:
bool
=
True
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
('PBE_52'
,
'PBE_54'
,
'PBE_64')
)
[source]

Bases:
VaspInputSet
Write a relaxation input set using the accurate and numerically
efficient r2SCAN variant of the Strongly Constrained and Appropriately Normed
(SCAN) metaGGA density functional.
Notes
1. This functional is officially supported in VASP 6.0.0 and above. On older version,
source code may be obtained by contacting the authors of the referenced manuscript.
The original SCAN functional, available from VASP 5.4.3 onwards, maybe used instead
by passing
user_incar_settings={“METAGGA”: “SCAN”}
when instantiating this InputSet.
r2SCAN and SCAN are expected to yield very similar results.
2. Meta-GGA calculations require POTCAR files that include
information on the kinetic energy density of the core-electrons,
i.e. “PBE_52”, “PBE_54” or “PBE_64”. Make sure the POTCARs include the
following lines (see VASP wiki for more details):
$ grep kinetic POTCAR
kinetic energy-density
mkinetic energy-density pseudized
kinetic energy density (partial)
Parameters
:
bandgap
(
float
) – Bandgap of the structure in eV. The bandgap is used to
compute the appropriate k-point density and determine the
smearing settings.
Metallic systems (default, bandgap = 0) use a KSPACING value of 0.22
and Methfessel-Paxton order 2 smearing (ISMEAR=2, SIGMA=0.2).
Non-metallic systems (bandgap > 0) use the tetrahedron smearing
method (ISMEAR=-5, SIGMA=0.05). The KSPACING value is
calculated from the bandgap via Eqs. 25 and 29 of Wisesa, McGill,
and Mueller [1] (see References). Note that if ‘user_incar_settings’
or ‘user_kpoints_settings’ override KSPACING, the calculation from
bandgap is not performed.
vdw
(
str
) – set “rVV10” to enable SCAN+rVV10, which is a versatile
van der Waals density functional by combing the SCAN functional
with the rVV10 non-local correlation functional. rvv10 is the only
dispersion correction available for SCAN at this time.
**kwargs
– Keywords supported by VaspInputSet.
References
P. Wisesa, K.A. McGill, T. Mueller, Efficient generation of
generalized Monkhorst-Pack grids through the use of informatics,
Phys. Rev. B. 93 (2016) 1-10. doi:10.1103/PhysRevB.93.155109.
James W. Furness, Aaron D. Kaplan, Jinliang Ning, John P. Perdew, and Jianwei Sun.
Accurate and Numerically Efficient r2SCAN Meta-Generalized Gradient Approximation.
The Journal of Physical Chemistry Letters 11, 8208-8215 (2022) DOI: 10.1021/acs.jpclett.0c02405
CONFIG
=
{'INCAR':
{'ALGO':
'ALL',
'EDIFF':
1e-05,
'EDIFFG':
-0.02,
'ENAUG':
1360,
'ENCUT':
680,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
0,
'ISPIN':
2,
'KSPACING':
0.22,
'LAECHG':
True,
'LASPH':
True,
'LCHARG':
True,
'LELF':
False,
'LMIXTAU':
True,
'LORBIT':
11,
'LREAL':
'Auto',
'LVTOT':
True,
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'METAGGA':
'R2SCAN',
'NELM':
200,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Am':
'Am',
'Ar':
'Ar',
'As':
'As',
'At':
'At',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cf':
'Cf',
'Cl':
'Cl',
'Cm':
'Cm',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Fr':
'Fr_sv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Po':
'Po_d',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Ra':
'Ra_sv',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Rn':
'Rn',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_sv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_3',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE_54'}
[source]

auto_ismear
:
bool
=
True
[source]

auto_kspacing
:
bool
=
True
[source]

bandgap
:
float
|
None
=
None
[source]

user_potcar_functional
:
UserPotcarFunctional
=
'PBE_54'
[source]

class
MPScanStaticSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
'PBE_54'
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
=
True
,
auto_kspacing:
bool
=
True
,
auto_ismear:
bool
=
True
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
('PBE_52'
,
'PBE_54'
,
'PBE_64')
,
lepsilon:
bool
=
False
,
lcalcpol:
bool
=
False
)
[source]

Bases:
MPScanRelaxSet
Create input files for a static calculation using the accurate and numerically
efficient r2SCAN variant of the Strongly Constrained and Appropriately Normed
(SCAN) metaGGA functional.
Parameters
:
structure
(
Structure
) – Structure from previous run.
bandgap
(
float
) – Bandgap of the structure in eV. The bandgap is used to
compute the appropriate k-point density and determine the smearing settings.
lepsilon
(
bool
) – Whether to add static dielectric calculation
lcalcpol
(
bool
) – Whether to turn on evaluation of the Berry phase approximations
for electronic polarization.
**kwargs
– Keywords supported by MPScanRelaxSet.
auto_kspacing
:
bool
=
True
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
inherit_incar
:
bool
=
True
[source]

lcalcpol
:
bool
=
False
[source]

lepsilon
:
bool
=
False
[source]

class
MPStaticSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
=
True
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
lepsilon:
bool
=
False
,
lcalcpol:
bool
=
False
,
reciprocal_density:
int
=
100
,
small_gap_multiply:
tuple[float
,
float]
|
None
=
None
)
[source]

Bases:
VaspInputSet
Create input files for a static calculation.
Parameters
:
structure
(
Structure
) – Structure from previous run.
lepsilon
(
bool
) – Whether to add static dielectric calculation
lcalcpol
(
bool
) – Whether to turn on evaluation of the Berry phase approximations
for electronic polarization
reciprocal_density
(
int
) – For static calculations, we usually set the
reciprocal density by volume. This is a convenience arg to change
that, rather than using user_kpoints_settings. Defaults to 100,
which is ~50% more than that of standard relaxation calculations.
small_gap_multiply
(
[
float
,
float
]
) – If the gap is less than
1st index, multiply the default reciprocal_density by the 2nd
index.
**kwargs
– Keywords supported by MPRelaxSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

property
incar_updates
:
dict
[source]

Updates to the INCAR config for this calculation type.
inherit_incar
:
bool
=
True
[source]

property
kpoints_updates
:
dict
|
Kpoints
[source]

Updates to the kpoints configuration for this calculation type.
lcalcpol
:
bool
=
False
[source]

lepsilon
:
bool
=
False
[source]

reciprocal_density
:
int
=
100
[source]

small_gap_multiply
:
tuple
[
float
,
float
]
|
None
=
None
[source]

class
MVLElasticSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
)
[source]

Bases:
VaspInputSet
MVL denotes VASP input sets that are implemented by the Materials Virtual
Lab (
https://materialsvirtuallab.org
) for various research.
This input set is used to calculate elastic constants in VASP. It is used
in the following work:
Z. Deng, Z. Wang, I.-H. Chu, J. Luo, S. P. Ong.
“Elastic Properties of Alkali Superionic Conductor Electrolytes
from First Principles Calculations”, J. Electrochem. Soc.
2016, 163(2), A67-A74. doi: 10.1149/2.0061602jes
To read the elastic constants, you may use the Outcar class which parses the
elastic constants.
Parameters
:
structure
(
pymatgen.Structure
) – Input structure.
potim
(
float
) – POTIM parameter. The default of 0.015 is usually fine,
but some structures may require a smaller step.
**kwargs
– Parameters supported by MPRelaxSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
potim
:
float
=
0.015
[source]

class
MVLGBSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
k_product:
int
=
40
,
slab_mode:
bool
=
False
,
is_metal:
bool
=
True
)
[source]

Bases:
VaspInputSet
Write a VASP input files for grain boundary calculations, slab or bulk.
Parameters
:
structure
(
Structure
) – provide the structure
k_product
– Kpoint number * length for a & b directions, also for c direction in
bulk calculations. Default to 40.
slab_mode
(
bool
) – Defaults to False. Use default (False) for a bulk supercell.
Use True if you are performing calculations on a slab-like (i.e., surface)
of the GB, for example, when you are calculating the work of separation.
is_metal
(
bool
) – Defaults to True. This determines whether an ISMEAR of 1 is
used (for metals) or not (for insulators and semiconductors) by default.
Note that it does
not
override user_incar_settings, which can be set by
the user to be anything desired.
**kwargs
– Other kwargs supported by MPRelaxSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
is_metal
:
bool
=
True
[source]

k_product
:
int
=
40
[source]

property
kpoints_updates
:
Kpoints
[source]

k_product is kpoint number * length for a & b directions, also for c direction
in bulk calculations Automatic mesh & Gamma is the default setting.
slab_mode
:
bool
=
False
[source]

class
MVLGWSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
True
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
=
True
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
reciprocal_density:
float
=
100
,
mode:
str
=
'STATIC'
,
copy_wavecar:
bool
=
True
,
nbands_factor:
int
=
5
,
ncores:
int
=
16
,
nbands:
int
|
None
=
None
)
[source]

Bases:
VaspInputSet
MVL denotes VASP input sets that are implemented by the Materials Virtual
Lab (
https://materialsvirtuallab.org
) for various research. This is a
flexible input set for GW calculations.
Note that unlike all other input sets in this module, the PBE_54 series of
functional is set as the default. These have much improved performance for
GW calculations.
A typical sequence is mode=”STATIC” -> mode=”DIAG” -> mode=”GW” ->
mode=”BSE”. For all steps other than the first one (static), the
recommendation is to use from_prev_calculation on the preceding run in
the series.
Parameters
:
structure
(
Structure
) – Input structure.
mode
(
str
) – Supported modes are “STATIC” (default), “DIAG”, “GW”,
and “BSE”.
nbands
(
int
) – For subsequent calculations, it is generally
recommended to perform NBANDS convergence starting from the
NBANDS of the previous run for DIAG, and to use the exact same
NBANDS for GW and BSE. This parameter is used by
from_previous_calculation to set nband.
copy_wavecar
– Whether to copy the old WAVECAR, WAVEDER and associated
files when starting from a previous calculation.
nbands_factor
(
int
) – Multiplicative factor for NBANDS when starting
from a previous calculation. Only applies if mode==”DIAG”.
Need to be tested for convergence.
reciprocal_density
(
int
) – Density of k-mesh by reciprocal atom. Only
applies if mode==”STATIC”. Defaults to 100.
ncores
(
int
) – Numbers of cores used for the calculation. VASP will alter
NBANDS if it was not dividable by ncores. Only applies if
mode==”DIAG”.
**kwargs
– All kwargs supported by VaspInputSet. Typically,
user_incar_settings is a commonly used option.
CONFIG
=
{'INCAR':
{'ALGO':
'Normal',
'EDIFF':
1e-08,
'IBRION':
-1,
'ICHARG':
1,
'ISMEAR':
0,
'ISPIN':
2,
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
True,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'PREC':
'Accurate',
'SIGMA':
0.01},
'KPOINTS':
{'reciprocal_density':
100},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag_sv_GW',
'Al':
'Al_GW',
'Ar':
'Ar_GW',
'As':
'As_GW',
'At':
'At_d_GW',
'Au':
'Au_sv_GW',
'B':
'B_GW',
'Ba':
'Ba_sv_GW',
'Be':
'Be_sv_GW',
'Bi':
'Bi_d_GW',
'Br':
'Br_GW',
'C':
'C_GW',
'Ca':
'Ca_sv_GW',
'Cd':
'Cd_sv_GW',
'Ce':
'Ce_GW',
'Cl':
'Cl_GW',
'Co':
'Co_sv_GW',
'Cr':
'Cr_sv_GW',
'Cs':
'Cs_sv_GW',
'Cu':
'Cu_sv_GW',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F_GW',
'Fe':
'Fe_sv_GW',
'Ga':
'Ga_d_GW',
'Gd':
'Gd',
'Ge':
'Ge_d_GW',
'H':
'H_GW',
'He':
'He_GW',
'Hf':
'Hf_sv_GW',
'Hg':
'Hg_sv_GW',
'Ho':
'Ho_3',
'I':
'I_GW',
'In':
'In_d_GW',
'Ir':
'Ir_sv_GW',
'K':
'K_sv_GW',
'Kr':
'Kr_GW',
'La':
'La_GW',
'Li':
'Li_sv_GW',
'Lu':
'Lu_3',
'Mg':
'Mg_sv_GW',
'Mn':
'Mn_sv_GW',
'Mo':
'Mo_sv_GW',
'N':
'N_GW',
'Na':
'Na_sv_GW',
'Nb':
'Nb_sv_GW',
'Nd':
'Nd_3',
'Ne':
'Ne_GW',
'Ni':
'Ni_sv_GW',
'Np':
'Np',
'O':
'O_GW',
'Os':
'Os_sv_GW',
'P':
'P_GW',
'Pa':
'Pa',
'Pb':
'Pb_d_GW',
'Pd':
'Pd_sv_GW',
'Pm':
'Pm_3',
'Po':
'Po_d_GW',
'Pr':
'Pr_3',
'Pt':
'Pt_sv_GW',
'Pu':
'Pu',
'Rb':
'Rb_sv_GW',
'Re':
'Re_sv_GW',
'Rh':
'Rh_sv_GW',
'Rn':
'Rn_d_GW',
'Ru':
'Ru_sv_GW',
'S':
'S_GW',
'Sb':
'Sb_d_GW',
'Sc':
'Sc_sv_GW',
'Se':
'Se_GW',
'Si':
'Si_GW',
'Sm':
'Sm_3',
'Sn':
'Sn_d_GW',
'Sr':
'Sr_sv_GW',
'Ta':
'Ta_sv_GW',
'Tb':
'Tb_3',
'Tc':
'Tc_sv_GW',
'Te':
'Te_GW',
'Th':
'Th',
'Ti':
'Ti_sv_GW',
'Tl':
'Tl_d_GW',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_sv_GW',
'W':
'W_sv_GW',
'Xe':
'Xe_GW',
'Y':
'Y_sv_GW',
'Yb':
'Yb_3',
'Zn':
'Zn_sv_GW',
'Zr':
'Zr_sv_GW'},
'POTCAR_FUNCTIONAL':
'PBE_54'}
[source]

SUPPORTED_MODES
=
('DIAG',
'GW',
'STATIC',
'BSE')
[source]

copy_wavecar
:
bool
=
True
[source]

force_gamma
:
bool
=
True
[source]

classmethod
from_prev_calc
(
prev_calc_dir
:
PathLike
,
mode
:
str
=
'DIAG'
,
**
kwargs
)
→
Self
[source]

Generate a set of VASP input files for GW or BSE calculations from a
directory of previous Exact Diag VASP run.
Parameters
:
prev_calc_dir
(
PathLike
) – The directory contains the outputs(
vasprun.xml of previous VASP run.
mode
(
str
) – Supported modes are “STATIC”, “DIAG” (default), “GW”,
and “BSE”.
**kwargs
– All kwargs supported by MVLGWSet, other than structure,
prev_incar and mode, which are determined from the
prev_calc_dir.
property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
inherit_incar
:
bool
=
True
[source]

property
kpoints_updates
:
dict
[
str
,
Any
]
[source]

Updates to the kpoints configuration for this calculation type.
mode
:
str
=
'STATIC'
[source]

nbands
:
int
|
None
=
None
[source]

nbands_factor
:
int
=
5
[source]

ncores
:
int
=
16
[source]

reciprocal_density
:
float
=
100
[source]

class
MVLNPTMDSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
start_temp:
float
=
0.0
,
end_temp:
float
=
300.0
,
nsteps:
int
=
1000
,
time_step:
float
=
2
,
spin_polarized:
bool
=
False
)
[source]

Bases:
VaspInputSet
Write a VASP MD run in NPT ensemble.
Notes
To eliminate Pulay stress, the default ENCUT is set to a rather large
value of ENCUT, which is 1.5 * ENMAX.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF':
1e-05,
'ENCUT':
520,
'IBRION':
2,
'ICHARG':
1,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'ISYM':
0,
'LDAU':
True,
'LDAUJ':
{'F':
{'Ag':
0,
'Co':
0,
'Cr':
0,
'Cu':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Nb':
0,
'Ni':
0,
'Re':
0,
'Ta':
0,
'V':
0,
'W':
0},
'O':
{'Ag':
0,
'Co':
0,
'Cr':
0,
'Cu':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Nb':
0,
'Ni':
0,
'Re':
0,
'Ta':
0,
'V':
0,
'W':
0},
'S':
{'Fe':
0,
'Mn':
0}},
'LDAUL':
{'F':
{'Ag':
2,
'Co':
2,
'Cr':
2,
'Cu':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Nb':
2,
'Ni':
2,
'Re':
2,
'Ta':
2,
'V':
2,
'W':
2},
'O':
{'Ag':
2,
'Co':
2,
'Cr':
2,
'Cu':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Nb':
2,
'Ni':
2,
'Re':
2,
'Ta':
2,
'V':
2,
'W':
2},
'S':
{'Fe':
2,
'Mn':
2.5}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Ag':
1.5,
'Co':
3.4,
'Cr':
3.5,
'Cu':
4,
'Fe':
4.0,
'Mn':
3.9,
'Mo':
4.38,
'Nb':
1.5,
'Ni':
6,
'Re':
2,
'Ta':
2,
'V':
3.1,
'W':
4.0},
'O':
{'Ag':
1.5,
'Co':
3.4,
'Cr':
3.5,
'Cu':
4,
'Fe':
4.0,
'Mn':
3.9,
'Mo':
4.38,
'Nb':
1.5,
'Ni':
6,
'Re':
2,
'Ta':
2,
'V':
3.1,
'W':
4.0},
'S':
{'Fe':
1.9,
'Mn':
2.5}},
'LORBIT':
'11',
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
200,
'NELMIN':
6,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'length':
25},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
{'hash':
'd6854224d20e3de6e6fd7399503791d1',
'symbol':
'Ac'},
'Ag':
{'hash':
'e8ffa02fe3f3a51338ac1ac91ae968b9',
'symbol':
'Ag'},
'Al':
{'hash':
'a6fd9a46aec185f4ad2acd0cbe4ae2fa',
'symbol':
'Al'},
'Ar':
{'hash':
'e782fc6292623b396091bf8b871c272f',
'symbol':
'Ar'},
'As':
{'hash':
'8005364db225a254e52cba350bedd032',
'symbol':
'As'},
'Au':
{'hash':
'a9182d436a13194b744640ac940ab9b0',
'symbol':
'Au'},
'B':
{'hash':
'18ed2875dfa6305324cec3d7d59273ae',
'symbol':
'B'},
'Ba':
{'hash':
'c0477913afb63dfae3439f3534fbf0ed',
'symbol':
'Ba_sv'},
'Be':
{'hash':
'fb974e44d56a8c62c6bbd1a1eb70c3a7',
'symbol':
'Be'},
'Bi':
{'hash':
'e29661c79d59abae3b3ba69eae24b1a5',
'symbol':
'Bi'},
'Br':
{'hash':
'40f9594b4506684a69158c8975cfb9d6',
'symbol':
'Br'},
'C':
{'hash':
'c0a8167dbb174fe492a3db7f5006c0f8',
'symbol':
'C'},
'Ca':
{'hash':
'eb006721e214c04b3c13146e81b3a27d',
'symbol':
'Ca_sv'},
'Cd':
{'hash':
'0506b2d0ac28d5fe2b5ced77a701aa86',
'symbol':
'Cd'},
'Ce':
{'hash':
'ff3a09f2ff91798e58eb4b9854e9be4a',
'symbol':
'Ce'},
'Cl':
{'hash':
'779b9901046c78fe51c5d80224642aeb',
'symbol':
'Cl'},
'Co':
{'hash':
'b169bca4e137294d2ab3df8cbdd09083',
'symbol':
'Co'},
'Cr':
{'hash':
'82c14307937c7509fda4e9bc023d243d',
'symbol':
'Cr'},
'Cs':
{'hash':
'096b53a7d80cc0086976bcda50d536e5',
'symbol':
'Cs_sv'},
'Cu':
{'hash':
'8ca4e43a30de0c397e51f16bbb20d678',
'symbol':
'Cu'},
'Dy':
{'hash':
'd4a05220ab0a2d4c03a76872ea724a1e',
'symbol':
'Dy_3'},
'Er':
{'hash':
'daa65a04877317f8c3c593ddeaa8a132',
'symbol':
'Er_3'},
'Eu':
{'hash':
'd466d046adf21f6146ee9644049ea268',
'symbol':
'Eu'},
'F':
{'hash':
'180141c33d032bfbfff30b3bea9d23dd',
'symbol':
'F'},
'Fe':
{'hash':
'9530da8244e4dac17580869b4adab115',
'symbol':
'Fe'},
'Ga':
{'hash':
'6e0b9d58412b1bfcd7252aff13d476c2',
'symbol':
'Ga'},
'Gd':
{'hash':
'1f0d42b1e5f6769d319d3f247992aeb9',
'symbol':
'Gd'},
'Ge':
{'hash':
'79e788788c31e196a460553010512d3f',
'symbol':
'Ge'},
'H':
{'hash':
'bb43c666e3d36577264afe07669e9582',
'symbol':
'H'},
'He':
{'hash':
'47f9434aa3db96c85d7c4b3e4c2df09b',
'symbol':
'He'},
'Hf':
{'hash':
'b113f150cbf9c736f8244a6c25b0482e',
'symbol':
'Hf'},
'Hg':
{'hash':
'c2f15dfb5fd53396c5427635e5019160',
'symbol':
'Hg'},
'Ho':
{'hash':
'661891464a27e87cf7e1324dd1893b77',
'symbol':
'Ho_3'},
'I':
{'hash':
'f4ff16a495dd361ff5824ee61b418bb0',
'symbol':
'I'},
'In':
{'hash':
'7df38c0cdb4e6d9a9b93f09d690bb3ae',
'symbol':
'In'},
'Ir':
{'hash':
'dbcf7dcc6f4fb40df7b3d26904f60a66',
'symbol':
'Ir'},
'K':
{'hash':
'3e84f86d37f203a4fb01de36af57e430',
'symbol':
'K_sv'},
'Kr':
{'hash':
'39b9b85ae3982e6c012fb549b2840ce5',
'symbol':
'Kr'},
'La':
{'hash':
'9b3ce03d18f7c0b40471a817ff91b287',
'symbol':
'La'},
'Li':
{'hash':
'65e83282d1707ec078c1012afbd05be8',
'symbol':
'Li'},
'Lu':
{'hash':
'd40a90babf1224b88ffb4c3273ac3848',
'symbol':
'Lu_3'},
'Mg':
{'hash':
'1771eb72adbbfa6310d66e7517e49930',
'symbol':
'Mg'},
'Mn':
{'hash':
'd082dba29b57ab59b3165e605dbf71b8',
'symbol':
'Mn'},
'Mo':
{'hash':
'84e18fd84a98e3d7fa8f055952410df0',
'symbol':
'Mo_pv'},
'N':
{'hash':
'b98fd027ddebc67da4063ff2cabbc04b',
'symbol':
'N'},
'Na':
{'hash':
'1a89e79f7e21d99e8cf5788979f6a987',
'symbol':
'Na'},
'Nb':
{'hash':
'7bcee99a4dc3094be0f9fd7961c02966',
'symbol':
'Nb_pv'},
'Nd':
{'hash':
'0c64e63070cee837c967283fffa001df',
'symbol':
'Nd'},
'Ne':
{'hash':
'52064eee378b9e37a295a674f1c278f0',
'symbol':
'Ne'},
'Ni':
{'hash':
'653f5772e68b2c7fd87ffd1086c0d710',
'symbol':
'Ni'},
'Np':
{'hash':
'20cb30b714200c4db870550b288ac4cd',
'symbol':
'Np'},
'O':
{'hash':
'7a25bc5b9a5393f46600a4939d357982',
'symbol':
'O'},
'Os':
{'hash':
'35c2cb48d48a9c38c40fb82bbe70626d',
'symbol':
'Os'},
'P':
{'hash':
'7dc3393307131ae67785a0cdacb61d5f',
'symbol':
'P'},
'Pa':
{'hash':
'a1fdb1089d0727f415416ec8082246ba',
'symbol':
'Pa'},
'Pb':
{'hash':
'704c2c967247d7f84090d2536c91877d',
'symbol':
'Pb'},
'Pd':
{'hash':
'a395eb3aaf2fcab12fac3030a1146f61',
'symbol':
'Pd'},
'Pm':
{'hash':
'a2c9485ea86b2a7cf175077e6e5c7b3e',
'symbol':
'Pm'},
'Pr':
{'hash':
'92f191499bf5346ea652bb806350ad87',
'symbol':
'Pr'},
'Pt':
{'hash':
'a604ea3c6a9cc23c739b762f625cf449',
'symbol':
'Pt'},
'Pu':
{'hash':
'f1d01e845dccc52d448679911f301a73',
'symbol':
'Pu'},
'Rb':
{'hash':
'e447c648d870b066b3514e6b800727ab',
'symbol':
'Rb_pv'},
'Re':
{'hash':
'72385e193c92a8acfe17ea49004c2be1',
'symbol':
'Re'},
'Rh':
{'hash':
'2c3dba3fcc6058ca1b1cfa75e45084bc',
'symbol':
'Rh'},
'Ru':
{'hash':
'7925f4d4b68076d70af7cd86eef9ba8d',
'symbol':
'Ru_pv'},
'S':
{'hash':
'd368db6899d8839859bbee4811a42a88',
'symbol':
'S'},
'Sb':
{'hash':
'd82c022b02fc5344e85bd1909f9ee3e7',
'symbol':
'Sb'},
'Sc':
{'hash':
'dc386f505ad0c43385a7715b4111cb75',
'symbol':
'Sc_sv'},
'Se':
{'hash':
'67a8804ede9f1112726e3d136978ef19',
'symbol':
'Se'},
'Si':
{'hash':
'b2b0ea6feb62e7cde209616683b8f7f5',
'symbol':
'Si'},
'Sm':
{'hash':
'e5e274e7cd99602ca81d146155abdf88',
'symbol':
'Sm_3'},
'Sn':
{'hash':
'849b0795e148f93113a06be8fd5f5001',
'symbol':
'Sn_d'},
'Sr':
{'hash':
'ca6a5429c120a0ab705824386a76fe5b',
'symbol':
'Sr_sv'},
'Ta':
{'hash':
'd4e2cfe9338ef80da592d5bb9dc782c7',
'symbol':
'Ta'},
'Tb':
{'hash':
'0790955c547003956c0fd4f080f7f508',
'symbol':
'Tb_3'},
'Tc':
{'hash':
'9592642886319309a39d55c5717c6f48',
'symbol':
'Tc'},
'Te':
{'hash':
'72719856e22fb1d3032df6f96d98a0f2',
'symbol':
'Te'},
'Th':
{'hash':
'aea79f322180fa6f0bfa74cb2a156dcf',
'symbol':
'Th'},
'Ti':
{'hash':
'c617e8b539c3f44a0ab6e8da2a92d318',
'symbol':
'Ti'},
'Tl':
{'hash':
'2aa0d5406aaab7ebfbc761da382f1352',
'symbol':
'Tl'},
'Tm':
{'hash':
'94a07cb7949b01305cb161da0cbfb492',
'symbol':
'Tm_3'},
'U':
{'hash':
'72702eabbb1bc02b4167590dc848ed5d',
'symbol':
'U'},
'V':
{'hash':
'7f1297a2e1d963e2a4d81b61f85e4ded',
'symbol':
'V_pv'},
'W':
{'hash':
'2a33e0d5c700640535f60ac0a12177ab',
'symbol':
'W_pv'},
'Xe':
{'hash':
'338472e581f58b41d37c002a5e22353b',
'symbol':
'Xe'},
'Y':
{'hash':
'4ed187e77cd54f198bb88020278b143d',
'symbol':
'Y_sv'},
'Yb':
{'hash':
'9f472bd422f640710f7d93e2d9ce89f4',
'symbol':
'Yb'},
'Zn':
{'hash':
'e35ee27f8483a63bb68dbc236a343af3',
'symbol':
'Zn'},
'Zr':
{'hash':
'd221d2c0bac4f8e81af2f5c42a314274',
'symbol':
'Zr'}},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

end_temp
:
float
=
300.0
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
property
kpoints_updates
:
Kpoints
[source]

Updates to the kpoints configuration for this calculation type.
nsteps
:
int
=
1000
[source]

spin_polarized
:
bool
=
False
[source]

start_temp
:
float
=
0.0
[source]

time_step
:
float
=
2
[source]

class
MVLRelax52Set
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
'PBE_52'
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
('PBE_52'
,
'PBE_54'
,
'PBE_64')
)
[source]

Bases:
VaspInputSet
Implementation of VaspInputSet utilizing the public Materials Project
parameters for INCAR & KPOINTS and VASP’s recommended PAW potentials for
POTCAR.
Keynotes from VASP manual:
Recommended potentials for calculations using VASP.5.2+
If dimers with short bonds are present in the compound (O2, CO,
N2, F2, P2, S2, Cl2), it is recommended to use the h potentials.
Specifically, C_h, O_h, N_h, F_h, P_h, S_h, Cl_h
Released on Oct 28, 2018 by VASP. Please refer to VASP
Manual 1.2, 1.3 & 10.2.1 for more details.
Parameters
:
structure
(
Structure
) – input structure.
user_potcar_functional
(
str
) – choose from “PBE_52”, “PBE_54” and “PBE_64”.
**kwargs
– Other kwargs supported by VaspInputSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ICHARG':
1,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Am':
'Am',
'Ar':
'Ar',
'As':
'As',
'At':
'At_d',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be',
'Bi':
'Bi_d',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Cm':
'Cm',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu_2',
'F':
'F',
'Fe':
'Fe',
'Fr':
'Fr_sv',
'Ga':
'Ga_d',
'Gd':
'Gd_3',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg',
'Mn':
'Mn_pv',
'Mo':
'Mo_sv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_sv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni',
'Np':
'Np',
'O':
'O',
'Os':
'Os',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Po':
'Po_d',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Ra':
'Ra_sv',
'Rb':
'Rb_sv',
'Re':
'Re',
'Rh':
'Rh_pv',
'Rn':
'Rn',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_sv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_sv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE_52'}
[source]

user_potcar_functional
:
UserPotcarFunctional
=
'PBE_52'
[source]

class
MVLScanRelaxSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
'PBE_52'
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
('PBE_52'
,
'PBE_54'
,
'PBE_64')
)
[source]

Bases:
VaspInputSet
Write a relax input set using Strongly Constrained and
Appropriately Normed (SCAN) semilocal density functional.
Notes
This functional is only available from VASP.5.4.3 upwards.
2. Meta-GGA calculations require POTCAR files that include
information on the kinetic energy density of the core-electrons,
i.e. “PBE_52”, “PBE_54” or “PBE_64”. Make sure the POTCAR including the
following lines (see VASP wiki for more details):
$ grep kinetic POTCAR
kinetic energy-density
mkinetic energy-density pseudized
kinetic energy density (partial)
Parameters
:
structure
(
Structure
) – input structure.
vdw
(
str
) – set “rVV10” to enable SCAN+rVV10, which is a versatile
van der Waals density functional by combing the SCAN functional
with the rVV10 non-local correlation functional.
**kwargs
– Other kwargs supported by VaspInputSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
user_potcar_functional
:
UserPotcarFunctional
=
'PBE_52'
[source]

class
MVLSlabSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
k_product:
int
=
50
,
bulk:
bool
=
False
,
auto_dipole:
bool
=
False
,
set_mix:
bool
=
True
)
[source]

Bases:
VaspInputSet
Write a set of slab VASP runs, including both slabs (along the c direction)
and orient unit cells (bulk), to ensure the same KPOINTS, POTCAR and INCAR criterion.
Parameters
:
structure
– Structure
k_product
– default to 50, kpoint number * length for a & b
directions, also for c direction in bulk calculations
bulk
auto_dipole
set_mix
sort_structure
**kwargs
– Other kwargs supported by VaspInputSet.
CONFIG
=
{'INCAR':
{'ALGO':
'FAST',
'EDIFF_PER_ATOM':
5e-05,
'ENCUT':
520,
'IBRION':
2,
'ISIF':
3,
'ISMEAR':
-5,
'ISPIN':
2,
'LASPH':
True,
'LDAU':
True,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUPRINT':
1,
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LORBIT':
11,
'LREAL':
'AUTO',
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
100,
'NSW':
99,
'PREC':
'Accurate',
'SIGMA':
0.05},
'KPOINTS':
{'reciprocal_density':
64},
'PARENT':
'VASPIncarBase',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Ar':
'Ar',
'As':
'As',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cl':
'Cl',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_3',
'Er':
'Er_3',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_3',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_3',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_3',
'Pr':
'Pr_3',
'Pt':
'Pt',
'Pu':
'Pu',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_3',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_3',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_3',
'U':
'U',
'V':
'V_pv',
'W':
'W_pv',
'Xe':
'Xe',
'Y':
'Y_sv',
'Yb':
'Yb_2',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE'}
[source]

as_dict
(
verbosity
:
int
=
2
)
→
dict
[
str
,
Any
]
[source]

Parameters
:
verbosity
(
int
) – Verbosity of dict. e.g. whether to include Structure.
Returns
:
MSONable MVLGBSet representation.
Return type
:
dict
auto_dipole
:
bool
=
False
[source]

bulk
:
bool
=
False
[source]

property
incar_updates
:
dict
[
str
,
Any
]
[source]

Updates to the INCAR config for this calculation type.
k_product
:
int
=
50
[source]

property
kpoints_updates
:
Kpoints
[source]

Updates to the kpoints configuration for this calculation type.
k_product, default to 50, is kpoint number * length for a & b
directions, also for c direction in bulk calculations
Automatic mesh & Gamma is the default setting.
set_mix
:
bool
=
True
[source]

class
MatPESStaticSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
tuple[str
,
...]
|
bool
=
('LPEAD'
,
'NGX'
,
'NGY'
,
'NGZ'
,
'SYMPREC'
,
'IMIX'
,
'LMAXMIX'
,
'KGAMMA'
,
'ISYM'
,
'NCORE'
,
'NPAR'
,
'NELMIN'
,
'IOPT'
,
'NBANDS'
,
'KPAR'
,
'AMIN'
,
'NELMDL'
,
'BMIX'
,
'AMIX_MAG'
,
'BMIX_MAG')
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
dict
|
str
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
,
xc_functional:
Literal['R2SCAN'
,
'PBE'
,
'PBE+U']
=
'PBE'
)
[source]

Bases:
VaspInputSet
Create input files for a MatPES static calculation.
The goal of MatPES is to generate potential energy surface data. This is a distinctly different
from the objectives of the MP static calculations, which aims to obtain primarily accurate
energies and also electronic structure (DOS). For PES data, force accuracy (and to some extent,
stress accuracy) is of paramount importance.
The default POTCAR versions have been updated to PBE_54 from the old PBE set used in the
MPStaticSet. However,
U values
are still based on PBE. The implicit assumption here is that
the PBE_54 and PBE POTCARs are sufficiently similar that the U values fitted to the old PBE
functional still applies.
Parameters
:
structure
(
Structure
) – The Structure to create inputs for. If None, the input
set is initialized without a Structure but one must be set separately before
the inputs are generated.
xc_functional
(
'R2SCAN'
|
'PBE'
) – Exchange-correlation functional to use. Defaults to ‘PBE’.
**kwargs
– Keywords supported by VaspInputSet.
CONFIG
=
{'INCAR':
{'ALGO':
'Normal',
'EDIFF':
1e-05,
'ENAUG':
1360,
'ENCUT':
680,
'GGA':
'PE',
'ISMEAR':
0,
'ISPIN':
2,
'KSPACING':
0.22,
'LAECHG':
True,
'LASPH':
True,
'LCHARG':
True,
'LDAU':
False,
'LDAUJ':
{'F':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0},
'O':
{'Co':
0,
'Cr':
0,
'Fe':
0,
'Mn':
0,
'Mo':
0,
'Ni':
0,
'V':
0,
'W':
0}},
'LDAUL':
{'F':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2},
'O':
{'Co':
2,
'Cr':
2,
'Fe':
2,
'Mn':
2,
'Mo':
2,
'Ni':
2,
'V':
2,
'W':
2}},
'LDAUTYPE':
2,
'LDAUU':
{'F':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2},
'O':
{'Co':
3.32,
'Cr':
3.7,
'Fe':
5.3,
'Mn':
3.9,
'Mo':
4.38,
'Ni':
6.2,
'V':
3.25,
'W':
6.2}},
'LMAXMIX':
6,
'LMIXTAU':
True,
'LORBIT':
11,
'LREAL':
False,
'LWAVE':
False,
'MAGMOM':
{'Ce':
5,
'Ce3+':
1,
'Co':
0.6,
'Co3+':
0.6,
'Co4+':
1,
'Cr':
5,
'Dy3+':
5,
'Er3+':
3,
'Eu':
10,
'Eu2+':
7,
'Eu3+':
6,
'Fe':
5,
'Gd3+':
7,
'Ho3+':
4,
'La3+':
0.6,
'Lu3+':
0.6,
'Mn':
5,
'Mn3+':
4,
'Mn4+':
3,
'Mo':
5,
'Nd3+':
3,
'Ni':
5,
'Pm3+':
4,
'Pr3+':
2,
'Sm3+':
5,
'Tb3+':
6,
'Tm3+':
2,
'V':
5,
'W':
5,
'Yb3+':
1},
'NELM':
200,
'NSW':
0,
'PREC':
'Accurate',
'SIGMA':
0.05},
'PARENT':
'PBE64Base',
'POTCAR':
{'Ac':
'Ac',
'Ag':
'Ag',
'Al':
'Al',
'Am':
'Am',
'Ar':
'Ar',
'As':
'As',
'At':
'At',
'Au':
'Au',
'B':
'B',
'Ba':
'Ba_sv_GW',
'Be':
'Be_sv',
'Bi':
'Bi',
'Br':
'Br',
'C':
'C',
'Ca':
'Ca_sv',
'Cd':
'Cd',
'Ce':
'Ce',
'Cf':
'Cf',
'Cl':
'Cl',
'Cm':
'Cm',
'Co':
'Co',
'Cr':
'Cr_pv',
'Cs':
'Cs_sv',
'Cu':
'Cu_pv',
'Dy':
'Dy_h',
'Er':
'Er_h',
'Eu':
'Eu',
'F':
'F',
'Fe':
'Fe_pv',
'Fr':
'Fr_sv',
'Ga':
'Ga_d',
'Gd':
'Gd',
'Ge':
'Ge_d',
'H':
'H',
'He':
'He',
'Hf':
'Hf_pv',
'Hg':
'Hg',
'Ho':
'Ho_h',
'I':
'I',
'In':
'In_d',
'Ir':
'Ir',
'K':
'K_sv',
'Kr':
'Kr',
'La':
'La',
'Li':
'Li_sv',
'Lu':
'Lu_3',
'Mg':
'Mg_pv',
'Mn':
'Mn_pv',
'Mo':
'Mo_pv',
'N':
'N',
'Na':
'Na_pv',
'Nb':
'Nb_pv',
'Nd':
'Nd_h',
'Ne':
'Ne',
'Ni':
'Ni_pv',
'Np':
'Np',
'O':
'O',
'Os':
'Os_pv',
'P':
'P',
'Pa':
'Pa',
'Pb':
'Pb_d',
'Pd':
'Pd',
'Pm':
'Pm_h',
'Po':
'Po_d',
'Pr':
'Pr_h',
'Pt':
'Pt',
'Pu':
'Pu',
'Ra':
'Ra_sv',
'Rb':
'Rb_sv',
'Re':
'Re_pv',
'Rh':
'Rh_pv',
'Rn':
'Rn',
'Ru':
'Ru_pv',
'S':
'S',
'Sb':
'Sb',
'Sc':
'Sc_sv',
'Se':
'Se',
'Si':
'Si',
'Sm':
'Sm_h',
'Sn':
'Sn_d',
'Sr':
'Sr_sv',
'Ta':
'Ta_pv',
'Tb':
'Tb_h',
'Tc':
'Tc_pv',
'Te':
'Te',
'Th':
'Th',
'Ti':
'Ti_pv',
'Tl':
'Tl_d',
'Tm':
'Tm_h',
'U':
'U',
'V':
'V_pv',
'W':
'W_sv',
'Xe':
'Xe_GW',
'Y':
'Y_sv',
'Yb':
'Yb_h',
'Zn':
'Zn',
'Zr':
'Zr_sv'},
'POTCAR_FUNCTIONAL':
'PBE_64'}
[source]

inherit_incar
:
tuple
[
str
,
...
]
|
bool
=
('LPEAD',
'NGX',
'NGY',
'NGZ',
'SYMPREC',
'IMIX',
'LMAXMIX',
'KGAMMA',
'ISYM',
'NCORE',
'NPAR',
'NELMIN',
'IOPT',
'NBANDS',
'KPAR',
'AMIN',
'NELMDL',
'BMIX',
'AMIX_MAG',
'BMIX_MAG')
[source]

prev_incar
:
dict
|
str
|
None
=
None
[source]

xc_functional
:
Literal
[
'R2SCAN'
,
'PBE'
,
'PBE+U'
]
=
'PBE'
[source]

class
NEBSet
(
structures
:
list
[
Structure
]
,
unset_encut
:
bool
=
False
,
parent_set
=
'MPRelaxSet'
,
**
kwargs
)
[source]

Bases:
VaspInputSet
An input set for NEB calculations. These are based on NEB parameters that have been extensively tested by the
Materials Virtual Lab.
Note that EDIFF is not on a per atom basis for this input set.
Parameters
:
structures
– List of Structure objects.
unset_encut
(
bool
) – Whether to unset ENCUT.
parent_set
(
str
) – The parent input set to inherit from. Defaults to MPRelaxSet. This should be a string
name to support MSONable.
**kwargs
– Other kwargs supported by VaspInputSet.
property
poscar
:
Poscar
[source]

Poscar for structure of first end point.
property
poscars
:
list
[
Poscar
]
[source]

List of Poscars.
write_input
(
output_dir
:
PathLike
,
make_dir_if_not_present
:
bool
=
True
,
write_cif
:
bool
=
False
,
write_path_cif
:
bool
=
False
,
write_endpoint_inputs
:
bool
=
False
)
→
None
[source]

NEB inputs has a special directory structure where inputs are in 00,
01, 02, ….
Parameters
:
output_dir
(
PathLike
) – Directory to output the VASP input files
make_dir_if_not_present
(
bool
) – Set to True if you want the
directory (and the whole path) to be created if it is not
present.
write_cif
(
bool
) – If true, writes a CIF along with each POSCAR.
write_path_cif
(
bool
) – If true, writes a CIF for each image.
write_endpoint_inputs
(
bool
) – If true, writes input files for
running endpoint calculations.
VaspInputGenerator
[source]

alias of
VaspInputSet
class
VaspInputSet
(
structure:
Structure
|
None
=
<property
object>
,
config_dict:
dict
=
<factory>
,
files_to_transfer:
dict
=
<factory>
,
user_incar_settings:
dict
=
<factory>
,
user_kpoints_settings:
dict
=
<factory>
,
user_potcar_settings:
dict
=
<factory>
,
constrain_total_magmom:
bool
=
False
,
sort_structure:
bool
=
True
,
user_potcar_functional:
UserPotcarFunctional
=
None
,
force_gamma:
bool
=
False
,
reduce_structure:
Literal['niggli'
,
'LLL']
|
None
=
None
,
vdw:
str
|
None
=
None
,
use_structure_charge:
bool
=
False
,
standardize:
bool
=
False
,
sym_prec:
float
=
0.1
,
international_monoclinic:
bool
=
True
,
validate_magmom:
bool
=
True
,
inherit_incar:
bool
|
list[str]
=
False
,
auto_kspacing:
bool
=
False
,
auto_ismear:
bool
=
False
,
auto_ispin:
bool
=
False
,
auto_lreal:
bool
=
False
,
auto_metal_kpoints:
bool
=
False
,
bandgap_tol:
float
=
0.0001
,
bandgap:
float
|
None
=
None
,
prev_incar:
str
|
dict
|
None
=
None
,
prev_kpoints:
str
|
Kpoints
|
None
=
None
,
_valid_potcars:
Sequence[str]
|
None
=
None
)
[source]

Bases:
InputGenerator
,
ABC
Base class representing a set of VASP input parameters with a structure
supplied as init parameters and initialized from a dict of settings.
This allows arbitrary settings to be input. In general,
this is rarely used directly unless there is a source of settings in yaml
format (e.g., from a REST interface). It is typically used by other
VaspInputSets for initialization.
Special consideration should be paid to the way the MAGMOM initialization
for the INCAR is done. The initialization differs depending on the type of
structure and the configuration settings. The order in which the magmom is
determined is as follows:
If the site is specified in user_incar_settings, use that setting.
If the site itself has a magmom setting (i.e. site.properties[“magmom”] = float),
that is used. This can be set with structure.add_site_property().
If the species of the site has a spin setting, that is used. This can be set
with structure.add_spin_by_element().
If the species itself has a particular setting in the config file, that
is used, e.g. Mn3+ may have a different magmom than Mn4+.
Lastly, the element symbol itself is checked in the config file. If
there are no settings, a default value of 0.6 is used.
Parameters
:
structure
(
Structure
) – The Structure to create inputs for. If None, the input
set is initialized without a Structure but one must be set separately before
the inputs are generated.
config_dict
(
dict
) – The config dictionary to use.
files_to_transfer
(
dict
) – A dictionary of {filename: filepath}. This allows the
transfer of files from a previous calculation.
user_incar_settings
(
dict
) – User INCAR settings. This allows a user to override
INCAR settings, e.g. setting a different MAGMOM for various elements or
species. Note that in the new scheme, ediff_per_atom and hubbard_u are no
longer args. Instead, the CONFIG supports EDIFF_PER_ATOM and EDIFF keys.
The former scales with # of atoms, the latter does not. If both are present,
EDIFF is preferred. To force such settings, just supply
user_incar_settings={“EDIFF”: 1e-5, “LDAU”: False} for example. The keys
‘LDAUU’, ‘LDAUJ’, ‘LDAUL’ are special cases since pymatgen defines different
values depending on what anions are present in the structure, so these keys
can be defined in one of two ways, e.g. either {“LDAUU”:{“O”:{“Fe”:5}}} to
set LDAUU for Fe to 5 in an oxide, or {“LDAUU”:{“Fe”:5}} to set LDAUU to 5
regardless of the input structure. If a None value is given, that key is
unset. For example, {“ENCUT”: None} will remove ENCUT from the
incar settings. Finally, KSPACING is a special setting and can be set to
“auto” in which the KSPACING is set automatically based on the band gap.
user_kpoints_settings
(
dict
or
Kpoints
) – Allow user to override kpoints setting
by supplying a dict. e.g. {“reciprocal_density”: 1000}. User can also
supply Kpoints object.
user_potcar_settings
(
dict
) – Allow user to override POTCARs. e.g. {“Gd”:
“Gd_3”}. This is generally not recommended.
constrain_total_magmom
(
bool
) – Whether to constrain the total magmom (NUPDOWN in
INCAR) to be the sum of the expected MAGMOM for all species.
sort_structure
(
bool
) – Whether to sort the structure (using the default sort
order of electronegativity) before generating input files. Defaults to True,
the behavior you would want most of the time. This ensures that similar
atomic species are grouped together.
user_potcar_functional
(
str
) – Functional to use. Default (None) is to use the
functional in the config dictionary. Valid values: “PBE”, “PBE_52”,
“PBE_54”, “PBE_64”, “LDA”, “LDA_52”, “LDA_54”, “PW91”, “LDA_US”, “PW91_US”.
force_gamma
(
bool
) – Force gamma centered kpoint generation. Default (False) is
to use the Automatic Density kpoint scheme, which will use the Gamma
centered generation scheme for hexagonal cells, and Monkhorst-Pack otherwise.
reduce_structure
(
None/str
) – Before generating the input files, generate the
reduced structure. Default (None), does not alter the structure. Valid
values: None, “niggli”, “LLL”.
vdw
– Adds default parameters for van-der-Waals functionals supported by VASP to
INCAR. Supported functionals are: DFT-D2, undamped DFT-D3, DFT-D3 with
Becke-Jonson damping, Tkatchenko-Scheffler, Tkatchenko-Scheffler with
iterative Hirshfeld partitioning,
MBD
@
rSC
, dDsC, Dion’s vdW-DF, DF2, optPBE,
optB88, optB86b and rVV10.
use_structure_charge
(
bool
) – If set to True, then the overall charge of the
structure (structure.charge) is used to set the NELECT variable in the
INCAR. Default is False.
standardize
(
float
) – Whether to standardize to a primitive standard cell.
Defaults to False.
sym_prec
(
float
) – Tolerance for symmetry finding.
international_monoclinic
(
bool
) – Whether to use international convention (vs
Curtarolo) for monoclinic. Defaults True.
validate_magmom
(
bool
) – Ensure that the missing magmom values are filled in with
the VASP default value of 1.0.
inherit_incar
(
bool
) – Whether to inherit INCAR settings from previous
calculation. This might be useful to port Custodian fixes to child jobs but
can also be dangerous e.g. when switching from GGA to meta-GGA or relax to
static jobs. Defaults to True.
auto_kspacing
(
bool
) – If true, determines the value of KSPACING from the bandgap
of a previous calculation.
auto_ismear
(
bool
) – If true, the values for ISMEAR and SIGMA will be set
automatically depending on the bandgap of the system. If the bandgap is not
known (e.g., there is no previous VASP directory) then ISMEAR=0 and
SIGMA=0.2; if the bandgap is zero (a metallic system) then ISMEAR=2 and
SIGMA=0.2; if the system is an insulator, then ISMEAR=-5 (tetrahedron
smearing). Note, this only works when generating the input set from a
previous VASP directory.
auto_ispin
(
bool
) – If generating input set from a previous calculation, this controls whether
to disable magnetisation (ISPIN = 1) if the absolute value of all magnetic
moments are less than 0.02.
auto_lreal
(
bool
) – If True, automatically use the VASP recommended LREAL based on cell size.
auto_metal_kpoints
– If true and the system is metallic, try and use
reciprocal_density_metal
instead of
reciprocal_density
for metallic systems. Note, this only works
if the bandgap is not None.
bandgap_tol
(
float
) – Tolerance for determining if a system is metallic when
KSPACING is set to “auto”. If the bandgap is less than this value, the
system is considered metallic. Defaults to 1e-4 (eV).
bandgap
(
float
) – Used for determining KSPACING if KSPACING == “auto” or
ISMEAR if auto_ismear == True. Set automatically when using from_prev_calc.
prev_incar
(
str
or
dict
) – Previous INCAR used for setting parent INCAR when
inherit_incar == True. Set automatically when using from_prev_calc.
prev_kpoints
(
str
or
Kpoints
) – Previous Kpoints. Set automatically when using
from_prev_calc.
as_dict
(
verbosity
:
int
=
2
)
→
dict
[source]

Parameters
:
verbosity
– Verbosity for generated dict. If 1, structure is
excluded.
Returns
:
MSONable VaspInputSet representation.
Return type
:
dict
auto_ismear
:
bool
=
False
[source]

auto_ispin
:
bool
=
False
[source]

auto_kspacing
:
bool
=
False
[source]

auto_lreal
:
bool
=
False
[source]

auto_metal_kpoints
:
bool
=
False
[source]

bandgap
:
float
|
None
=
None
[source]

bandgap_tol
:
float
=
0.0001
[source]

calculate_ng
(
max_prime_factor
:
int
=
7
,
must_inc_2
:
bool
=
True
,
custom_encut
:
float
|
None
=
None
,
custom_prec
:
str
|
None
=
None
)
→
tuple
[source]

Calculate the NGX, NGY, and NGZ values using the information available in the INCAR and POTCAR
This is meant to help with making initial guess for the FFT grid so we can interact with the Charge density API.
Parameters
:
max_prime_factor
(
int
) – the valid prime factors of the grid size in each direction
VASP has many different setting for this to handle many compiling options.
For typical MPI options all prime factors up to 7 are allowed
must_inc_2
(
bool
) – Whether 2 must be a prime factor of the result. Defaults to True.
custom_encut
(
float
|
None
) – Calculates the FFT grid parameters using a custom
ENCUT that may be different from what is generated by the input set. Defaults to None.
Do
not
use this unless you know what you are doing.
custom_prec
(
str
|
None
) – Calculates the FFT grid parameters using a custom prec
that may be different from what is generated by the input set. Defaults to None.
Do
not
use this unless you know what you are doing.
config_dict
:
dict
[source]

constrain_total_magmom
:
bool
=
False
[source]

estimate_nbands
(
)
→
int
[source]

Estimate the number of bands that VASP will initialize a
calculation with by default. Note that in practice this
can depend on # of cores (if not set explicitly).
Note that this formula is slightly different than the formula on the VASP wiki
(as of July 2023). This is because the formula in the source code (
main.F
) is
slightly different than what is on the wiki.
files_to_transfer
:
dict
[source]

force_gamma
:
bool
=
False
[source]

static
from_directory
(
directory
:
PathLike
,
optional_files
:
dict
|
None
=
None
)
→
VaspInput
[source]

Load a set of VASP inputs from a directory.
Note that only the standard INCAR, POSCAR, POTCAR and KPOINTS files are read
unless optional_filenames is specified.
Parameters
:
directory
– Directory to read VASP inputs from.
optional_files
– Optional files to read in as well as a dict of {filename: Object class}.
Object class must have a static/class method from_file.
classmethod
from_prev_calc
(
prev_calc_dir
:
PathLike
,
**
kwargs
)
→
Self
[source]

Generate a set of VASP input files for static calculations from a
directory of previous VASP run.
Parameters
:
prev_calc_dir
(
PathLike
) – Directory containing the outputs(
vasprun.xml and OUTCAR) of previous VASP run.
**kwargs
– All kwargs supported by MPStaticSet, other than prev_incar
and prev_structure and prev_kpoints which are determined from
the prev_calc_dir.
get_input_set
(
structure
:
Structure
|
None
=
None
,
prev_dir
:
PathLike
|
None
=
None
,
potcar_spec
:
bool
=
False
)
→
VaspInput
[source]

Get a VASP input set.
Note, if both
structure
and
prev_dir
are set, then the structure
specified will be preferred over the final structure from the last VASP run.
Parameters
:
structure
(
Structure
) – A structure.
prev_dir
(
PathLike
) – A previous directory to generate the input set from.
potcar_spec
(
bool
) – Instead of generating a Potcar object, use a list of
potcar symbols. This will be written as a “POTCAR.spec” file. This is
intended to help sharing an input set with people who might not have a
license to specific Potcar files. Given a “POTCAR.spec”, the specific
POTCAR file can be re-generated using pymatgen with the
“generate_potcar” function in the pymatgen CLI.
Returns
:
A VASP input object.
Return type
:
VaspInput
get_vasp_input
(
structure
:
Structure
|
None
=
None
)
→
VaspInput
[source]

Get a VaspInput object.
Returns
:
VaspInput.
property
incar
:
Incar
[source]

The INCAR.
property
incar_updates
:
dict
[source]

Updates to the INCAR config for this calculation type.
inherit_incar
:
bool
|
list
[
str
]
=
False
[source]

international_monoclinic
:
bool
=
True
[source]

property
kpoints
:
Kpoints
|
None
[source]

The KPOINTS file.
property
kpoints_updates
:
dict
[source]

Updates to the kpoints configuration for this calculation type.
Note, these updates will be ignored if the user has set user_kpoint_settings.
Returns
:
A dictionary of updates to apply to the KPOINTS config
or a Kpoints object.
Return type
:
dict or
Kpoints
property
nelect
:
float
[source]

The default number of electrons for a given structure.
override_from_prev_calc
(
prev_calc_dir
:
PathLike
=
'.'
)
→
Self
[source]

Update the input set to include settings from a previous calculation.
Parameters
:
prev_calc_dir
(
PathLike
) – The path to the previous calculation directory.
Returns
:
A new input set with settings (Structure, k-points, incar, etc)
updated using the previous VASP run.
Return type
:
VaspInputSet
property
poscar
:
Poscar
[source]

Poscar.
property
potcar
:
Potcar
[source]

The input set’s POTCAR.
property
potcar_functional
:
UserPotcarFunctional
[source]

The functional used for POTCAR generation.
property
potcar_symbols
:
list
[
str
]
[source]

List of POTCAR symbols.
prev_incar
:
str
|
dict
|
None
=
None
[source]

prev_kpoints
:
str
|
Kpoints
|
None
=
None
[source]

reduce_structure
:
Literal
[
'niggli'
,
'LLL'
]
|
None
=
None
[source]

sort_structure
:
bool
=
True
[source]

standardize
:
bool
=
False
[source]

property
structure
:
Structure
|
None
[source]

Structure.
sym_prec
:
float
=
0.1
[source]

use_structure_charge
:
bool
=
False
[source]

user_incar_settings
:
dict
[source]

user_kpoints_settings
:
dict
[source]

user_potcar_functional
:
UserPotcarFunctional
=
None
[source]

user_potcar_settings
:
dict
[source]

validate_magmom
:
bool
=
True
[source]

vdw
:
str
|
None
=
None
[source]

write_input
(
output_dir
:
str
,
make_dir_if_not_present
:
bool
=
True
,
include_cif
:
bool
|
str
=
False
,
potcar_spec
:
bool
=
False
,
zip_output
:
bool
|
str
=
False
)
→
None
[source]

Write a set of VASP input to a directory.
Parameters
:
output_dir
(
str
) – Directory to output the VASP input files
make_dir_if_not_present
(
bool
) – Set to True if you want the
directory (and the whole path) to be created if it is not
present.
include_cif
(
bool
) – Whether to write a CIF file in the output
directory for easier opening by VESTA.
potcar_spec
(
bool
) – Instead of writing the POTCAR, write a “POTCAR.spec”.
This is intended to help sharing an input set with people who might
not have a license to specific Potcar files. Given a “POTCAR.spec”,
the specific POTCAR file can be re-generated using pymatgen with the
“generate_potcar” function in the pymatgen CLI.
zip_output
(
bool
) – If True, output will be zipped into a file with the
same name as the InputSet (e.g., MPStaticSet.zip).
auto_kspacing
(
bandgap
:
float
|
None
,
bandgap_tol
:
float
)
→
float
[source]

Set kspacing based on the bandgap.
batch_write_input
(
structures:
Sequence[Structure],
vasp_input_set=<class
'pymatgen.io.vasp.sets.MPRelaxSet'>,
output_dir:
PathLike
=
'.',
make_dir_if_not_present:
bool
=
True,
subfolder:
Callable
|
None
=
None,
sanitize:
bool
=
False,
include_cif:
bool
=
False,
potcar_spec:
bool
=
False,
zip_output:
bool
=
False,
**kwargs
)
[source]

Batch write VASP input for a sequence of structures to
output_dir, following the format output_dir/{group}/{formula}_{number}.
Parameters
:
structures
(
[
Structure
]
) – Sequence of Structures.
vasp_input_set
(
VaspInputSet
) – VaspInputSet class that creates
VASP input files from structures. Note that a class should be
supplied. Defaults to MPRelaxSet.
output_dir
(
str
) – Directory to output files. Defaults to current
directory “.”.
make_dir_if_not_present
(
bool
) – Create the directory if not present.
Defaults to True.
subfolder
(
callable
) – Function to create subdirectory name from
structure. Defaults to simply “formula_count”.
sanitize
(
bool
) – Boolean indicating whether to sanitize the
structure before writing the VASP input files. Sanitized output
are generally easier for viewing and certain forms of analysis.
Defaults to False.
include_cif
(
bool
) – Whether to output a CIF as well. CIF files are
generally better supported in visualization programs.
potcar_spec
(
bool
) – Instead of writing the POTCAR, write a “POTCAR.spec”.
This is intended to help sharing an input set with people who might
not have a license to specific Potcar files. Given a “POTCAR.spec”,
the specific POTCAR file can be re-generated using pymatgen with the
“generate_potcar” function in the pymatgen CLI.
zip_output
(
bool
) – If True, output will be zipped into a file with the
same name as the InputSet (e.g., MPStaticSet.zip)
**kwargs
– Additional kwargs are passed to the vasp_input_set class
in addition to structure.
get_structure_from_prev_run
(
vasprun
:
Vasprun
,
outcar
:
Outcar
|
None
=
None
)
→
Structure
[source]

Process structure from previous run.
Parameters
:
vasprun
(
Vasprun
) – Vasprun that contains the final structure from previous run.
outcar
(
Outcar
) – Outcar that contains the magnetization info from previous run.
Returns
:
The magmom-decorated structure that can be passed to get VASP input files, e.g.
get_kpoints().
Return type
:
Structure
get_valid_magmom_struct
(
structure
:
Structure
|
IStructure
,
inplace
:
bool
=
True
,
spin_mode
:
str
=
'auto'
)
→
IStructure
|
Structure
[source]

Make sure that the structure has valid magmoms based on the kind of calculation.
Fill in missing Magmom values.
Parameters
:
structure
– The input structure
inplace
– True: edit magmoms of the input structure; False: return new structure
spin_mode
–
“scalar”/”vector”/”none”/”auto” only first letter (s/v/n) is needed.
dictates how the spin configuration will be determined.
auto: read the existing magmom values and decide
scalar: use a single scalar value (for spin up/down)
vector: use a vector value for spin-orbit systems
none: Remove all the magmom information
Returns
:
New structure if inplace is False
get_vasprun_outcar
(
path
:
PathLike
,
parse_dos
:
bool
=
True
,
parse_eigen
:
bool
=
True
)
→
tuple
[
Vasprun
,
Outcar
]
[source]

Get a Vasprun and Outcar from a directory.
Parameters
:
path
– Path to get the vasprun.xml and OUTCAR.
parse_dos
– Whether to parse dos. Defaults to True.
parse_eigen
– Whether to parse eigenvalue. Defaults to True.
Returns
:
Vasprun and Outcar files.
next_num_with_prime_factors
(
n
:
int
,
max_prime_factor
:
int
,
must_inc_2
:
bool
=
True
)
→
int
[source]

Get the next number greater than or equal to n that only has the desired prime factors.
Parameters
:
n
(
int
) – Initial guess at the grid density
max_prime_factor
(
int
) – the maximum prime factor
must_inc_2
(
bool
) – 2 must be a prime factor of the result
Returns
:
first product of the prime_factors that is >= n
Return type
:
int
primes_less_than
(
max_val
:
int
)
→
list
[
int
]
[source]

Get the primes less than or equal to the max value.
standardize_structure
(
structure
:
Structure
|
IStructure
,
sym_prec
:
float
=
0.1
,
international_monoclinic
:
bool
=
True
)
→
Structure
[source]

Get the symmetrically standardized structure.
Parameters
:
structure
(
Structure
) – The structure.
sym_prec
(
float
) – Tolerance for symmetry finding for standardization.
international_monoclinic
(
bool
) – Whether to use international
convention (vs Curtarolo) for monoclinic. Defaults True.
Returns
:
The symmetrized structure.
© Copyright 2011, Pymatgen Development Team.
Built with
Sphinx
using a
theme
provided by
Read the Docs
.