pymatgen.io.lammps package — pymatgen 2025.5.28 documentation
pymatgen.io.lammps package
Submodules
pymatgen.io.lammps.data module
CombinedData
CombinedData.as_lammpsdata()
CombinedData.disassemble()
CombinedData.from_ff_and_topologies()
CombinedData.from_files()
CombinedData.from_lammpsdata()
CombinedData.from_structure()
CombinedData.get_str()
CombinedData.parse_xyz()
CombinedData.structure
ForceField
ForceField.masses
ForceField.force_fieldct
ForceField.maps
ForceField.from_dict()
ForceField.from_file()
ForceField.to_file()
LammpsBox
LammpsBox.get_box_shift()
LammpsBox.get_str()
LammpsBox.to_lattice()
LammpsBox.volume
LammpsData
LammpsData.disassemble()
LammpsData.from_ff_and_topologies()
LammpsData.from_file()
LammpsData.from_structure()
LammpsData.get_str()
LammpsData.set_charge_atom()
LammpsData.set_charge_atom_type()
LammpsData.structure
LammpsData.write_file()
Topology
Topology.from_bonding()
lattice_2_lmpbox()
pymatgen.io.lammps.generators module
BaseLammpsGenerator
BaseLammpsGenerator.template
BaseLammpsGenerator.calc_type
BaseLammpsGenerator.settings
BaseLammpsGenerator.keep_stages
BaseLammpsGenerator.calc_type
BaseLammpsGenerator.data
BaseLammpsGenerator.get_input_set()
BaseLammpsGenerator.inputfile
BaseLammpsGenerator.keep_stages
BaseLammpsGenerator.settings
BaseLammpsGenerator.template
LammpsMinimization
LammpsMinimization.atom_style
LammpsMinimization.boundary
LammpsMinimization.dimension
LammpsMinimization.force_field
LammpsMinimization.read_data
LammpsMinimization.units
pymatgen.io.lammps.inputs module
LammpsInputFile
LammpsInputFile.add_commands()
LammpsInputFile.add_stage()
LammpsInputFile.append()
LammpsInputFile.contains_command()
LammpsInputFile.from_file()
LammpsInputFile.from_str()
LammpsInputFile.get_args()
LammpsInputFile.get_str()
LammpsInputFile.merge_stages()
LammpsInputFile.ncomments
LammpsInputFile.nstages
LammpsInputFile.remove_command()
LammpsInputFile.remove_stage()
LammpsInputFile.rename_stage()
LammpsInputFile.set_args()
LammpsInputFile.stages_names
LammpsInputFile.write_file()
LammpsRun
LammpsRun.md()
LammpsRun.write_inputs()
LammpsTemplateGen
LammpsTemplateGen.get_input_set()
write_lammps_inputs()
pymatgen.io.lammps.outputs module
LammpsDump
LammpsDump.as_dict()
LammpsDump.from_dict()
LammpsDump.from_str()
parse_lammps_dumps()
parse_lammps_log()
pymatgen.io.lammps.sets module
LammpsInputSet
LammpsInputSet.from_directory()
LammpsInputSet.validate()
pymatgen.io.lammps.utils module
LammpsRunner
LammpsRunner.run()
PackmolRunner
PackmolRunner.convert_obatoms_to_molecule()
PackmolRunner.restore_site_properties()
PackmolRunner.run()
PackmolRunner.write_pdb()
Polymer
pymatgen
pymatgen.io.lammps package
Edit on GitHub
pymatgen.io.lammps package

IO for LAMMPS.
Submodules

pymatgen.io.lammps.data module

This module implements a core class LammpsData for generating/parsing
LAMMPS data file, and other bridging classes to build LammpsData from
molecules. This module also implements a subclass CombinedData for
merging LammpsData object.
Only point particle styles are supported for now (atom_style in angle,
atomic, bond, charge, full and molecular only). See the pages below for
more info.
https://docs.lammps.org/atom_style.html
https://docs.lammps.org/read_data.html
class
CombinedData
(
list_of_molecules
:
list
,
list_of_names
:
list
[
str
]
,
list_of_numbers
:
list
[
int
]
,
coordinates
:
DataFrame
,
atom_style
:
str
=
'full'
)
[source]

Bases:
LammpsData
Object for a collective set of data for a series of LAMMPS data file.
velocities not yet implemented.
Parameters
:
list_of_molecules
– A list of LammpsData objects of a chemical cluster.
Each LammpsData object (cluster) may contain one or more molecule ID.
list_of_names
– A list of name (string) for each cluster. The characters in each name are
restricted to word characters ([
a-zA-Z0-9_
]). If names with any non-word characters
are passed in, the special characters will be substituted by ‘_’.
list_of_numbers
– A list of Integer for counts of each molecule
coordinates
(
pandas.DataFrame
) – DataFrame at least containing
columns of [“x”, “y”, “z”] for coordinates of atoms.
atom_style
(
str
) – Output atom_style. Default to “full”.
as_lammpsdata
(
)
[source]

Convert a CombinedData object to a LammpsData object. attributes are deep-copied.
box (LammpsBox): Simulation box.
force_fieldct (dict): Data for force field sections. Optional
with default to None. Only keywords in force field and
class 2 force field are valid keys, and each value is a
DataFrame.
topology (dict): Data for topology sections. Optional with
default to None. Only keywords in topology are valid
keys, and each value is a DataFrame.
disassemble
(
atom_labels
:
Sequence
[
str
]
|
None
=
None
,
guess_element
:
bool
=
True
,
ff_label
:
str
=
'ff_map'
)
[source]

Breaks down each LammpsData in CombinedData to building blocks
(LammpsBox, ForceField and a series of Topology).
RESTRICTIONS APPLIED:
1. No complex force field defined not just on atom
types, where the same type or equivalent types of topology
may have more than one set of coefficients.
No intermolecular topologies (with atoms from different
molecule-ID) since a Topology object includes data for ONE
molecule or structure only.
Parameters
:
atom_labels
(
[
str
]
) – List of strings (must be different
from one another) for labelling each atom type found in
Masses section. Default to None, where the labels are
automatically added based on either element guess or
dummy specie assignment.
guess_element
(
bool
) – Whether to guess the element based on
its atomic mass. Default to True, otherwise dummy
species “Qa”, “Qb”, … will be assigned to various
atom types. The guessed or assigned elements will be
reflected on atom labels if atom_labels is None, as
well as on the species of molecule in each Topology.
ff_label
(
str
) – Site property key for labeling atoms of
different types. Default to “ff_map”.
Returns
:
[(LammpsBox, ForceField, [Topology]), …]
classmethod
from_ff_and_topologies
(
)
→
None
[source]

Unsupported constructor for CombinedData objects.
classmethod
from_files
(
coordinate_file
:
str
,
list_of_numbers
:
list
[
int
]
,
*
filenames
:
str
)
→
Self
[source]

Constructor that parse a series of data file.
Parameters
:
coordinate_file
(
str
) – The filename of xyz coordinates.
list_of_numbers
(
list
[
int
]
) – A list of numbers specifying counts for each
clusters parsed from files.
filenames
(
str
) – A series of LAMMPS data filenames in string format.
classmethod
from_lammpsdata
(
mols
:
list
,
names
:
list
,
list_of_numbers
:
list
,
coordinates
:
pd.DataFrame
,
atom_style
:
str
|
None
=
None
)
→
Self
[source]

Constructor that can infer atom_style.
The input LammpsData objects are used non-destructively.
Parameters
:
mols
– a list of LammpsData of a chemical cluster.Each LammpsData object (cluster)
may contain one or more molecule ID.
names
– a list of name for each cluster.
list_of_numbers
– a list of Integer for counts of each molecule
coordinates
(
pandas.DataFrame
) – DataFrame at least containing
columns of [“x”, “y”, “z”] for coordinates of atoms.
atom_style
(
str
) – Output atom_style. Default to “full”.
classmethod
from_structure
(
)
→
None
[source]

Unsupported constructor for CombinedData objects.
get_str
(
distance
:
int
=
6
,
velocity
:
int
=
8
,
charge
:
int
=
4
,
hybrid
:
bool
=
True
)
→
str
[source]

Get the string representation of CombinedData, essentially
the string to be written to a file. Combination info is included
as a comment. For single molecule ID data, the info format is:
num name
For data with multiple molecule ID, the format is:
num(mols_per_data) name.
Parameters
:
distance
(
int
) – No. of significant figures to output for
box settings (bounds and tilt) and atomic coordinates.
Default to 6.
velocity
(
int
) – No. of significant figures to output for
velocities. Default to 8.
charge
(
int
) – No. of significant figures to output for
charges. Default to 4.
hybrid
(
bool
) – Whether to write hybrid coeffs types.
Default to True. If the data object has no hybrid
coeffs types and has large coeffs section, one may
use False to speed up the process. Otherwise, the
default is recommended.
Returns
:
String representation of CombinedData.
Return type
:
str
classmethod
parse_xyz
(
filename
:
str
|
Path
)
→
DataFrame
[source]

Load xyz file generated from packmol (for those who find it hard to install openbabel).
Returns
:
pandas.DataFrame
property
structure
:
Structure
[source]

Exports a periodic structure object representing the simulation
box.
Returns
:
Structure
class
ForceField
(
mass_info
:
list
,
nonbond_coeffs
:
list
|
None
=
None
,
topo_coeffs
:
dict
|
None
=
None
)
[source]

Bases:
MSONable
Class carrying most data in masses and force field sections.
masses
[source]

DataFrame for masses section.
Type
:
pandas.DataFrame
force_fieldct
[source]

Force field section keywords (keys) and
data (values) as DataFrames.
Type
:
dict
maps
[source]

Dict for labeling atoms and topologies.
Type
:
dict
Parameters
:
mass_info
(
list
) – List of atomic mass info. Elements,
strings (symbols) and floats are all acceptable for the
values, with the first two converted to the atomic mass
of an element. It is recommended to use
dict.items() to prevent key duplications.
[(“C”, 12.01), (“H”, Element(“H”)), (“O”, “O”), …]
nonbond_coeffs
(
list
) – List of Pair or PairIJ
coefficients, of which the sequence must be sorted
according to the species in mass_dict. Pair or PairIJ
determined by the length of list. Optional with default
to None.
topo_coeffs
(
dict
) –
Dict with force field coefficients for
molecular topologies. Optional with default
to None. All four valid keys listed below are optional.
Each value is a list of dicts with non-optional keys
“coeffs” and “types”, and related class2 force field
keywords as optional keys.
{
”Bond Coeffs”:
[{“coeffs”: [coeff],
”types”: [(“C”, “C”), …]}, …],
”Angle Coeffs”:
[{“coeffs”: [coeff],
”BondBond Coeffs”: [coeff],
“types”: [(“H”, “C”, “H”), …]}, …],
”Dihedral Coeffs”:
[{“coeffs”: [coeff],
”BondBond13 Coeffs”: [coeff],
“types”: [(“H”, “C”, “C”, “H”), …]}, …],
”Improper Coeffs”:
[{“coeffs”: [coeff],
”AngleAngle Coeffs”: [coeff],
“types”: [(“H”, “C”, “C”, “H”), …]}, …],
}
Topology of same type or equivalent types (e.g.,
(“C”, “H”) and (“H”, “C”) bonds) are NOT ALLOWED to
be defined MORE THAN ONCE with DIFFERENT coefficients.
classmethod
from_dict
(
dct
:
dict
)
→
Self
[source]

Constructor that reads in a dictionary.
Parameters
:
dct
(
dict
) – Dictionary to read.
classmethod
from_file
(
filename
:
str
)
→
Self
[source]

Constructor that reads in a file in YAML format.
Parameters
:
filename
(
str
) – Filename.
to_file
(
filename
:
str
)
→
None
[source]

Save force field to a file in YAML format.
Parameters
:
filename
(
str
) – Filename.
class
LammpsBox
(
bounds
:
Sequence
,
tilt
:
Sequence
|
None
=
None
)
[source]

Bases:
MSONable
Object for representing a simulation box in LAMMPS settings.
Parameters
:
bounds
– A (3, 2) array/list of floats setting the
boundaries of simulation box.
tilt
– A (3,) array/list of floats setting the tilt of
simulation box. Default to None, i.e., use an
orthogonal box.
get_box_shift
(
i
:
Sequence
[
int
]
)
→
np.ndarray
[source]

Calculates the coordinate shift due to PBC.
Parameters
:
i
– A (n, 3) integer array containing the labels for box
entries.
(
images
of
n
)
Returns
:
Coordinate shift array with the same shape of i
get_str
(
significant_figures
:
int
=
6
)
→
str
[source]

Get the string representation of simulation box in LAMMPS data file format.
Parameters
:
significant_figures
(
int
) – No. of significant figures to
output for box settings. Default to 6.
to_lattice
(
)
→
Lattice
[source]

Convert the simulation box to a more powerful Lattice backend.
Note that Lattice is always periodic in 3D space while a
simulation box is not necessarily periodic in all dimensions.
Returns
:
Lattice
property
volume
:
float
[source]

Volume of simulation box.
class
LammpsData
(
box
:
LammpsBox
,
masses
:
DataFrame
,
atoms
:
DataFrame
,
velocities
:
DataFrame
=
None
,
force_field
:
dict
|
None
=
None
,
topology
:
dict
[
str
,
DataFrame
]
|
None
=
None
,
atom_style
:
str
=
'full'
)
[source]

Bases:
MSONable
Object for representing the data in a LAMMPS data file.
Low level constructor designed to work with parsed data or other bridging
objects (ForceField and Topology). Not recommended to use directly.
Parameters
:
box
(
LammpsBox
) – Simulation box.
masses
(
pandas.DataFrame
) – DataFrame with one column
[“mass”] for Masses section.
atoms
(
pandas.DataFrame
) – DataFrame with multiple columns
for Atoms section. Column names vary with atom_style.
velocities
(
pandas.DataFrame
) – DataFrame with three columns
[“vx”, “vy”, “vz”] for Velocities section. Optional
with default to None. If not None, its index should be
consistent with atoms.
force_fieldct
(
dict
) – Data for force field sections. Optional
with default to None. Only keywords in force field and
class 2 force field are valid keys, and each value is a
DataFrame.
topology
(
dict
) – Data for topology sections. Optional with
default to None. Only keywords in topology are valid
keys, and each value is a DataFrame.
atom_style
(
str
) – Output atom_style. Default to “full”.
disassemble
(
atom_labels
:
Sequence
[
str
]
|
None
=
None
,
guess_element
:
bool
=
True
,
ff_label
:
str
=
'ff_map'
)
→
tuple
[
LammpsBox
,
ForceField
,
list
[
Topology
]
]
[source]

Breaks down LammpsData to building blocks
(LammpsBox, ForceField and a series of Topology).
RESTRICTIONS APPLIED:
No complex force field defined not just on atom
types, where the same type or equivalent types of topology
may have more than one set of coefficients.
No intermolecular topologies (with atoms from different
molecule-ID) since a Topology object includes data for ONE
molecule or structure only.
Parameters
:
atom_labels
(
[
str
]
) – List of strings (must be different
from one another) for labelling each atom type found in
Masses section. Default to None, where the labels are
automatically added based on either element guess or
dummy specie assignment.
guess_element
(
bool
) – Whether to guess the element based on
its atomic mass. Default to True, otherwise dummy
species “Qa”, “Qb”, … will be assigned to various
atom types. The guessed or assigned elements will be
reflected on atom labels if atom_labels is None, as
well as on the species of molecule in each Topology.
ff_label
(
str
) – Site property key for labeling atoms of
different types. Default to “ff_map”.
Returns
:
LammpsBox, ForceField, [Topology]
classmethod
from_ff_and_topologies
(
box
:
LammpsBox
,
ff
:
ForceField
,
topologies
:
Sequence
[
Topology
]
,
atom_style
:
str
=
'full'
)
→
Self
[source]

Constructor building LammpsData from a ForceField object and a
list of Topology objects. Do not support intermolecular
topologies since a Topology object includes data for ONE
molecule or structure only.
Parameters
:
box
(
LammpsBox
) – Simulation box.
ff
(
ForceField
) – ForceField object with data for Masses and
force field sections.
topologies
(
[
Topology
]
) – List of Topology objects with data
for Atoms, Velocities and topology sections.
atom_style
(
str
) – Output atom_style. Default to “full”.
classmethod
from_file
(
filename
:
str
,
atom_style
:
str
=
'full'
,
sort_id
:
bool
=
False
)
→
Self
[source]

Constructor that parses a file.
Parameters
:
filename
(
str
) – Filename to read.
atom_style
(
str
) – Associated atom_style. Default to “full”.
sort_id
(
bool
) – Whether sort each section by id. Default to
True.
classmethod
from_structure
(
structure
:
Structure
|
IStructure
,
ff_elements
:
Sequence
[
str
]
|
None
=
None
,
atom_style
:
Literal
[
'atomic'
,
'charge'
]
=
'charge'
,
is_sort
:
bool
=
False
)
→
Self
[source]

Simple constructor building LammpsData from a structure without
force field parameters and topologies.
Parameters
:
structure
(
Structure
) – Input structure.
ff_elements
(
[
str
]
) – List of strings of elements that must
be present due to force field settings but not
necessarily in the structure. Default to None.
atom_style
(
str
) – Choose between “atomic” (neutral) and
“charge” (charged). Default to “charge”.
is_sort
(
bool
) – whether to sort sites
get_str
(
distance
:
int
=
6
,
velocity
:
int
=
8
,
charge
:
int
=
4
,
hybrid
:
bool
=
True
)
→
str
[source]

Get the string representation of LammpsData, essentially the string
to be written to a file. Supports hybrid style coeffs read and write.
Parameters
:
distance
(
int
) – No. of significant figures to output for
box settings (bounds and tilt) and atomic coordinates.
Default to 6.
velocity
(
int
) – No. of significant figures to output for
velocities. Default to 8.
charge
(
int
) – No. of significant figures to output for
charges. Default to 4.
hybrid
(
bool
) – Whether to write hybrid coeffs types.
Default to True. If the data object has no hybrid
coeffs types and has large coeffs section, one may
use False to speed up the process. Otherwise, the
default is recommended.
Returns
:
String representation of LammpsData.
Return type
:
str
set_charge_atom
(
charges
:
dict
[
int
,
float
]
)
→
None
[source]

Set the charges of specific atoms of the data.
Parameters
:
charges
– A dictionary with atom indexes as keys and
charges as values, e.g. to set the charge
of the atom with index 3 to -2, use
{3: -2}
.
set_charge_atom_type
(
charges
:
dict
[
str
|
int
,
float
]
)
→
None
[source]

Add or modify charges of all atoms of a given type in the data.
Parameters
:
charges
–
Dict containing the charges for the atom types to set.
The dict should contain atom types as integers or labels and charges.
Example: change the charge of Li atoms to +3:
charges={“Li”: 3}
charges={1: 3} if Li atoms are of type 1
property
structure
:
Structure
[source]

Exports a periodic structure object representing the simulation
box.
Returns
:
Structure
write_file
(
filename
:
str
,
distance
:
int
=
6
,
velocity
:
int
=
8
,
charge
:
int
=
4
)
→
None
[source]

Write LammpsData to file.
Parameters
:
filename
(
str
) – Filename.
distance
(
int
) – No. of significant figures to output for
box settings (bounds and tilt) and atomic coordinates.
Default to 6.
velocity
(
int
) – No. of significant figures to output for
velocities. Default to 8.
charge
(
int
) – No. of significant figures to output for
charges. Default to 4.
class
Topology
(
sites
:
Sequence
[
Site
]
|
SiteCollection
,
ff_label
:
str
|
None
=
None
,
charges
:
Sequence
|
None
=
None
,
velocities
:
Sequence
[
Sequence
]
|
None
=
None
,
topologies
:
dict
|
None
=
None
)
[source]

Bases:
MSONable
Carry most data in Atoms, Velocities and Molecular Topology sections for
ONE SINGLE Molecule or Structure object, or a plain list of Sites.
Parameters
:
sites
(
[
Site
] or
SiteCollection
) – A group of sites in a
list or as a Molecule/Structure.
ff_label
(
str
) – Site property key for labeling atoms of
different types. Default to None, i.e., use
site.species_string.
charges
(
[
q
,
...
]
) – Charge of each site in a (n,)
array/list, where n is the No. of sites. Default to
None, i.e., search site property for charges.
velocities
(
[
[
vx
,
vy
,
vz
]
,
...
]
) – Velocity of each site in
a (n, 3) array/list, where n is the No. of sites.
Default to None, i.e., search site property for
velocities.
topologies
(
dict
) –
Bonds, angles, dihedrals and improper
dihedrals defined by site indices. Default to None,
i.e., no additional topology. All four valid keys
listed below are optional.
{
”Bonds”: [[i, j], …],
“Angles”: [[i, j, k], …],
“Dihedrals”: [[i, j, k, l], …],
“Impropers”: [[i, j, k, l], …]
}.
classmethod
from_bonding
(
molecule
:
Molecule
,
bond
:
bool
=
True
,
angle
:
bool
=
True
,
dihedral
:
bool
=
True
,
tol
:
float
=
0.1
,
**
kwargs
)
→
Self
[source]

Another constructor that creates an instance from a molecule.
Covalent bonds and other bond-based topologies (angles and
dihedrals) can be automatically determined. Cannot be used for
non bond-based topologies, e.g. improper dihedrals.
Parameters
:
molecule
(
Molecule
) – Input molecule.
bond
(
bool
) – Whether find bonds. If set to False, angle and
dihedral searching will be skipped. Default to True.
angle
(
bool
) – Whether find angles. Default to True.
dihedral
(
bool
) – Whether find dihedrals. Default to True.
tol
(
float
) – Bond distance tolerance. Default to 0.1.
Not recommended to alter.
**kwargs
– Other kwargs supported by Topology.
lattice_2_lmpbox
(
lattice
:
Lattice
,
origin
:
Sequence
=
(0,
0,
0)
)
→
tuple
[
LammpsBox
,
SymmOp
]
[source]

Converts a lattice object to LammpsBox, and calculates the symmetry
operation used.
Parameters
:
lattice
(
Lattice
) – Input lattice.
origin
– A (3,) array/list of floats setting lower bounds of
simulation box. Default to (0, 0, 0).
Returns
:
tuple[LammpsBox, SymmOp]
pymatgen.io.lammps.generators module

Input set generators for LAMMPS.
This InputSet and InputGenerator implementation is based on templates and is not intended to be very flexible.
For instance, pymatgen will not detect whether a given variable should be adapted based on others
(e.g., the number of steps from the temperature), it will not check for convergence nor will it actually run LAMMPS.
For additional flexibility and automation, use the atomate2-lammps implementation
(
https://github.com/Matgenix/atomate2-lammps
).
class
BaseLammpsGenerator
(
inputfile:
~pymatgen.io.lammps.inputs.LammpsInputFile
|
None
=
None
,
template:
str
=
<factory>
,
data:
~pymatgen.io.lammps.data.LammpsData
|
~pymatgen.io.lammps.data.CombinedData
|
None
=
None
,
settings:
dict
=
<factory>
,
calc_type:
str
=
'lammps'
,
keep_stages:
bool
=
True
)
[source]

Bases:
InputGenerator
Base class to generate LAMMPS input sets.
Uses template files for the input. The variables that can be changed
in the input template file are those starting with a $ sign, e.g. $nsteps.
This generic class is specialized for each template in subclasses, e.g. LammpsMinimization.
You can create a template for your own task following those present in pymatgen/io/lammps/templates.
The parameters are then replaced based on the values found
in the settings dictionary that you provide, e.g.
{“nsteps”: 1000}
.
template
[source]

Path (string) to the template file used to create the InputFile for LAMMPS.
Type
:
str
calc_type
[source]

Human-readable string used to briefly describe the type of computations performed by LAMMPS.
Type
:
str
settings
[source]

Dictionary containing the values of the parameters to replace in the template.
Type
:
dict
keep_stages
[source]

If True, the string is formatted in a block structure with stage names
Type
:
bool
and
newlines
that
differentiate
commands
in
the
respective
stages
of
the
InputFile.
If
False,
stage
names
are
not
printed
and
all
commands
appear
in
a
single
block.
/!This InputSet and InputGenerator implementation is based on templates and is not intended to be very flexible.
For instance, pymatgen will not detect whether a given variable should be adapted based on others
(e.g., the number of steps from the temperature), it will not check for convergence nor will it actually run LAMMPS.
For additional flexibility and automation, use the atomate2-lammps implementation
(
https://github.com/Matgenix/atomate2-lammps
).
calc_type
:
str
=
'lammps'
[source]

data
:
LammpsData
|
CombinedData
|
None
=
None
[source]

get_input_set
(
structure
:
Structure
|
LammpsData
|
CombinedData
)
→
LammpsInputSet
[source]

Generate a LammpsInputSet from the structure/data, tailored to the template file.
inputfile
:
LammpsInputFile
|
None
=
None
[source]

keep_stages
:
bool
=
True
[source]

settings
:
dict
[source]

template
:
str
[source]

class
LammpsMinimization
(
template
:
str
|
None
=
None
,
units
:
str
=
'metal'
,
atom_style
:
str
=
'full'
,
dimension
:
int
=
3
,
boundary
:
str
=
'p
p
p'
,
read_data
:
str
=
'system.data'
,
force_field
:
str
=
'Unspecified
force
field!'
,
keep_stages
:
bool
=
False
)
[source]

Bases:
BaseLammpsGenerator
Generator that yields a LammpsInputSet tailored for minimizing the energy of a system by iteratively
adjusting atom coordinates.
Example usage:
`
structure
=
Structure.from_file("mp-149.cif")
lmp_minimization
=
LammpsMinimization(units="atomic").get_input_set(structure)
`
.
Do not forget to specify the force field, otherwise LAMMPS will not be able to run!
This InputSet and InputGenerator implementation is based on templates and is not intended to be very flexible.
For instance, pymatgen will not detect whether a given variable should be adapted based on others
(e.g., the number of steps from the temperature), it will not check for convergence nor will it actually run LAMMPS.
For additional flexibility and automation, use the atomate2-lammps implementation
(
https://github.com/Matgenix/atomate2-lammps
).
Parameters
:
template
– Path (string) to the template file used to create the InputFile for LAMMPS.
units
– units to be used for the LAMMPS calculation (see LAMMPS docs).
atom_style
– atom_style to be used for the LAMMPS calculation (see LAMMPS docs).
dimension
– dimension to be used for the LAMMPS calculation (see LAMMPS docs).
boundary
– boundary to be used for the LAMMPS calculation (see LAMMPS docs).
read_data
– read_data to be used for the LAMMPS calculation (see LAMMPS docs).
force_field
– force field to be used for the LAMMPS calculation (see LAMMPS docs).
Note that you should provide all the required information as a single string.
In case of multiple lines expected in the input file,
separate them with ‘n’ in force_field.
keep_stages
– If True, the string is formatted in a block structure with stage names
and newlines that differentiate commands in the respective stages of the InputFile.
If False, stage names are not printed and all commands appear in a single block.
property
atom_style
:
str
[source]

The argument of the command ‘atom_style’ passed to the generator.
property
boundary
:
str
[source]

The argument of the command ‘boundary’ passed to the generator.
property
dimension
:
int
[source]

The argument of the command ‘dimension’ passed to the generator.
property
force_field
:
str
[source]

The details of the force field commands passed to the generator.
property
read_data
:
str
[source]

The argument of the command ‘read_data’ passed to the generator.
property
units
:
str
[source]

The argument of the command ‘units’ passed to the generator.
pymatgen.io.lammps.inputs module

This module implements methods for reading/manipulating/writing LAMMPS input files.
It does not implement methods for automatically creating inputs based on a structure
and computation type. For this, see the InputSet and InputGenerator in sets.py, or
https://github.com/Matgenix/atomate2-lammps
.
class
LammpsInputFile
(
stages
:
list
|
None
=
None
)
[source]

Bases:
InputFile
LAMMPS input settings file such as
in.lammps
.
Allows for LAMMPS input generation in line/stage wise manner. A stage
here is defined as a block of LAMMPS input commands usually performing a
specific task during the simulation such as energy minimization or
NPT/NVT runs. But more broadly, a stage can also be a block of LAMMPS
input where the simulation box is set up, a set of variables are declared or
quantities are computed.
The LammpsInputFile is defined by the attribute
stages
,
i.e. a list of dicts each with keys
stage_name
and
commands
,
defining the stage names and the corresponding LAMMPS input settings (list of tuples of two strings each).
The structure is the following:
``
`
stages = [
{“stage_name”: “Stage 1”, “commands”: [(cmd1, args1), (cmd2, args2)]},
{“stage_name”: “Stage 2”, “commands”: [(cmd3, args3)]},
]

where cmd’s are the LAMMPS command names (e.g., “units”, or “pair_coeff”)
and the args are the corresponding arguments.
“Stage 1” and “Stage 2” are examples of stage names.
param stages
:
list of LAMMPS input settings.
add_commands
(
stage_name
:
str
,
commands
:
str
|
list
[
str
]
|
dict
)
→
None
[source]

Method to add a LAMMPS commands and their arguments to a stage of
the LammpsInputFile. The stage name should be provided: a default behavior
is avoided here to avoid mistakes (e.g., the commands are added to the wrong stage).
Example
In order to add the command
pair_coeff
1
1
morse
0.0580
3.987
3.404
to the stage “Definition of the potential”, simply use
``
`
your_input_file.add_commands(
stage_name=”Definition of the potential”, commands=”pair_coeff 1 1 morse 0.0580 3.987 3.404”
)

To add multiple commands, use a dict or a list, e.g.
``
`
your_input_file.add_commands(
stage_name=”Definition of the potential”,
commands=[“pair_coeff 1 1 morse 0.0580 3.987 3.404”, “units atomic”],
)
your_input_file.add_commands(
stage_name=”Definition of the potential”,
commands={“pair_coeff”: “1 1 morse 0.0580 3.987 3.404”, “units”: “atomic”},
)

param stage_name
:
name of the stage to which the command should be added.
type stage_name
:
str
param commands
:
LAMMPS command, with or without the arguments.
type commands
:
str or list or dict
add_stage
(
stage
:
dict
|
None
=
None
,
commands
:
str
|
list
[
str
]
|
dict
[
str
,
str
|
float
]
|
None
=
None
,
stage_name
:
str
|
None
=
None
,
after_stage
:
str
|
int
|
None
=
None
)
→
None
[source]

Adds a new stage to the LammpsInputFile, either from a whole stage (dict) or
from a stage_name and commands. Both ways are mutually exclusive.
Examples
1) In order to add a stage defining the force field to be used, you can use:
``
`
your_input_file.add_stage(
commands=[“pair_coeff 1 1 morse 0.0580 3.987 3.404”, “pair_coeff 1 4 morse 0.0408 1.399 3.204”],
stage_name=”Definition of the force field”,
)

or

your_input_file.add_stage(
{
“stage_name”: “Definition of the force field”,
“commands”: [
(“pair_coeff”, “1 1 morse 0.0580 3.987 3.404”),
(“pair_coeff”, “1 4 morse 0.0408 1.399 3.204”),
],
}
)

2) Another stage could consist in an energy minimization. In that case, the commands could look like
``
`
commands = [
“thermo 1”,
“thermo_style custom step lx ly lz press pxx pyy pzz pe”,
“dump dmp all atom 5 run.dump”,
“min_style cg”,
“fix 1 all box/relax iso 0.0 vmax 0.001”,
“minimize 1.0e-16 1.0e-16 5000 10000”,
“write_data run.data”,
]

or a dictionary such as
{“thermo”: 1, …}
, or a string with a single command (e.g., “units atomic”).
param stage
:
if provided, this is the stage that will be added to the LammpsInputFile.stages
type stage
:
dict
param commands
:
if provided, these are the LAMMPS command(s)
that will be included in the stage to add.
Can pass a list of LAMMPS commands with their arguments.
Also accepts a dictionary of LAMMPS commands and
corresponding arguments as key, value pairs.
A single string can also be passed (single command together with its arguments).
Not used in case a whole stage is given.
type commands
:
str or list or dict
param stage_name
:
If a stage name is mentioned, the commands are added
under that stage block, else the new stage is named from numbering.
If given, stage_name cannot be one of the already present stage names.
Not used in case a whole stage is given.
type stage_name
:
str
param after_stage
:
Name of the stage after which this stage should be added.
If None, the stage is added at the end of the LammpsInputFile.
type after_stage
:
str
append
(
lmp_input_file
:
LammpsInputFile
)
→
None
[source]

Appends a LammpsInputFile to another. The
stages
are merged,
and the numbering of stages/comments is either kept the same or updated.
Parameters
:
lmp_input_file
(
LammpsInputFile
) – LammpsInputFile to append.
contains_command
(
command
:
str
,
stage_name
:
str
|
None
=
None
)
→
bool
[source]

Get whether a given command is present in the LammpsInputFile.
A stage name can be given; in this case the search will happen only for this stage.
Parameters
:
command
(
str
) – String with the command to find in the input file (e.g., “units”).
stage_name
(
str
) – String giving the stage name where the change should take place.
Returns
:
True if the command is present, False if not.
Return type
:
bool
classmethod
from_file
(
path
:
str
|
Path
,
ignore_comments
:
bool
=
False
,
keep_stages
:
bool
=
False
)
→
Self
[source]

Creates an InputFile object from a file.
Parameters
:
path
(
str
or
path
) – Filename to read, including path.
ignore_comments
(
bool
) – True if only the commands should be kept from the input file.
keep_stages
(
bool
) – True if the block structure from the input file should be kept.
If False, a single block is assumed.
Returns
:
LammpsInputFile
classmethod
from_str
(
contents
:
str
,
ignore_comments
:
bool
=
False
,
keep_stages
:
bool
=
False
)
→
Self
[source]

Helper method to parse string representation of LammpsInputFile.
If you created the input file by hand, there is no guarantee that the representation
will be perfect as it is difficult to account for all the cosmetic changes you
could have done on your input script. Always check that you have what you want !
By default, a single stage containing all the input settings is created.
If the block structure of your input file should be kept and stored as
different stages, set keep_stages to True.
Parameters
:
contents
(
str
) – String representation of LammpsInputFile.
ignore_comments
(
bool
) – True if only the commands should be kept from the input file.
keep_stages
(
bool
) – True if the block structure from the input file should be kept.
If False, a single block is assumed.
Returns
:
LammpsInputFile
get_args
(
command
:
str
,
stage_name
:
str
|
None
=
None
)
→
list
|
str
[source]

Given a command, returns the corresponding arguments (or list of arguments) in the LammpsInputFile.
A stage name can be given; in this case the search will happen only for this stage.
If a stage name is not given, the command will be searched for through all of them.
If the command is not found, an empty list is returned.
Parameters
:
command
(
str
) – String with the command to find in the input file (e.g., “units”).
stage_name
(
str
) – String giving the stage name where the change should take place.
Returns
:
Value of the argument corresponding to the command.
List if the same command is used multiple times.
get_str
(
ignore_comments
:
bool
=
False
,
keep_stages
:
bool
=
True
)
→
str
[source]

Generate and ² the string representation of the LammpsInputFile.
Stages are separated by empty lines.
The headers of the stages will be put in comments preceding each stage.
Other comments will be put inline within stages, where they have been added.
Parameters
:
ignore_comments
(
bool
) – True if only the commands should be kept from the InputFile.
keep_stages
(
bool
) – If True, the string is formatted in a block structure with stage names
and newlines that differentiate commands in the respective stages of the InputFile.
If False, stage names are not printed and all commands appear in a single block.
Returns
:
String representation of the LammpsInputFile.
Return type
:
str
merge_stages
(
stage_names
:
list
[
str
]
)
→
None
[source]

Merges multiple stages of a LammpsInputFile together.
The merged stage will be at the same index as the first of the stages to be merged.
The others will appear in the same order as provided in the list. Other non-merged stages will follow.
Parameters
:
stage_names
(
list
) – list of strings giving the names of the stages to be merged.
property
ncomments
:
int
[source]

The number of comments in the current LammpsInputFile. Includes the blocks of comments as well
as inline comments (comment lines within blocks of LAMMPS commands).
property
nstages
:
int
[source]

The number of stages in the current LammpsInputFile.
remove_command
(
command
:
str
,
stage_name
:
str
|
list
[
str
]
|
None
=
None
,
remove_empty_stages
:
bool
=
True
)
→
None
[source]

Removes a given command from a given stage. If no stage is given, removes all occurrences of the command.
In case removing a command completely empties a stage, the choice whether to keep this stage in the
LammpsInputFile is given by remove_empty_stages.
Parameters
:
command
(
str
) – command to be removed.
stage_name
(
str
or
list
) – names of the stages where the command should be removed.
remove_empty_stages
(
bool
) – whether to remove the stages emptied by removing the command or not.
remove_stage
(
stage_name
:
str
)
→
None
[source]

Removes a whole stage from the LammpsInputFile.
Parameters
:
stage_name
(
str
) – name of the stage to remove.
rename_stage
(
stage_name
:
str
,
new_name
:
str
)
→
None
[source]

Renames a stage
stage_name
from LammpsInputFile into
new_name
.
First checks that the stage to rename is present, and that
the new name is not already a stage name.
Parameters
:
stage_name
(
str
) – name of the stage to rename.
new_name
(
str
) – new name of the stage.
set_args
(
command
:
str
,
argument
:
str
,
stage_name
:
str
|
None
=
None
,
how
:
str
|
int
|
list
[
int
]
=
'all'
)
→
None
[source]

Set the arguments for the given command to the given string.
If the command is not found, nothing is done. Use LammpsInputFile.add_commands instead.
If a stage name is specified, it will be replaced or set only for this stage.
If no stage name is given, it will apply the change in all of them that contain the given command.
If the command is set multiple times in the file/stage, it will be replaced based on “how”:
either the first occurrence, all of them, or the index of the occurrence.
Parameters
:
command
(
str
) – String representing the command to change, e.g. “units”.
argument
(
str
) – String with the new value for the command, e.g. “atomic”.
stage_name
(
str
) – String giving the stage name where the change should take place.
how
(
str
or
int
or
list
) – “all” for changing all occurrences of the command within the stage_name
or the whole InputFile, “first” for the first occurrence, int i for the i-th time the command
is present in the stage_name or the whole InputFile, starting at 0. Can be a list of indexes as well.
property
stages_names
:
list
[source]

List of names for all the stages present in
stages
.
write_file
(
filename
:
PathLike
,
ignore_comments
:
bool
=
False
,
keep_stages
:
bool
=
True
)
→
None
[source]

Write LAMMPS input file.
Parameters
:
filename
(
str
or
path
) – The filename to output to, including path.
ignore_comments
(
bool
) – True if only the commands should be kept from the InputFile.
keep_stages
(
bool
) – True if the block structure from the InputFile should be kept.
If False, a single block is assumed.
class
LammpsRun
(
script_template
:
str
,
settings
:
dict
,
data
:
LammpsData
|
str
,
script_filename
:
str
)
[source]

Bases:
MSONable
Examples for various simple LAMMPS runs with given simulation box,
force field and a few more settings. Experienced LAMMPS users should
consider using write_lammps_inputs method with more sophisticated
templates.
Base constructor.
Parameters
:
script_template
(
str
) – String template for input script
with placeholders. The format for placeholders has to
be ‘$variable_name’, e.g. ‘$temperature’
settings
(
dict
) – Contains values to be written to the
placeholders, e.g. {‘temperature’: 1}.
data
(
LammpsData
or
str
) – Data file as a LammpsData
instance or path to an existing data file. Default to
None, i.e., no data file supplied. Useful only when
read_data cmd is in the script.
script_filename
(
str
) – Filename for the input script.
classmethod
md
(
data
:
LammpsData
|
str
,
force_field
:
str
,
temperature
:
float
,
nsteps
:
int
,
other_settings
:
dict
|
None
=
None
)
→
LammpsRun
[source]

Example for a simple MD run based on template md.template.
Parameters
:
data
(
LammpsData
or
str
) – Data file as a LammpsData
instance or path to an existing data file.
force_field
(
str
) – Combined force field related cmds. For
example, ‘pair_style eamnpair_coeff * * Cu_u3.eam’.
temperature
(
float
) – Simulation temperature.
nsteps
(
int
) – No. of steps to run.
other_settings
(
dict
) – other settings to be filled into
placeholders.
write_inputs
(
output_dir
:
str
,
**
kwargs
)
→
None
[source]

Write all input files (input script, and data if needed).
Other supporting files are not handled at this moment.
Parameters
:
output_dir
(
str
) – Directory to output the input files.
**kwargs
– kwargs supported by LammpsData.write_file.
class
LammpsTemplateGen
[source]

Bases:
TemplateInputGen
Create an InputSet object for a LAMMPS run based on a template file.
The input script is constructed by substituting variables into placeholders
in the template file using python’s Template.safe_substitute() function.
The data file containing coordinates and topology information can be provided
as a LammpsData instance. Alternatively, you can include a read_data command
in the template file that points to an existing data file.
Other supporting files are not handled at the moment.
To write the input files to a directory, call LammpsTemplateSet.write_input()
See pymatgen.io.template.py for additional documentation of this method.
get_input_set
(
script_template
:
PathLike
,
settings
:
dict
|
None
=
None
,
script_filename
:
str
=
'in.lammps'
,
data
:
LammpsData
|
CombinedData
|
None
=
None
,
data_filename
:
str
=
'system.data'
)
→
InputSet
[source]

Parameters
:
script_template
– String template for input script with
placeholders. The format for placeholders has to be
‘$variable_name’, e.g. ‘$temperature’
settings
– Contains values to be written to the
placeholders, e.g. {‘temperature’: 1}. Default to None.
data
– Data file as a LammpsData instance. Default to None, i.e., no
data file supplied. Note that a matching ‘read_data’ command
must be provided in the script template in order for the data
file to actually be read.
script_filename
– Filename for the input file.
data_filename
– Filename for the data file, if provided.
write_lammps_inputs
(
output_dir
:
str
,
script_template
:
str
,
settings
:
dict
|
None
=
None
,
data
:
LammpsData
|
str
|
None
=
None
,
script_filename
:
str
=
'in.lammps'
,
make_dir_if_not_present
:
bool
=
True
,
**
kwargs
)
→
None
[source]

Write input files for a LAMMPS run. Input script is constructed
from a str template with placeholders to be filled by custom
settings. Data file is either written from a LammpsData
instance or copied from an existing file if read_data cmd is
inspected in the input script. Other supporting files are not
handled at the moment.
Parameters
:
output_dir
(
str
) – Directory to output the input files.
script_template
(
str
) – String template for input script with
placeholders. The format for placeholders has to be
‘$variable_name’, e.g. ‘$temperature’
settings
(
dict
) – Contains values to be written to the
placeholders, e.g. {‘temperature’: 1}. Default to None.
data
(
LammpsData
or
str
) – Data file as a LammpsData instance or
path to an existing data file. Default to None, i.e., no
data file supplied. Useful only when read_data cmd is in
the script.
script_filename
(
str
) – Filename for the input script.
make_dir_if_not_present
(
bool
) – Set to True if you want the
directory (and the whole path) to be created if it is not
present.
**kwargs
– kwargs supported by LammpsData.write_file.
Examples
>>>
eam_template
=
'''units           metal
...
atom_style      atomic
...
...
lattice         fcc 3.615
...
region          box block 0 20 0 20 0 20
...
create_box      1 box
...
create_atoms    1 box
...
...
pair_style      eam
...
pair_coeff      1 1 Cu_u3.eam
...
...
velocity        all create $temperature 376847 loop geom
...
...
neighbor        1.0 bin
...
neigh_modify    delay 5 every 1
...
...
fix             1 all nvt temp $temperature $temperature 0.1
...
...
timestep        0.005
...
...
run             $nsteps'''
>>>
write_lammps_inputs
(
"."
,
eam_template
,
settings
=
{
"temperature"
:
1600.0
,
"nsteps"
:
100
})
>>>
with
open
(
"in.lammps"
,
encoding
=
"utf-8"
)
as
file
:
...
script
=
file
.
read
()
>>>
print
(
script
)
units           metal
atom_style      atomic
lattice         fcc 3.615
region          box block 0 20 0 20 0 20
create_box      1 box
create_atoms    1 box
pair_style      eam
pair_coeff      1 1 Cu_u3.eam
velocity        all create 1600.0 376847 loop geom
neighbor        1.0 bin
neigh_modify    delay 5 every 1
fix             1 all nvt temp 1600.0 1600.0 0.1
timestep        0.005
run             100
pymatgen.io.lammps.outputs module

This module implements classes and methods for processing LAMMPS output
files (log and dump).
class
LammpsDump
(
timestep
:
int
,
natoms
:
int
,
box
:
LammpsBox
,
data
:
DataFrame
)
[source]

Bases:
MSONable
Object for representing dump data for a single snapshot.
Base constructor.
Parameters
:
timestep
(
int
) – Current time step.
natoms
(
int
) – Total number of atoms in the box.
box
(
LammpsBox
) – Simulation box.
data
(
pd.DataFrame
) – Dumped atomic data.
as_dict
(
)
→
dict
[
str
,
Any
]
[source]

Get MSONable dict.
classmethod
from_dict
(
dct
:
dict
)
→
Self
[source]

Parameters
:
dct
(
dict
) – Dict representation.
Returns
:
LammpsDump
classmethod
from_str
(
string
:
str
)
→
Self
[source]

Constructor from string parsing.
Parameters
:
string
(
str
) – Input string.
parse_lammps_dumps
(
file_pattern
)
[source]

Generator that parses dump file(s).
Parameters
:
file_pattern
(
str
) – Filename to parse. The timestep wildcard
(e.g., dump.atom.’*’) is supported and the files are parsed
in the sequence of timestep.
Yields
:
LammpsDump for each available snapshot.
parse_lammps_log
(
filename
:
str
=
'log.lammps'
)
→
list
[
DataFrame
]
[source]

Parses log file with focus on thermo data. Both one and multi line
formats are supported. Any incomplete runs (no “Loop time” marker)
will not be parsed.
Notes
SHAKE stats printed with thermo data are not supported yet.
They are ignored in multi line format, while they may cause
issues with dataframe parsing in one line format.
Parameters
:
filename
(
str
) – Filename to parse.
Returns
:
[pd.DataFrame] containing thermo data for each completed run.
pymatgen.io.lammps.sets module

Input sets for LAMMPS.
This InputSet and InputGenerator implementation is based on templates and is not intended to be very flexible.
For instance, pymatgen will not detect whether a given variable should be adapted based on others
(e.g., the number of steps from the temperature), it will not check for convergence nor will it actually run LAMMPS.
For additional flexibility and automation, use the atomate2-lammps implementation
(
https://github.com/Matgenix/atomate2-lammps
).
class
LammpsInputSet
(
inputfile
:
LammpsInputFile
|
str
,
data
:
LammpsData
|
CombinedData
,
calc_type
:
str
=
''
,
template_file
:
PathLike
=
''
,
keep_stages
:
bool
=
False
)
[source]

Bases:
InputSet
Container class for all LAMMPS inputs. This class is intended to provide
general functionality that can be customized to many purposes.
InputGenerator classes elsewhere in this module are used to create
specific instances of LammpsInputSet that are tailored to specific purposes.
/!This InputSet and InputGenerator implementation is based on templates and is not intended to be very flexible.
For instance, pymatgen will not detect whether a given variable should be adapted based on others
(e.g., the number of steps from the temperature), it will not check for convergence nor will it actually run LAMMPS.
For additional flexibility and automation, use the atomate2-lammps implementation
(
https://github.com/Matgenix/atomate2-lammps
).
Parameters
:
inputfile
– The input file containing settings. It can be a LammpsInputFile object
or a string representation.
data
– The data file containing structure and topology information.
It can be a LammpsData or a CombinedData object.
calc_type
– Human-readable string used to briefly describe the type of computations performed by LAMMPS.
template_file
– Path (string) to the template file used to create the input file for LAMMPS.
keep_stages
– Whether to keep the stage structure of the LammpsInputFile or not.
classmethod
from_directory
(
directory
:
PathLike
,
keep_stages
:
bool
=
False
)
→
Self
[source]

Construct a LammpsInputSet from a directory of two or more files.
TODO: accept directories with only the input file, that should include the structure as well.
Parameters
:
directory
– Directory to read input files from. It should contain at least two files:
in.lammps for the LAMMPS input file, and system.data with the system information.
keep_stages
– Whether to keep the stage structure of the LammpsInputFile or not.
validate
(
)
→
bool
[source]

A place to implement basic checks to verify the validity of an
input set. Can be as simple or as complex as desired.
Will raise a NotImplementedError unless overloaded by the inheriting class.
pymatgen.io.lammps.utils module

This module defines utility classes and functions.
class
LammpsRunner
(
input_filename
:
str
=
'lammps.in'
,
bin
:
str
=
'lammps'
)
[source]

Bases:
object
LAMMPS wrapper.
Parameters
:
input_filename
(
str
) – input file name
bin
(
str
) – command to run, excluding the input file name.
run
(
)
→
tuple
[
bytes
,
bytes
]
[source]

Write the input/data files and run LAMMPS.
class
PackmolRunner
(
mols
:
list
,
param_list
:
list
,
input_file
:
str
=
'pack.inp'
,
tolerance
:
float
=
2.0
,
filetype
:
str
=
'xyz'
,
control_params
:
dict
|
None
=
None
,
auto_box
:
bool
=
True
,
output_file
:
str
=
'packed.xyz'
,
bin
:
str
=
'packmol'
)
[source]

Bases:
object
Wrapper for the Packmol software that can be used to pack various types of
molecules into a one single unit.
Parameters
:
mols
– list of Molecules to pack
input_file
– name of the packmol input file
tolerance
– min distance between the atoms
filetype
– input/output structure file type
control_params
– packmol control parameters dictionary. Basically
all parameters other than structure/atoms
param_list
– list of parameters containing dicts for each molecule
auto_box
– put the molecule assembly in a box
output_file
– output file name. The extension will be adjusted
according to the filetype.
convert_obatoms_to_molecule
(
atoms
:
Sequence
,
residue_name
:
str
|
None
=
None
,
site_property
:
str
=
'ff_map'
)
→
Molecule
[source]

Convert list of openbabel atoms to Molecule.
Parameters
:
atoms
(
[
OBAtom
]
) – list of OBAtom objects
residue_name
(
str
) – the key in self.map_residue_to_mol. Used to
restore the site properties in the final packed molecule.
site_property
(
str
) – the site property to be restored.
Returns
:
Molecule object
restore_site_properties
(
site_property
:
str
=
'ff_map'
,
filename
:
str
|
None
=
None
)
→
Molecule
[source]

Restore the site properties for the final packed molecule.
Parameters
:
site_property
(
str
)
filename
(
str
) – path to the final packed molecule.
Returns
:
Molecule
run
(
site_property
:
str
|
None
=
None
)
→
Molecule
[source]

Write the input file to the scratch directory, run packmol and return
the packed molecule to the current working directory.
Parameters
:
site_property
(
str
) – if set then the specified site property
for the final packed molecule will be restored.
Returns
:
Molecule object
static
write_pdb
(
mol
:
Molecule
,
filename
:
str
,
name
:
str
|
None
=
None
,
num
=
None
)
→
None
[source]

Dump the molecule into pdb file with custom residue name and number.
class
Polymer
(
start_monomer
:
Molecule
,
s_head
:
int
,
s_tail
:
int
,
monomer
:
Molecule
,
head
:
int
,
tail
:
int
,
end_monomer
:
Molecule
,
e_head
:
int
,
e_tail
:
int
,
n_units
:
int
,
link_distance
:
float
=
1.0
,
linear_chain
:
bool
=
False
)
[source]

Bases:
object
Generate polymer chain via Random walk. At each position there are
a total of 5 possible moves(excluding the previous direction).
Parameters
:
start_monomer
(
Molecule
) – Starting molecule
s_head
(
int
) – starting atom index of the start_monomer molecule
s_tail
(
int
) – tail atom index of the start_monomer
monomer
(
Molecule
) – The monomer
head
(
int
) – index of the atom in the monomer that forms the head
tail
(
int
) – tail atom index. monomers will be connected from
tail to head
end_monomer
(
Molecule
) – Terminal molecule
e_head
(
int
) – starting atom index of the end_monomer molecule
e_tail
(
int
) – tail atom index of the end_monomer
n_units
(
int
) – number of monomer units excluding the start and
terminal molecules
link_distance
(
float
) – distance between consecutive monomers
linear_chain
(
bool
) – linear or random walk polymer chain.
© Copyright 2011, Pymatgen Development Team.
Built with
Sphinx
using a
theme
provided by
Read the Docs
.