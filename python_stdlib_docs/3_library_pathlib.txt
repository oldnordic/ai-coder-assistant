Added in version 3.4.
Source code:
This module offers classes representing filesystem paths with semantics
appropriate for different operating systems.  Path classes are divided
between
, which provide purely computational
operations without I/O, and
, which
inherit from pure paths but also provide I/O operations.
If youâve never used this module before or just arenât sure which class is
right for your task,
is most likely what you need. It instantiates
a
for the platform the code is running on.
Pure paths are useful in some special cases; for example:
If you want to manipulate Windows paths on a Unix machine (or vice versa).
You cannot instantiate a
when running on Unix, but you
can instantiate
.
You want to make sure that your code only manipulates paths without actually
accessing the OS. In this case, instantiating one of the pure classes may be
useful since those simply donât have any OS-accessing operations.
See also
: The pathlib module â object-oriented filesystem paths.
See also
For low-level path manipulation on strings, you can also use the
module.
Importing the main class:
>>>
from
pathlib
import
Path
Listing subdirectories:
>>>
p
=
Path
(
'.'
)
>>>
[
x
for
x
in
p
.
iterdir
()
if
x
.
is_dir
()]
[PosixPath('.hg'), PosixPath('docs'), PosixPath('dist'),
PosixPath('__pycache__'), PosixPath('build')]
Listing Python source files in this directory tree:
>>>
list
(
p
.
glob
(
'**/*.py'
))
[PosixPath('test_pathlib.py'), PosixPath('setup.py'),
PosixPath('pathlib.py'), PosixPath('docs/conf.py'),
PosixPath('build/lib/pathlib.py')]
Navigating inside a directory tree:
>>>
p
=
Path
(
'/etc'
)
>>>
q
=
p
/
'init.d'
/
'reboot'
>>>
q
PosixPath('/etc/init.d/reboot')
>>>
q
.
resolve
()
PosixPath('/etc/rc.d/init.d/halt')
Querying path properties:
>>>
q
.
exists
()
True
>>>
q
.
is_dir
()
False
Opening a file:
>>>
with
q
.
open
()
as
f
:
f
.
readline
()
...
'#!/bin/bash\n'
exception
pathlib.
UnsupportedOperation
An exception inheriting
that is raised when an
unsupported operation is called on a path object.
Added in version 3.13.
Pure path objects provide path-handling operations which donât actually
access a filesystem.  There are three ways to access these classes, which
we also call
flavours
:
class
pathlib.
PurePath
(
*
pathsegments
)
A generic class that represents the systemâs path flavour (instantiating
it creates either a
or a
):
>>>
PurePath
(
'setup.py'
)
# Running on a Unix machine
PurePosixPath('setup.py')
Each element of
pathsegments
can be either a string representing a
path segment, or an object implementing the
interface
where the
method returns a string,
such as another path object:
>>>
PurePath
(
'foo'
,
'some/path'
,
'bar'
)
PurePosixPath('foo/some/path/bar')
>>>
PurePath
(
Path
(
'foo'
),
Path
(
'bar'
))
PurePosixPath('foo/bar')
When
pathsegments
is empty, the current directory is assumed:
>>>
PurePath
()
PurePosixPath('.')
If a segment is an absolute path, all previous segments are ignored
(like
):
>>>
PurePath
(
'/etc'
,
'/usr'
,
'lib64'
)
PurePosixPath('/usr/lib64')
>>>
PureWindowsPath
(
'c:/Windows'
,
'd:bar'
)
PureWindowsPath('d:bar')
On Windows, the drive is not reset when a rooted relative path
segment (e.g.,
r'\foo'
) is encountered:
>>>
PureWindowsPath
(
'c:/Windows'
,
'/Program Files'
)
PureWindowsPath('c:/Program Files')
Spurious slashes and single dots are collapsed, but double dots (
'..'
)
and leading double slashes (
'//'
) are not, since this would change the
meaning of a path for various reasons (e.g. symbolic links, UNC paths):
>>>
PurePath
(
'foo//bar'
)
PurePosixPath('foo/bar')
>>>
PurePath
(
'//foo/bar'
)
PurePosixPath('//foo/bar')
>>>
PurePath
(
'foo/./bar'
)
PurePosixPath('foo/bar')
>>>
PurePath
(
'foo/../bar'
)
PurePosixPath('foo/../bar')
(a naÃ¯ve approach would make
PurePosixPath('foo/../bar')
equivalent
to
PurePosixPath('bar')
, which is wrong if
foo
is a symbolic link
to another directory)
Pure path objects implement the
interface, allowing them
to be used anywhere the interface is accepted.
Changed in version 3.6:
Added support for the
interface.
class
pathlib.
PurePosixPath
(
*
pathsegments
)
A subclass of
, this path flavour represents non-Windows
filesystem paths:
>>>
PurePosixPath
(
'/etc/hosts'
)
PurePosixPath('/etc/hosts')
pathsegments
is specified similarly to
.
class
pathlib.
PureWindowsPath
(
*
pathsegments
)
A subclass of
, this path flavour represents Windows
filesystem paths, including
:
>>>
PureWindowsPath
(
'c:/'
,
'Users'
,
'XimÃ©nez'
)
PureWindowsPath('c:/Users/XimÃ©nez')
>>>
PureWindowsPath
(
'//server/share/file'
)
PureWindowsPath('//server/share/file')
pathsegments
is specified similarly to
.
Regardless of the system youâre running on, you can instantiate all of
these classes, since they donât provide any operation that does system calls.
Paths are immutable and
.  Paths of a same flavour are comparable
and orderable.  These properties respect the flavourâs case-folding
semantics:
>>>
PurePosixPath
(
'foo'
)
==
PurePosixPath
(
'FOO'
)
False
>>>
PureWindowsPath
(
'foo'
)
==
PureWindowsPath
(
'FOO'
)
True
>>>
PureWindowsPath
(
'FOO'
)
in
{
PureWindowsPath
(
'foo'
)
}
True
>>>
PureWindowsPath
(
'C:'
)
<
PureWindowsPath
(
'd:'
)
True
Paths of a different flavour compare unequal and cannot be ordered:
>>>
PureWindowsPath
(
'foo'
)
==
PurePosixPath
(
'foo'
)
False
>>>
PureWindowsPath
(
'foo'
)
<
PurePosixPath
(
'foo'
)
Traceback (most recent call last):
File
"<stdin>"
, line
1
, in
<module>
TypeError
:
'<' not supported between instances of 'PureWindowsPath' and 'PurePosixPath'
The slash operator helps create child paths, like
.
If the argument is an absolute path, the previous path is ignored.
On Windows, the drive is not reset when the argument is a rooted
relative path (e.g.,
r'\foo'
):
>>>
p
=
PurePath
(
'/etc'
)
>>>
p
PurePosixPath('/etc')
>>>
p
/
'init.d'
/
'apache2'
PurePosixPath('/etc/init.d/apache2')
>>>
q
=
PurePath
(
'bin'
)
>>>
'/usr'
/
q
PurePosixPath('/usr/bin')
>>>
p
/
'/an_absolute_path'
PurePosixPath('/an_absolute_path')
>>>
PureWindowsPath
(
'c:/Windows'
,
'/Program Files'
)
PureWindowsPath('c:/Program Files')
A path object can be used anywhere an object implementing
is accepted:
>>>
import
os
>>>
p
=
PurePath
(
'/etc'
)
>>>
os
.
fspath
(
p
)
'/etc'
The string representation of a path is the raw filesystem path itself
(in native form, e.g. with backslashes under Windows), which you can
pass to any function taking a file path as a string:
>>>
p
=
PurePath
(
'/etc'
)
>>>
str
(
p
)
'/etc'
>>>
p
=
PureWindowsPath
(
'c:/Program Files'
)
>>>
str
(
p
)
'c:\\Program Files'
Similarly, calling
on a path gives the raw filesystem path as a
bytes object, as encoded by
:
>>>
bytes
(
p
)
b'/etc'
Note
Calling
is only recommended under Unix.  Under Windows,
the unicode form is the canonical representation of filesystem paths.
To access the individual âpartsâ (components) of a path, use the following
property:
PurePath.
parts
A tuple giving access to the pathâs various components:
>>>
p
=
PurePath
(
'/usr/bin/python3'
)
>>>
p
.
parts
('/', 'usr', 'bin', 'python3')
>>>
p
=
PureWindowsPath
(
'c:/Program Files/PSF'
)
>>>
p
.
parts
('c:\\', 'Program Files', 'PSF')
(note how the drive and local root are regrouped in a single part)
Pure paths provide the following methods and properties:
PurePath.
parser
The implementation of the
module used for low-level path
parsing and joining: either
posixpath
or
ntpath
.
Added in version 3.13.
PurePath.
drive
A string representing the drive letter or name, if any:
>>>
PureWindowsPath
(
'c:/Program Files/'
)
.
drive
'c:'
>>>
PureWindowsPath
(
'/Program Files/'
)
.
drive
''
>>>
PurePosixPath
(
'/etc'
)
.
drive
''
UNC shares are also considered drives:
>>>
PureWindowsPath
(
'//host/share/foo.txt'
)
.
drive
'\\\\host\\share'
PurePath.
root
A string representing the (local or global) root, if any:
>>>
PureWindowsPath
(
'c:/Program Files/'
)
.
root
'\\'
>>>
PureWindowsPath
(
'c:Program Files/'
)
.
root
''
>>>
PurePosixPath
(
'/etc'
)
.
root
'/'
UNC shares always have a root:
>>>
PureWindowsPath
(
'//host/share'
)
.
root
'\\'
If the path starts with more than two successive slashes,
collapses them:
>>>
PurePosixPath
(
'//etc'
)
.
root
'//'
>>>
PurePosixPath
(
'///etc'
)
.
root
'/'
>>>
PurePosixPath
(
'////etc'
)
.
root
'/'
Note
This behavior conforms to
The Open Group Base Specifications Issue 6
,
paragraph
:
âA pathname that begins with two successive slashes may be interpreted in
an implementation-defined manner, although more than two leading slashes
shall be treated as a single slash.â
PurePath.
anchor
The concatenation of the drive and root:
>>>
PureWindowsPath
(
'c:/Program Files/'
)
.
anchor
'c:\\'
>>>
PureWindowsPath
(
'c:Program Files/'
)
.
anchor
'c:'
>>>
PurePosixPath
(
'/etc'
)
.
anchor
'/'
>>>
PureWindowsPath
(
'//host/share'
)
.
anchor
'\\\\host\\share\\'
PurePath.
parents
An immutable sequence providing access to the logical ancestors of
the path:
>>>
p
=
PureWindowsPath
(
'c:/foo/bar/setup.py'
)
>>>
p
.
parents
[
0
]
PureWindowsPath('c:/foo/bar')
>>>
p
.
parents
[
1
]
PureWindowsPath('c:/foo')
>>>
p
.
parents
[
2
]
PureWindowsPath('c:/')
Changed in version 3.10:
The parents sequence now supports
and negative index values.
PurePath.
parent
The logical parent of the path:
>>>
p
=
PurePosixPath
(
'/a/b/c/d'
)
>>>
p
.
parent
PurePosixPath('/a/b/c')
You cannot go past an anchor, or empty path:
>>>
p
=
PurePosixPath
(
'/'
)
>>>
p
.
parent
PurePosixPath('/')
>>>
p
=
PurePosixPath
(
'.'
)
>>>
p
.
parent
PurePosixPath('.')
Note
This is a purely lexical operation, hence the following behaviour:
>>>
p
=
PurePosixPath
(
'foo/..'
)
>>>
p
.
parent
PurePosixPath('foo')
If you want to walk an arbitrary filesystem path upwards, it is
recommended to first call
so as to resolve
symlinks and eliminate
".."
components.
PurePath.
name
A string representing the final path component, excluding the drive and
root, if any:
>>>
PurePosixPath
(
'my/library/setup.py'
)
.
name
'setup.py'
UNC drive names are not considered:
>>>
PureWindowsPath
(
'//some/share/setup.py'
)
.
name
'setup.py'
>>>
PureWindowsPath
(
'//some/share'
)
.
name
''
PurePath.
suffix
The last dot-separated portion of the final component, if any:
>>>
PurePosixPath
(
'my/library/setup.py'
)
.
suffix
'.py'
>>>
PurePosixPath
(
'my/library.tar.gz'
)
.
suffix
'.gz'
>>>
PurePosixPath
(
'my/library'
)
.
suffix
''
This is commonly called the file extension.
PurePath.
suffixes
A list of the pathâs suffixes, often called file extensions:
>>>
PurePosixPath
(
'my/library.tar.gar'
)
.
suffixes
['.tar', '.gar']
>>>
PurePosixPath
(
'my/library.tar.gz'
)
.
suffixes
['.tar', '.gz']
>>>
PurePosixPath
(
'my/library'
)
.
suffixes
[]
PurePath.
stem
The final path component, without its suffix:
>>>
PurePosixPath
(
'my/library.tar.gz'
)
.
stem
'library.tar'
>>>
PurePosixPath
(
'my/library.tar'
)
.
stem
'library'
>>>
PurePosixPath
(
'my/library'
)
.
stem
'library'
PurePath.
as_posix
(
)
Return a string representation of the path with forward slashes (
/
):
>>>
p
=
PureWindowsPath
(
'c:
\\
windows'
)
>>>
str
(
p
)
'c:\\windows'
>>>
p
.
as_posix
()
'c:/windows'
PurePath.
is_absolute
(
)
Return whether the path is absolute or not.  A path is considered absolute
if it has both a root and (if the flavour allows) a drive:
>>>
PurePosixPath
(
'/a/b'
)
.
is_absolute
()
True
>>>
PurePosixPath
(
'a/b'
)
.
is_absolute
()
False
>>>
PureWindowsPath
(
'c:/a/b'
)
.
is_absolute
()
True
>>>
PureWindowsPath
(
'/a/b'
)
.
is_absolute
()
False
>>>
PureWindowsPath
(
'c:'
)
.
is_absolute
()
False
>>>
PureWindowsPath
(
'//some/share'
)
.
is_absolute
()
True
PurePath.
is_relative_to
(
other
)
Return whether or not this path is relative to the
other
path.
>>>
p
=
PurePath
(
'/etc/passwd'
)
>>>
p
.
is_relative_to
(
'/etc'
)
True
>>>
p
.
is_relative_to
(
'/usr'
)
False
This method is string-based; it neither accesses the filesystem nor treats
â
..
â segments specially. The following code is equivalent:
>>>
u
=
PurePath
(
'/usr'
)
>>>
u
==
p
or
u
in
p
.
parents
False
Added in version 3.9.
Deprecated since version 3.12, will be removed in version 3.14:
Passing additional arguments is deprecated; if supplied, they are joined
with
other
.
PurePath.
is_reserved
(
)
With
, return
True
if the path is considered
reserved under Windows,
False
otherwise.  With
,
False
is always returned.
Changed in version 3.13:
Windows path names that contain a colon, or end with a dot or a space,
are considered reserved. UNC paths may be reserved.
Deprecated since version 3.13, will be removed in version 3.15:
This method is deprecated; use
to detect
reserved paths on Windows.
PurePath.
joinpath
(
*
pathsegments
)
Calling this method is equivalent to combining the path with each of
the given
pathsegments
in turn:
>>>
PurePosixPath
(
'/etc'
)
.
joinpath
(
'passwd'
)
PurePosixPath('/etc/passwd')
>>>
PurePosixPath
(
'/etc'
)
.
joinpath
(
PurePosixPath
(
'passwd'
))
PurePosixPath('/etc/passwd')
>>>
PurePosixPath
(
'/etc'
)
.
joinpath
(
'init.d'
,
'apache2'
)
PurePosixPath('/etc/init.d/apache2')
>>>
PureWindowsPath
(
'c:'
)
.
joinpath
(
'/Program Files'
)
PureWindowsPath('c:/Program Files')
PurePath.
full_match
(
pattern
,
*
,
case_sensitive
=
None
)
Match this path against the provided glob-style pattern.  Return
True
if matching is successful,
False
otherwise.  For example:
>>>
PurePath
(
'a/b.py'
)
.
full_match
(
'a/*.py'
)
True
>>>
PurePath
(
'a/b.py'
)
.
full_match
(
'*.py'
)
False
>>>
PurePath
(
'/a/b/c.py'
)
.
full_match
(
'/a/**'
)
True
>>>
PurePath
(
'/a/b/c.py'
)
.
full_match
(
'**/*.py'
)
True
See also
documentation.
As with other methods, case-sensitivity follows platform defaults:
>>>
PurePosixPath
(
'b.py'
)
.
full_match
(
'*.PY'
)
False
>>>
PureWindowsPath
(
'b.py'
)
.
full_match
(
'*.PY'
)
True
Set
case_sensitive
to
True
or
False
to override this behaviour.
Added in version 3.13.
PurePath.
match
(
pattern
,
*
,
case_sensitive
=
None
)
Match this path against the provided non-recursive glob-style pattern.
Return
True
if matching is successful,
False
otherwise.
This method is similar to
, but empty patterns
arenât allowed (
is raised), the recursive wildcard
â
**
â isnât supported (it acts like non-recursive â
*
â), and if a
relative pattern is provided, then matching is done from the right:
>>>
PurePath
(
'a/b.py'
)
.
match
(
'*.py'
)
True
>>>
PurePath
(
'/a/b/c.py'
)
.
match
(
'b/*.py'
)
True
>>>
PurePath
(
'/a/b/c.py'
)
.
match
(
'a/*.py'
)
False
Changed in version 3.12:
The
pattern
parameter accepts a
.
Changed in version 3.12:
The
case_sensitive
parameter was added.
PurePath.
relative_to
(
other
,
walk_up
=
False
)
Compute a version of this path relative to the path represented by
other
.  If itâs impossible,
is raised:
>>>
p
=
PurePosixPath
(
'/etc/passwd'
)
>>>
p
.
relative_to
(
'/'
)
PurePosixPath('etc/passwd')
>>>
p
.
relative_to
(
'/etc'
)
PurePosixPath('passwd')
>>>
p
.
relative_to
(
'/usr'
)
Traceback (most recent call last):
File
"<stdin>"
, line
1
, in
<module>
File
"pathlib.py"
, line
941
, in
relative_to
raise
ValueError
(
error_message
.
format
(
str
(
self
),
str
(
formatted
)))
ValueError
:
'/etc/passwd' is not in the subpath of '/usr' OR one path is relative and the other is absolute.
When
walk_up
is false (the default), the path must start with
other
.
When the argument is true,
..
entries may be added to form the
relative path. In all other cases, such as the paths referencing
different drives,
is raised.:
>>>
p
.
relative_to
(
'/usr'
,
walk_up
=
True
)
PurePosixPath('../etc/passwd')
>>>
p
.
relative_to
(
'foo'
,
walk_up
=
True
)
Traceback (most recent call last):
File
"<stdin>"
, line
1
, in
<module>
File
"pathlib.py"
, line
941
, in
relative_to
raise
ValueError
(
error_message
.
format
(
str
(
self
),
str
(
formatted
)))
ValueError
:
'/etc/passwd' is not on the same drive as 'foo' OR one path is relative and the other is absolute.
Warning
This function is part of
and works with strings.
It does not check or access the underlying file structure.
This can impact the
walk_up
option as it assumes that no symlinks
are present in the path; call
first if
necessary to resolve symlinks.
Changed in version 3.12:
The
walk_up
parameter was added (old behavior is the same as
walk_up=False
).
Deprecated since version 3.12, will be removed in version 3.14:
Passing additional positional arguments is deprecated; if supplied,
they are joined with
other
.
PurePath.
with_name
(
name
)
Return a new path with the
changed.  If the original path
doesnât have a name, ValueError is raised:
>>>
p
=
PureWindowsPath
(
'c:/Downloads/pathlib.tar.gz'
)
>>>
p
.
with_name
(
'setup.py'
)
PureWindowsPath('c:/Downloads/setup.py')
>>>
p
=
PureWindowsPath
(
'c:/'
)
>>>
p
.
with_name
(
'setup.py'
)
Traceback (most recent call last):
File
"<stdin>"
, line
1
, in
<module>
File
"/home/antoine/cpython/default/Lib/pathlib.py"
, line
751
, in
with_name
raise
ValueError
(
"
%r
has an empty name"
%
(
self
,))
ValueError
:
PureWindowsPath('c:/') has an empty name
PurePath.
with_stem
(
stem
)
Return a new path with the
changed.  If the original path
doesnât have a name, ValueError is raised:
>>>
p
=
PureWindowsPath
(
'c:/Downloads/draft.txt'
)
>>>
p
.
with_stem
(
'final'
)
PureWindowsPath('c:/Downloads/final.txt')
>>>
p
=
PureWindowsPath
(
'c:/Downloads/pathlib.tar.gz'
)
>>>
p
.
with_stem
(
'lib'
)
PureWindowsPath('c:/Downloads/lib.gz')
>>>
p
=
PureWindowsPath
(
'c:/'
)
>>>
p
.
with_stem
(
''
)
Traceback (most recent call last):
File
"<stdin>"
, line
1
, in
<module>
File
"/home/antoine/cpython/default/Lib/pathlib.py"
, line
861
, in
with_stem
return
self
.
with_name
(
stem
+
self
.
suffix
)
File
"/home/antoine/cpython/default/Lib/pathlib.py"
, line
851
, in
with_name
raise
ValueError
(
"
%r
has an empty name"
%
(
self
,))
ValueError
:
PureWindowsPath('c:/') has an empty name
Added in version 3.9.
PurePath.
with_suffix
(
suffix
)
Return a new path with the
changed.  If the original path
doesnât have a suffix, the new
suffix
is appended instead.  If the
suffix
is an empty string, the original suffix is removed:
>>>
p
=
PureWindowsPath
(
'c:/Downloads/pathlib.tar.gz'
)
>>>
p
.
with_suffix
(
'.bz2'
)
PureWindowsPath('c:/Downloads/pathlib.tar.bz2')
>>>
p
=
PureWindowsPath
(
'README'
)
>>>
p
.
with_suffix
(
'.txt'
)
PureWindowsPath('README.txt')
>>>
p
=
PureWindowsPath
(
'README.txt'
)
>>>
p
.
with_suffix
(
''
)
PureWindowsPath('README')
PurePath.
with_segments
(
*
pathsegments
)
Create a new path object of the same type by combining the given
pathsegments
. This method is called whenever a derivative path is created,
such as from
and
. Subclasses may
override this method to pass information to derivative paths, for example:
from
pathlib
import
PurePosixPath
class
MyPath
(
PurePosixPath
):
def
__init__
(
self
,
*
pathsegments
,
session_id
):
super
()
.
__init__
(
*
pathsegments
)
self
.
session_id
=
session_id
def
with_segments
(
self
,
*
pathsegments
):
return
type
(
self
)(
*
pathsegments
,
session_id
=
self
.
session_id
)
etc
=
MyPath
(
'/etc'
,
session_id
=
42
)
hosts
=
etc
/
'hosts'
print
(
hosts
.
session_id
)
# 42
Added in version 3.12.
Concrete paths are subclasses of the pure path classes.  In addition to
operations provided by the latter, they also provide methods to do system
calls on path objects.  There are three ways to instantiate concrete paths:
class
pathlib.
Path
(
*
pathsegments
)
A subclass of
, this class represents concrete paths of
the systemâs path flavour (instantiating it creates either a
or a
):
>>>
Path
(
'setup.py'
)
PosixPath('setup.py')
pathsegments
is specified similarly to
.
class
pathlib.
PosixPath
(
*
pathsegments
)
A subclass of
and
, this class
represents concrete non-Windows filesystem paths:
>>>
PosixPath
(
'/etc/hosts'
)
PosixPath('/etc/hosts')
pathsegments
is specified similarly to
.
Changed in version 3.13:
Raises
on Windows. In previous versions,
was raised instead.
class
pathlib.
WindowsPath
(
*
pathsegments
)
A subclass of
and
, this class
represents concrete Windows filesystem paths:
>>>
WindowsPath
(
'c:/'
,
'Users'
,
'XimÃ©nez'
)
WindowsPath('c:/Users/XimÃ©nez')
pathsegments
is specified similarly to
.
Changed in version 3.13:
Raises
on non-Windows platforms. In previous
versions,
was raised instead.
You can only instantiate the class flavour that corresponds to your system
(allowing system calls on non-compatible path flavours could lead to
bugs or failures in your application):
>>>
import
os
>>>
os
.
name
'posix'
>>>
Path
(
'setup.py'
)
PosixPath('setup.py')
>>>
PosixPath
(
'setup.py'
)
PosixPath('setup.py')
>>>
WindowsPath
(
'setup.py'
)
Traceback (most recent call last):
File
"<stdin>"
, line
1
, in
<module>
File
"pathlib.py"
, line
798
, in
__new__
%
(
cls
.
__name__
,))
UnsupportedOperation
:
cannot instantiate 'WindowsPath' on your system
Some concrete path methods can raise an
if a system call fails
(for example because the path doesnât exist).
Concrete path objects can be created from, and represented as, âfileâ URIs
conforming to
.
Note
File URIs are not portable across machines with different
.
classmethod
Path.
from_uri
(
uri
)
Return a new path object from parsing a âfileâ URI. For example:
>>>
p
=
Path
.
from_uri
(
'file:///etc/hosts'
)
PosixPath('/etc/hosts')
On Windows, DOS device and UNC paths may be parsed from URIs:
>>>
p
=
Path
.
from_uri
(
'file:///c:/windows'
)
WindowsPath('c:/windows')
>>>
p
=
Path
.
from_uri
(
'file://server/share'
)
WindowsPath('//server/share')
Several variant forms are supported:
>>>
p
=
Path
.
from_uri
(
'file:////server/share'
)
WindowsPath('//server/share')
>>>
p
=
Path
.
from_uri
(
'file://///server/share'
)
WindowsPath('//server/share')
>>>
p
=
Path
.
from_uri
(
'file:c:/windows'
)
WindowsPath('c:/windows')
>>>
p
=
Path
.
from_uri
(
'file:/c|/windows'
)
WindowsPath('c:/windows')
is raised if the URI does not start with
file:
, or
the parsed path isnât absolute.
Added in version 3.13.
Path.
as_uri
(
)
Represent the path as a âfileâ URI.
is raised if
the path isnât absolute.
>>>
p
=
PosixPath
(
'/etc/passwd'
)
>>>
p
.
as_uri
()
'file:///etc/passwd'
>>>
p
=
WindowsPath
(
'c:/Windows'
)
>>>
p
.
as_uri
()
'file:///c:/Windows'
For historical reasons, this method is also available from
objects. However, its use of
makes
it strictly impure.
classmethod
Path.
home
(
)
Return a new path object representing the userâs home directory (as
returned by
with
~
construct). If the home
directory canât be resolved,
is raised.
>>>
Path
.
home
()
PosixPath('/home/antoine')
Added in version 3.5.
Path.
expanduser
(
)
Return a new path with expanded
~
and
~user
constructs,
as returned by
. If a home directory canât be
resolved,
is raised.
>>>
p
=
PosixPath
(
'~/films/Monty Python'
)
>>>
p
.
expanduser
()
PosixPath('/home/eric/films/Monty Python')
Added in version 3.5.
classmethod
Path.
cwd
(
)
Return a new path object representing the current directory (as returned
by
):
>>>
Path
.
cwd
()
PosixPath('/home/antoine/pathlib')
Path.
absolute
(
)
Make the path absolute, without normalization or resolving symlinks.
Returns a new path object:
>>>
p
=
Path
(
'tests'
)
>>>
p
PosixPath('tests')
>>>
p
.
absolute
()
PosixPath('/home/antoine/pathlib/tests')
Path.
resolve
(
strict
=
False
)
Make the path absolute, resolving any symlinks.  A new path object is
returned:
>>>
p
=
Path
()
>>>
p
PosixPath('.')
>>>
p
.
resolve
()
PosixPath('/home/antoine/pathlib')
â
..
â components are also eliminated (this is the only method to do so):
>>>
p
=
Path
(
'docs/../setup.py'
)
>>>
p
.
resolve
()
PosixPath('/home/antoine/pathlib/setup.py')
If a path doesnât exist or a symlink loop is encountered, and
strict
is
True
,
is raised.  If
strict
is
False
, the path is
resolved as far as possible and any remainder is appended without checking
whether it exists.
Changed in version 3.6:
The
strict
parameter was added (pre-3.6 behavior is strict).
Changed in version 3.13:
Symlink loops are treated like other errors:
is raised in
strict mode, and no exception is raised in non-strict mode. In previous
versions,
is raised no matter the value of
strict
.
Path.
readlink
(
)
Return the path to which the symbolic link points (as returned by
):
>>>
p
=
Path
(
'mylink'
)
>>>
p
.
symlink_to
(
'setup.py'
)
>>>
p
.
readlink
()
PosixPath('setup.py')
Added in version 3.9.
Changed in version 3.13:
Raises
if
is not
available. In previous versions,
was raised.
Changed in version 3.8:
,
,
,
,
,
,
,
,
now return
False
instead of raising an exception for paths that contain characters
unrepresentable at the OS level.
Path.
stat
(
*
,
follow_symlinks
=
True
)
Return an
object containing information about this path, like
.
The result is looked up at each call to this method.
This method normally follows symlinks; to stat a symlink add the argument
follow_symlinks=False
, or use
.
>>>
p
=
Path
(
'setup.py'
)
>>>
p
.
stat
()
.
st_size
956
>>>
p
.
stat
()
.
st_mtime
1327883547.852554
Changed in version 3.10:
The
follow_symlinks
parameter was added.
Path.
lstat
(
)
Like
but, if the path points to a symbolic link, return
the symbolic linkâs information rather than its targetâs.
Path.
exists
(
*
,
follow_symlinks
=
True
)
Return
True
if the path points to an existing file or directory.
This method normally follows symlinks; to check if a symlink exists, add
the argument
follow_symlinks=False
.
>>>
Path
(
'.'
)
.
exists
()
True
>>>
Path
(
'setup.py'
)
.
exists
()
True
>>>
Path
(
'/etc'
)
.
exists
()
True
>>>
Path
(
'nonexistentfile'
)
.
exists
()
False
Changed in version 3.12:
The
follow_symlinks
parameter was added.
Path.
is_file
(
*
,
follow_symlinks
=
True
)
Return
True
if the path points to a regular file,
False
if it
points to another kind of file.
False
is also returned if the path doesnât exist or is a broken symlink;
other errors (such as permission errors) are propagated.
This method normally follows symlinks; to exclude symlinks, add the
argument
follow_symlinks=False
.
Changed in version 3.13:
The
follow_symlinks
parameter was added.
Path.
is_dir
(
*
,
follow_symlinks
=
True
)
Return
True
if the path points to a directory,
False
if it points
to another kind of file.
False
is also returned if the path doesnât exist or is a broken symlink;
other errors (such as permission errors) are propagated.
This method normally follows symlinks; to exclude symlinks to directories,
add the argument
follow_symlinks=False
.
Changed in version 3.13:
The
follow_symlinks
parameter was added.
Path.
is_symlink
(
)
Return
True
if the path points to a symbolic link,
False
otherwise.
False
is also returned if the path doesnât exist; other errors (such
as permission errors) are propagated.
Path.
is_junction
(
)
Return
True
if the path points to a junction, and
False
for any other
type of file. Currently only Windows supports junctions.
Added in version 3.12.
Path.
is_mount
(
)
Return
True
if the path is a
mount point
: a point in a
file system where a different file system has been mounted.  On POSIX, the
function checks whether
path
âs parent,
path/..
, is on a different
device than
path
, or whether
path/..
and
path
point to the same
i-node on the same device â this should detect mount points for all Unix
and POSIX variants.  On Windows, a mount point is considered to be a drive
letter root (e.g.
c:\
), a UNC share (e.g.
\\server\share
), or a
mounted filesystem directory.
Added in version 3.7.
Changed in version 3.12:
Windows support was added.
Path.
is_socket
(
)
Return
True
if the path points to a Unix socket (or a symbolic link
pointing to a Unix socket),
False
if it points to another kind of file.
False
is also returned if the path doesnât exist or is a broken symlink;
other errors (such as permission errors) are propagated.
Path.
is_fifo
(
)
Return
True
if the path points to a FIFO (or a symbolic link
pointing to a FIFO),
False
if it points to another kind of file.
False
is also returned if the path doesnât exist or is a broken symlink;
other errors (such as permission errors) are propagated.
Path.
is_block_device
(
)
Return
True
if the path points to a block device (or a symbolic link
pointing to a block device),
False
if it points to another kind of file.
False
is also returned if the path doesnât exist or is a broken symlink;
other errors (such as permission errors) are propagated.
Path.
is_char_device
(
)
Return
True
if the path points to a character device (or a symbolic link
pointing to a character device),
False
if it points to another kind of file.
False
is also returned if the path doesnât exist or is a broken symlink;
other errors (such as permission errors) are propagated.
Path.
samefile
(
other_path
)
Return whether this path points to the same file as
other_path
, which
can be either a Path object, or a string.  The semantics are similar
to
and
.
An
can be raised if either file cannot be accessed for some
reason.
>>>
p
=
Path
(
'spam'
)
>>>
q
=
Path
(
'eggs'
)
>>>
p
.
samefile
(
q
)
False
>>>
p
.
samefile
(
'spam'
)
True
Added in version 3.5.
Path.
open
(
mode
=
'r'
,
buffering
=
-1
,
encoding
=
None
,
errors
=
None
,
newline
=
None
)
Open the file pointed to by the path, like the built-in
function does:
>>>
p
=
Path
(
'setup.py'
)
>>>
with
p
.
open
()
as
f
:
...
f
.
readline
()
...
'#!/usr/bin/env python3\n'
Path.
read_text
(
encoding
=
None
,
errors
=
None
,
newline
=
None
)
Return the decoded contents of the pointed-to file as a string:
>>>
p
=
Path
(
'my_text_file'
)
>>>
p
.
write_text
(
'Text file contents'
)
18
>>>
p
.
read_text
()
'Text file contents'
The file is opened and then closed. The optional parameters have the same
meaning as in
.
Added in version 3.5.
Changed in version 3.13:
The
newline
parameter was added.
Path.
read_bytes
(
)
Return the binary contents of the pointed-to file as a bytes object:
>>>
p
=
Path
(
'my_binary_file'
)
>>>
p
.
write_bytes
(
b
'Binary file contents'
)
20
>>>
p
.
read_bytes
()
b'Binary file contents'
Added in version 3.5.
Path.
write_text
(
data
,
encoding
=
None
,
errors
=
None
,
newline
=
None
)
Open the file pointed to in text mode, write
data
to it, and close the
file:
>>>
p
=
Path
(
'my_text_file'
)
>>>
p
.
write_text
(
'Text file contents'
)
18
>>>
p
.
read_text
()
'Text file contents'
An existing file of the same name is overwritten. The optional parameters
have the same meaning as in
.
Added in version 3.5.
Changed in version 3.10:
The
newline
parameter was added.
Path.
write_bytes
(
data
)
Open the file pointed to in bytes mode, write
data
to it, and close the
file:
>>>
p
=
Path
(
'my_binary_file'
)
>>>
p
.
write_bytes
(
b
'Binary file contents'
)
20
>>>
p
.
read_bytes
()
b'Binary file contents'
An existing file of the same name is overwritten.
Added in version 3.5.
Path.
iterdir
(
)
When the path points to a directory, yield path objects of the directory
contents:
>>>
p
=
Path
(
'docs'
)
>>>
for
child
in
p
.
iterdir
():
child
...
PosixPath('docs/conf.py')
PosixPath('docs/_templates')
PosixPath('docs/make.bat')
PosixPath('docs/index.rst')
PosixPath('docs/_build')
PosixPath('docs/_static')
PosixPath('docs/Makefile')
The children are yielded in arbitrary order, and the special entries
'.'
and
'..'
are not included.  If a file is removed from or added
to the directory after creating the iterator, it is unspecified whether
a path object for that file is included.
If the path is not a directory or otherwise inaccessible,
is
raised.
Path.
glob
(
pattern
,
*
,
case_sensitive
=
None
,
recurse_symlinks
=
False
)
Glob the given relative
pattern
in the directory represented by this path,
yielding all matching files (of any kind):
>>>
sorted
(
Path
(
'.'
)
.
glob
(
'*.py'
))
[PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib.py')]
>>>
sorted
(
Path
(
'.'
)
.
glob
(
'*/*.py'
))
[PosixPath('docs/conf.py')]
>>>
sorted
(
Path
(
'.'
)
.
glob
(
'**/*.py'
))
[PosixPath('build/lib/pathlib.py'),
PosixPath('docs/conf.py'),
PosixPath('pathlib.py'),
PosixPath('setup.py'),
PosixPath('test_pathlib.py')]
See also
documentation.
By default, or when the
case_sensitive
keyword-only argument is set to
None
, this method matches paths using platform-specific casing rules:
typically, case-sensitive on POSIX, and case-insensitive on Windows.
Set
case_sensitive
to
True
or
False
to override this behaviour.
By default, or when the
recurse_symlinks
keyword-only argument is set to
False
, this method follows symlinks except when expanding â
**
â
wildcards. Set
recurse_symlinks
to
True
to always follow symlinks.
Raises an
pathlib.Path.glob
with arguments
self
,
pattern
.
Changed in version 3.12:
The
case_sensitive
parameter was added.
Changed in version 3.13:
The
recurse_symlinks
parameter was added.
Changed in version 3.13:
The
pattern
parameter accepts a
.
Changed in version 3.13:
Any
exceptions raised from scanning the filesystem are
suppressed. In previous versions, such exceptions are suppressed in many
cases, but not all.
Path.
rglob
(
pattern
,
*
,
case_sensitive
=
None
,
recurse_symlinks
=
False
)
Glob the given relative
pattern
recursively.  This is like calling
with â
**/
â added in front of the
pattern
.
See also
and
documentation.
Raises an
pathlib.Path.rglob
with arguments
self
,
pattern
.
Changed in version 3.12:
The
case_sensitive
parameter was added.
Changed in version 3.13:
The
recurse_symlinks
parameter was added.
Changed in version 3.13:
The
pattern
parameter accepts a
.
Path.
walk
(
top_down
=
True
,
on_error
=
None
,
follow_symlinks
=
False
)
Generate the file names in a directory tree by walking the tree
either top-down or bottom-up.
For each directory in the directory tree rooted at
self
(including
self
but excluding â.â and â..â), the method yields a 3-tuple of
(dirpath,
dirnames,
filenames)
.
dirpath
is a
to the directory currently being walked,
dirnames
is a list of strings for the names of subdirectories in
dirpath
(excluding
'.'
and
'..'
), and
filenames
is a list of strings for
the names of the non-directory files in
dirpath
. To get a full path
(which begins with
self
) to a file or directory in
dirpath
, do
dirpath
/
name
. Whether or not the lists are sorted is file
system-dependent.
If the optional argument
top_down
is true (which is the default), the triple for a
directory is generated before the triples for any of its subdirectories
(directories are walked top-down).  If
top_down
is false, the triple
for a directory is generated after the triples for all of its subdirectories
(directories are walked bottom-up). No matter the value of
top_down
, the
list of subdirectories is retrieved before the triples for the directory and
its subdirectories are walked.
When
top_down
is true, the caller can modify the
dirnames
list in-place
(for example, using
or slice assignment), and
will only recurse into the subdirectories whose names remain in
dirnames
.
This can be used to prune the search, or to impose a specific order of visiting,
or even to inform
about directories the caller creates or
renames before it resumes
again. Modifying
dirnames
when
top_down
is false has no effect on the behavior of
since the
directories in
dirnames
have already been generated by the time
dirnames
is yielded to the caller.
By default, errors from
are ignored.  If the optional
argument
on_error
is specified, it should be a callable; it will be
called with one argument, an
instance. The callable can handle the
error to continue the walk or re-raise it to stop the walk. Note that the
filename is available as the
filename
attribute of the exception object.
By default,
does not follow symbolic links, and instead adds them
to the
filenames
list. Set
follow_symlinks
to true to resolve symlinks
and place them in
dirnames
and
filenames
as appropriate for their targets, and
consequently visit directories pointed to by symlinks (where supported).
Note
Be aware that setting
follow_symlinks
to true can lead to infinite
recursion if a link points to a parent directory of itself.
does not keep track of the directories it has already visited.
Note
assumes the directories it walks are not modified during
execution. For example, if a directory from
dirnames
has been replaced
with a symlink and
follow_symlinks
is false,
will
still try to descend into it. To prevent such behavior, remove directories
from
dirnames
as appropriate.
Note
Unlike
,
lists symlinks to directories in
filenames
if
follow_symlinks
is false.
This example displays the number of bytes used by all files in each directory,
while ignoring
__pycache__
directories:
from
pathlib
import
Path
for
root
,
dirs
,
files
in
Path
(
"cpython/Lib/concurrent"
)
.
walk
(
on_error
=
print
):
print
(
root
,
"consumes"
,
sum
((
root
/
file
)
.
stat
()
.
st_size
for
file
in
files
),
"bytes in"
,
len
(
files
),
"non-directory files"
)
if
'__pycache__'
in
dirs
:
dirs
.
remove
(
'__pycache__'
)
This next example is a simple implementation of
.
Walking the tree bottom-up is essential as
doesnât allow
deleting a directory before it is empty:
# Delete everything reachable from the directory "top".
# CAUTION:  This is dangerous! For example, if top == Path('/'),
# it could delete all of your files.
for
root
,
dirs
,
files
in
top
.
walk
(
top_down
=
False
):
for
name
in
files
:
(
root
/
name
)
.
unlink
()
for
name
in
dirs
:
(
root
/
name
)
.
rmdir
()
Added in version 3.12.
Path.
touch
(
mode
=
0o666
,
exist_ok
=
True
)
Create a file at this given path.  If
mode
is given, it is combined
with the processâs
umask
value to determine the file mode and access
flags.  If the file already exists, the function succeeds when
exist_ok
is true (and its modification time is updated to the current time),
otherwise
is raised.
See also
The
,
and
methods are often used to create files.
Path.
mkdir
(
mode
=
0o777
,
parents
=
False
,
exist_ok
=
False
)
Create a new directory at this given path.  If
mode
is given, it is
combined with the processâs
umask
value to determine the file mode
and access flags.  If the path already exists,
is raised.
If
parents
is true, any missing parents of this path are created
as needed; they are created with the default permissions without taking
mode
into account (mimicking the POSIX
mkdir
-p
command).
If
parents
is false (the default), a missing parent raises
.
If
exist_ok
is false (the default),
is
raised if the target directory already exists.
If
exist_ok
is true,
will not be raised unless the given
path already exists in the file system and is not a directory (same
behavior as the POSIX
mkdir
-p
command).
Changed in version 3.5:
The
exist_ok
parameter was added.
Path.
symlink_to
(
target
,
target_is_directory
=
False
)
Make this path a symbolic link pointing to
target
.
On Windows, a symlink represents either a file or a directory, and does not
morph to the target dynamically.  If the target is present, the type of the
symlink will be created to match. Otherwise, the symlink will be created
as a directory if
target_is_directory
is true or a file symlink (the
default) otherwise.  On non-Windows platforms,
target_is_directory
is ignored.
>>>
p
=
Path
(
'mylink'
)
>>>
p
.
symlink_to
(
'setup.py'
)
>>>
p
.
resolve
()
PosixPath('/home/antoine/pathlib/setup.py')
>>>
p
.
stat
()
.
st_size
956
>>>
p
.
lstat
()
.
st_size
8
Note
The order of arguments (link, target) is the reverse
of
âs.
Changed in version 3.13:
Raises
if
is not
available. In previous versions,
was raised.
Path.
hardlink_to
(
target
)
Make this path a hard link to the same file as
target
.
Note
The order of arguments (link, target) is the reverse
of
âs.
Added in version 3.10.
Changed in version 3.13:
Raises
if
is not
available. In previous versions,
was raised.
Path.
rename
(
target
)
Rename this file or directory to the given
target
, and return a new
Path
instance pointing to
target
.  On Unix, if
target
exists
and is a file, it will be replaced silently if the user has permission.
On Windows, if
target
exists,
will be raised.
target
can be either a string or another path object:
>>>
p
=
Path
(
'foo'
)
>>>
p
.
open
(
'w'
)
.
write
(
'some text'
)
9
>>>
target
=
Path
(
'bar'
)
>>>
p
.
rename
(
target
)
PosixPath('bar')
>>>
target
.
open
()
.
read
()
'some text'
The target path may be absolute or relative. Relative paths are interpreted
relative to the current working directory,
not
the directory of the
Path
object.
It is implemented in terms of
and gives the same guarantees.
Changed in version 3.8:
Added return value, return the new
Path
instance.
Path.
replace
(
target
)
Rename this file or directory to the given
target
, and return a new
Path
instance pointing to
target
.  If
target
points to an
existing file or empty directory, it will be unconditionally replaced.
The target path may be absolute or relative. Relative paths are interpreted
relative to the current working directory,
not
the directory of the
Path
object.
Changed in version 3.8:
Added return value, return the new
Path
instance.
Path.
unlink
(
missing_ok
=
False
)
Remove this file or symbolic link.  If the path points to a directory,
use
instead.
If
missing_ok
is false (the default),
is
raised if the path does not exist.
If
missing_ok
is true,
exceptions will be
ignored (same behavior as the POSIX
rm
-f
command).
Changed in version 3.8:
The
missing_ok
parameter was added.
Path.
rmdir
(
)
Remove this directory.  The directory must be empty.
Path.
owner
(
*
,
follow_symlinks
=
True
)
Return the name of the user owning the file.
is raised
if the fileâs user identifier (UID) isnât found in the system database.
This method normally follows symlinks; to get the owner of the symlink, add
the argument
follow_symlinks=False
.
Changed in version 3.13:
Raises
if the
module is not
available. In earlier versions,
was raised.
Changed in version 3.13:
The
follow_symlinks
parameter was added.
Path.
group
(
*
,
follow_symlinks
=
True
)
Return the name of the group owning the file.
is raised
if the fileâs group identifier (GID) isnât found in the system database.
This method normally follows symlinks; to get the group of the symlink, add
the argument
follow_symlinks=False
.
Changed in version 3.13:
Raises
if the
module is not
available. In earlier versions,
was raised.
Changed in version 3.13:
The
follow_symlinks
parameter was added.
Path.
chmod
(
mode
,
*
,
follow_symlinks
=
True
)
Change the file mode and permissions, like
.
This method normally follows symlinks. Some Unix flavours support changing
permissions on the symlink itself; on these platforms you may add the
argument
follow_symlinks=False
, or use
.
>>>
p
=
Path
(
'setup.py'
)
>>>
p
.
stat
()
.
st_mode
33277
>>>
p
.
chmod
(
0o444
)
>>>
p
.
stat
()
.
st_mode
33060
Changed in version 3.10:
The
follow_symlinks
parameter was added.
Path.
lchmod
(
mode
)
Like
but, if the path points to a symbolic link, the
symbolic linkâs mode is changed rather than its targetâs.
The following wildcards are supported in patterns for
,
and
:
**
(entire segment)
Matches any number of file or directory segments, including zero.
*
(entire segment)
Matches one file or directory segment.
*
(part of a segment)
Matches any number of non-separator characters, including zero.
?
Matches one non-separator character.
[seq]
Matches one character in
seq
, where
seq
is a sequence of characters.
Range expressions are supported; for example,
[a-z]
matches any lowercase ASCII letter.
Multiple ranges can be combined:
[a-zA-Z0-9_]
matches any ASCII letter, digit, or underscore.
[!seq]
Matches one character not in
seq
, where
seq
follows the same rules as above.
For a literal match, wrap the meta-characters in brackets.
For example,
"[?]"
matches the character
"?"
.
The â
**
â wildcard enables recursive globbing. A few examples:
Pattern
Meaning
â
**/*
â
Any path with at least one segment.
â
**/*.py
â
Any path with a final segment ending â
.py
â.
â
assets/**
â
Any path starting with â
assets/
â.
â
assets/**/*
â
Any path starting with â
assets/
â, excluding â
assets/
â itself.
Note
Globbing with the â
**
â wildcard visits every directory in the tree.
Large directory trees may take a long time to search.
Changed in version 3.13:
Globbing with a pattern that ends with â
**
â returns both files and
directories. In previous versions, only directories were returned.
In
and
, a trailing slash may be added to
the pattern to match only directories.
Changed in version 3.11:
Globbing with a pattern that ends with a pathname components separator
(
or
) returns only directories.
The patterns accepted and results generated by
and
differ slightly from those by the
module:
Files beginning with a dot are not special in pathlib. This is
like passing
include_hidden=True
to
.
â
**
â pattern components are always recursive in pathlib. This is like
passing
recursive=True
to
.
â
**
â pattern components do not follow symlinks by default in pathlib.
This behaviour has no equivalent in
, but you can pass
recurse_symlinks=True
to
for compatible behaviour.
Like all
and
objects, the values returned
from
and
donât include trailing
slashes.
The values returned from pathlibâs
path.glob()
and
path.rglob()
include the
path
as a prefix, unlike the results of
glob.glob(root_dir=path)
.
The values returned from pathlibâs
path.glob()
and
path.rglob()
may include
path
itself, for example when globbing â
**
â, whereas the
results of
glob.glob(root_dir=path)
never include an empty string that
would correspond to
path
.
pathlib implements path operations using
and
objects, and so itâs said to be
object-oriented
. On the other hand, the
and
modules supply functions that work with low-level
str
and
bytes
objects, which is a more
procedural
approach. Some
users consider the object-oriented style to be more readable.
Many functions in
and
support
bytes
paths and
. These features arenât
available in pathlib.
Pythonâs
str
and
bytes
types, and portions of the
and
modules, are written in C and are very speedy. pathlib is
written in pure Python and is often slower, but rarely slow enough to matter.
pathlibâs path normalization is slightly more opinionated and consistent than
. For example, whereas
eliminates
â
..
â segments from a path, which may change its meaning if symlinks are
involved,
preserves these segments for greater safety.
pathlibâs path normalization may render it unsuitable for some applications:
pathlib normalizes
Path("my_folder/")
to
Path("my_folder")
, which
changes a pathâs meaning when supplied to various operating system APIs and
command-line utilities. Specifically, the absence of a trailing separator
may allow the path to be resolved as either a file or directory, rather
than a directory only.
pathlib normalizes
Path("./my_program")
to
Path("my_program")
,
which changes a pathâs meaning when used as an executable search path, such
as in a shell or when spawning a child process. Specifically, the absence
of a separator in the path may force it to be looked up in
PATH
rather than the current directory.
As a consequence of these differences, pathlib is not a drop-in replacement
for
.
Below is a table mapping various
functions to their corresponding
/
equivalent.
and
,
,
,
Footnotes
[
]
calls
to make paths
absolute and remove â
..
â parts, whereas
is a lexical operation that raises
when its inputsâ
anchors differ (e.g. if one path is absolute and the other relative.)
[
]
returns the path unchanged if the home
directory canât be resolved, whereas
raises
.
[
]
removes â
..
â components without resolving
symlinks, which may change the meaning of the path, whereas
leaves any â
..
â components in the path.
[
]
always follows symlinks when categorizing paths into
dirnames
and
filenames
, whereas
categorizes all
symlinks into
filenames
when
follow_symlinks
is false (the default.)