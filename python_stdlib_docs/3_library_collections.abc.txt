Added in version 3.3:
Formerly, this module was part of the
module.
Source code:
This module provides
that
can be used to test whether a class provides a particular interface; for
example, whether it is
or whether it is a
.
An
or
test for an interface works in one
of three ways.
A newly written class can inherit directly from one of the
abstract base classes.  The class must supply the required abstract
methods.  The remaining mixin methods come from inheritance and can be
overridden if desired.  Other methods may be added as needed:
class
C
(
Sequence
):
# Direct inheritance
def
__init__
(
self
):
...
# Extra method not required by the ABC
def
__getitem__
(
self
,
index
):
...
# Required abstract method
def
__len__
(
self
):
...
# Required abstract method
def
count
(
self
,
value
):
...
# Optionally override a mixin method
>>>
issubclass
(
C
,
Sequence
)
True
>>>
isinstance
(
C
(),
Sequence
)
True
Existing classes and built-in classes can be registered as âvirtual
subclassesâ of the ABCs.  Those classes should define the full API
including all of the abstract methods and all of the mixin methods.
This lets users rely on
or
tests
to determine whether the full interface is supported.  The exception to
this rule is for methods that are automatically inferred from the rest
of the API:
class
D
:
# No inheritance
def
__init__
(
self
):
...
# Extra method not required by the ABC
def
__getitem__
(
self
,
index
):
...
# Abstract method
def
__len__
(
self
):
...
# Abstract method
def
count
(
self
,
value
):
...
# Mixin method
def
index
(
self
,
value
):
...
# Mixin method
Sequence
.
register
(
D
)
# Register instead of inherit
>>>
issubclass
(
D
,
Sequence
)
True
>>>
isinstance
(
D
(),
Sequence
)
True
In this example, class
D
does not need to define
__contains__
,
__iter__
, and
__reversed__
because the
, the
logic, and the
function automatically fall back to
using
__getitem__
and
__len__
.
Some simple interfaces are directly recognizable by the presence of
the required methods (unless those methods have been set to
):
class
E
:
def
__iter__
(
self
):
...
def
__next__
(
self
):
...
>>>
issubclass
(
E
,
Iterable
)
True
>>>
isinstance
(
E
(),
Iterable
)
True
Complex interfaces do not support this last technique because an
interface is more than just the presence of method names.  Interfaces
specify semantics and relationships between methods that cannot be
inferred solely from the presence of specific method names.  For
example, knowing that a class supplies
__getitem__
,
__len__
, and
__iter__
is insufficient for distinguishing a
from
a
.
Added in version 3.9:
These abstract classes now support
[]
. See
and
.
The collections module offers the following
:
ABC
Inherits from
Abstract Methods
Mixin Methods
__contains__
__hash__
__iter__
__next__
__iter__
__reversed__
send
,
throw
close
,
__iter__
,
__next__
__len__
__call__
,
,
__contains__
,
__iter__
,
__len__
,
__getitem__
,
__len__
__contains__
,
__iter__
,
__reversed__
,
index
, and
count
__getitem__
,
__setitem__
,
__delitem__
,
__len__
,
insert
Inherited
methods and
append
,
clear
,
reverse
,
extend
,
pop
,
remove
, and
__iadd__
__getitem__
,
__len__
Inherited
methods
__contains__
,
__iter__
,
__len__
__le__
,
__lt__
,
__eq__
,
__ne__
,
__gt__
,
__ge__
,
__and__
,
__or__
,
__sub__
,
__rsub__
,
__xor__
,
__rxor__
and
isdisjoint
__contains__
,
__iter__
,
__len__
,
add
,
discard
Inherited
methods and
clear
,
pop
,
remove
,
__ior__
,
__iand__
,
__ixor__
, and
__isub__
__getitem__
,
__iter__
,
__len__
__contains__
,
keys
,
items
,
values
,
get
,
__eq__
, and
__ne__
__getitem__
,
__setitem__
,
__delitem__
,
__iter__
,
__len__
Inherited
methods and
pop
,
popitem
,
clear
,
update
,
and
setdefault
__init__
,
__len__
and
__repr__
,
__contains__
,
__iter__
,
__contains__
,
__iter__
,
__contains__
,
__iter__
__await__
send
,
throw
close
__aiter__
__anext__
__aiter__
asend
,
athrow
aclose
,
__aiter__
,
__anext__
__buffer__
Footnotes
[
1
]
(
,
,
,
,
,
,
,
,
,
,
,
,
,
,
)
These ABCs override
to support
testing an interface by verifying the required methods are present
and have not been set to
.  This only works for simple
interfaces.  More complex interfaces require registration or direct
subclassing.
[
]
Checking
isinstance(obj,
Iterable)
detects classes that are
registered as
or that have an
method, but it does not detect classes that iterate with the
method.  The only reliable way to determine
whether an object is
is to call
iter(obj)
.
class
collections.abc.
Container
ABC for classes that provide the
method.
class
collections.abc.
Hashable
ABC for classes that provide the
method.
class
collections.abc.
Sized
ABC for classes that provide the
method.
class
collections.abc.
Callable
ABC for classes that provide the
method.
See
for details on how to use
Callable
in type annotations.
class
collections.abc.
Iterable
ABC for classes that provide the
method.
Checking
isinstance(obj,
Iterable)
detects classes that are registered
as
or that have an
method,
but it does
not detect classes that iterate with the
method.
The only reliable way to determine whether an object is
is to call
iter(obj)
.
class
collections.abc.
Collection
ABC for sized iterable container classes.
Added in version 3.6.
class
collections.abc.
Iterator
ABC for classes that provide the
and
methods.  See also the definition of
.
class
collections.abc.
Reversible
ABC for iterable classes that also provide the
method.
Added in version 3.6.
class
collections.abc.
Generator
ABC for
classes that implement the protocol defined in
that extends
with the
,
and
methods.
See
for details on using
Generator
in type annotations.
Added in version 3.5.
class
collections.abc.
Sequence
class
collections.abc.
MutableSequence
class
collections.abc.
ByteString
ABCs for read-only and mutable
.
Implementation note: Some of the mixin methods, such as
,
and
index()
, make
repeated calls to the underlying
method.
Consequently, if
is implemented with constant
access speed, the mixin methods will have linear performance;
however, if the underlying method is linear (as it would be with a
linked list), the mixins will have quadratic performance and will
likely need to be overridden.
Changed in version 3.5:
The index() method added support for
stop
and
start
arguments.
Deprecated since version 3.12, will be removed in version 3.14:
The
ABC has been deprecated.
For use in typing, prefer a union, like
bytes
|
bytearray
, or
.
For use as an ABC, prefer
or
.
class
collections.abc.
Set
class
collections.abc.
MutableSet
ABCs for read-only and mutable
.
class
collections.abc.
Mapping
class
collections.abc.
MutableMapping
ABCs for read-only and mutable
.
class
collections.abc.
MappingView
class
collections.abc.
ItemsView
class
collections.abc.
KeysView
class
collections.abc.
ValuesView
ABCs for mapping, items, keys, and values
.
class
collections.abc.
Awaitable
ABC for
objects, which can be used in
expressions.  Custom implementations must provide the
method.
objects and instances of the
ABC are all instances of this ABC.
Note
In CPython, generator-based coroutines (
decorated with
) are
awaitables
, even though they do not have an
method.
Using
isinstance(gencoro,
Awaitable)
for them will return
False
.
Use
to detect them.
Added in version 3.5.
class
collections.abc.
Coroutine
ABC for
compatible classes.  These implement the
following methods, defined in
:
,
, and
.  Custom implementations must also implement
.  All
instances are also
instances of
.
Note
In CPython, generator-based coroutines (
decorated with
) are
awaitables
, even though they do not have an
method.
Using
isinstance(gencoro,
Coroutine)
for them will return
False
.
Use
to detect them.
See
for details on using
Coroutine
in type annotations.
The variance and order of type parameters correspond to those of
.
Added in version 3.5.
class
collections.abc.
AsyncIterable
ABC for classes that provide an
__aiter__
method.  See also the
definition of
.
Added in version 3.5.
class
collections.abc.
AsyncIterator
ABC for classes that provide
__aiter__
and
__anext__
methods.  See also the definition of
.
Added in version 3.5.
class
collections.abc.
AsyncGenerator
ABC for
classes that implement the protocol
defined in
and
.
See
for details on using
AsyncGenerator
in type annotations.
Added in version 3.6.
class
collections.abc.
Buffer
ABC for classes that provide the
method,
implementing the
. See
.
Added in version 3.12.
ABCs allow us to ask classes or instances if they provide
particular functionality, for example:
size
=
None
if
isinstance
(
myvar
,
collections
.
abc
.
Sized
):
size
=
len
(
myvar
)
Several of the ABCs are also useful as mixins that make it easier to develop
classes supporting container APIs.  For example, to write a class supporting
the full
API, it is only necessary to supply the three underlying
abstract methods:
,
, and
. The ABC supplies the remaining methods such as
__and__()
and
:
class
ListBasedSet
(
collections
.
abc
.
Set
):
''' Alternate set implementation favoring space over speed
and not requiring the set elements to be hashable. '''
def
__init__
(
self
,
iterable
):
self
.
elements
=
lst
=
[]
for
value
in
iterable
:
if
value
not
in
lst
:
lst
.
append
(
value
)
def
__iter__
(
self
):
return
iter
(
self
.
elements
)
def
__contains__
(
self
,
value
):
return
value
in
self
.
elements
def
__len__
(
self
):
return
len
(
self
.
elements
)
s1
=
ListBasedSet
(
'abcdef'
)
s2
=
ListBasedSet
(
'defghi'
)
overlap
=
s1
&
s2
# The __and__() method is supported automatically
Notes on using
and
as a mixin:
Since some set operations create new sets, the default mixin methods need
a way to create new instances from an
. The class constructor is
assumed to have a signature in the form
ClassName(iterable)
.
That assumption is factored-out to an internal
called
_from_iterable()
which calls
cls(iterable)
to produce a new set.
If the
mixin is being used in a class with a different
constructor signature, you will need to override
_from_iterable()
with a classmethod or regular method that can construct new instances from
an iterable argument.
To override the comparisons (presumably for speed, as the
semantics are fixed), redefine
and
,
then the other operations will automatically follow suit.
The
mixin provides a
_hash()
method to compute a hash value
for the set; however,
is not defined because not all sets
are
or immutable.  To add set hashability using mixins,
inherit from both
and
, then define
__hash__
=
Set._hash
.
See also
for an
example built on
.
For more about ABCs, see the
module and
.